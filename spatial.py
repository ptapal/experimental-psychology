#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
This experiment was created using PsychoPy3 Experiment Builder (v2024.2.4),
    on Wed Jun  4 11:04:23 2025
If you publish work using this script the most relevant publication is:

    Peirce J, Gray JR, Simpson S, MacAskill M, Höchenberger R, Sogo H, Kastman E, Lindeløv JK. (2019) 
        PsychoPy2: Experiments in behavior made easy Behav Res 51: 195. 
        https://doi.org/10.3758/s13428-018-01193-y

"""

# --- Import packages ---
from psychopy import locale_setup
from psychopy import prefs
from psychopy import plugins
plugins.activatePlugins()
prefs.hardware['audioLib'] = 'ptb'
prefs.hardware['audioLatencyMode'] = '3'
from psychopy import sound, gui, visual, core, data, event, logging, clock, colors, layout, hardware
from psychopy.tools import environmenttools
from psychopy.constants import (NOT_STARTED, STARTED, PLAYING, PAUSED,
                                STOPPED, FINISHED, PRESSED, RELEASED, FOREVER, priority)

import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import (sin, cos, tan, log, log10, pi, average,
                   sqrt, std, deg2rad, rad2deg, linspace, asarray)
from numpy.random import random, randint, normal, shuffle, choice as randchoice
import os  # handy system and path functions
import sys  # to get file system encoding

import psychopy.iohub as io
from psychopy.hardware import keyboard

# --- Setup global variables (available in all functions) ---
# create a device manager to handle hardware (keyboards, mice, mirophones, speakers, etc.)
deviceManager = hardware.DeviceManager()
# ensure that relative paths start from the same directory as this script
_thisDir = os.path.dirname(os.path.abspath(__file__))
# store info about the experiment session
psychopyVersion = '2024.2.4'
expName = 'spatial'  # from the Builder filename that created this script
# information about this experiment
expInfo = {
    'participant': f"{randint(0, 999999):06.0f}",
    'session': '001',
    'date|hid': data.getDateStr(),
    'expName|hid': expName,
    'psychopyVersion|hid': psychopyVersion,
}

# --- Define some variables which will change depending on pilot mode ---
'''
To run in pilot mode, either use the run/pilot toggle in Builder, Coder and Runner, 
or run the experiment with `--pilot` as an argument. To change what pilot 
#mode does, check out the 'Pilot mode' tab in preferences.
'''
# work out from system args whether we are running in pilot mode
PILOTING = core.setPilotModeFromArgs()
# start off with values from experiment settings
_fullScr = True
_winSize = [1280, 720]
# if in pilot mode, apply overrides according to preferences
if PILOTING:
    # force windowed mode
    if prefs.piloting['forceWindowed']:
        _fullScr = False
        # set window size
        _winSize = prefs.piloting['forcedWindowSize']

def showExpInfoDlg(expInfo):
    """
    Show participant info dialog.
    Parameters
    ==========
    expInfo : dict
        Information about this experiment.
    
    Returns
    ==========
    dict
        Information about this experiment.
    """
    # show participant info dialog
    dlg = gui.DlgFromDict(
        dictionary=expInfo, sortKeys=False, title=expName, alwaysOnTop=True
    )
    if dlg.OK == False:
        core.quit()  # user pressed cancel
    # return expInfo
    return expInfo


def setupData(expInfo, dataDir=None):
    """
    Make an ExperimentHandler to handle trials and saving.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    dataDir : Path, str or None
        Folder to save the data to, leave as None to create a folder in the current directory.    
    Returns
    ==========
    psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    # remove dialog-specific syntax from expInfo
    for key, val in expInfo.copy().items():
        newKey, _ = data.utils.parsePipeSyntax(key)
        expInfo[newKey] = expInfo.pop(key)
    
    # data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc
    if dataDir is None:
        dataDir = _thisDir
    filename = u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])
    # make sure filename is relative to dataDir
    if os.path.isabs(filename):
        dataDir = os.path.commonprefix([dataDir, filename])
        filename = os.path.relpath(filename, dataDir)
    
    # an ExperimentHandler isn't essential but helps with data saving
    thisExp = data.ExperimentHandler(
        name=expName, version='',
        extraInfo=expInfo, runtimeInfo=None,
        originPath='/Users/a1234/Downloads/spatial.py',
        savePickle=True, saveWideText=True,
        dataFileName=dataDir + os.sep + filename, sortColumns='time'
    )
    thisExp.setPriority('thisRow.t', priority.CRITICAL)
    thisExp.setPriority('expName', priority.LOW)
    # return experiment handler
    return thisExp


def setupLogging(filename):
    """
    Setup a log file and tell it what level to log at.
    
    Parameters
    ==========
    filename : str or pathlib.Path
        Filename to save log file and data files as, doesn't need an extension.
    
    Returns
    ==========
    psychopy.logging.LogFile
        Text stream to receive inputs from the logging system.
    """
    # set how much information should be printed to the console / app
    if PILOTING:
        logging.console.setLevel(
            prefs.piloting['pilotConsoleLoggingLevel']
        )
    else:
        logging.console.setLevel('warning')
    # save a log file for detail verbose info
    logFile = logging.LogFile(filename+'.log')
    if PILOTING:
        logFile.setLevel(
            prefs.piloting['pilotLoggingLevel']
        )
    else:
        logFile.setLevel(
            logging.getLevel('info')
        )
    
    return logFile


def setupWindow(expInfo=None, win=None):
    """
    Setup the Window
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    win : psychopy.visual.Window
        Window to setup - leave as None to create a new window.
    
    Returns
    ==========
    psychopy.visual.Window
        Window in which to run this experiment.
    """
    if PILOTING:
        logging.debug('Fullscreen settings ignored as running in pilot mode.')
    
    if win is None:
        # if not given a window to setup, make one
        win = visual.Window(
            size=_winSize, fullscr=_fullScr, screen=0,
            winType='pyglet', allowGUI=True, allowStencil=False,
            monitor='testMonitor', color=[0,0,0], colorSpace='rgb',
            backgroundImage='', backgroundFit='none',
            blendMode='avg', useFBO=True,
            units='height',
            checkTiming=False  # we're going to do this ourselves in a moment
        )
    else:
        # if we have a window, just set the attributes which are safe to set
        win.color = [0,0,0]
        win.colorSpace = 'rgb'
        win.backgroundImage = ''
        win.backgroundFit = 'none'
        win.units = 'height'
    if expInfo is not None:
        # get/measure frame rate if not already in expInfo
        if win._monitorFrameRate is None:
            win._monitorFrameRate = win.getActualFrameRate(infoMsg='Attempting to measure frame rate of screen, please wait...')
        expInfo['frameRate'] = win._monitorFrameRate
    win.hideMessage()
    # show a visual indicator if we're in piloting mode
    if PILOTING and prefs.piloting['showPilotingIndicator']:
        win.showPilotingIndicator()
    
    return win


def setupDevices(expInfo, thisExp, win):
    """
    Setup whatever devices are available (mouse, keyboard, speaker, eyetracker, etc.) and add them to 
    the device manager (deviceManager)
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window in which to run this experiment.
    Returns
    ==========
    bool
        True if completed successfully.
    """
    # --- Setup input devices ---
    ioConfig = {}
    
    # Setup iohub keyboard
    ioConfig['Keyboard'] = dict(use_keymap='psychopy')
    
    # Setup iohub experiment
    ioConfig['Experiment'] = dict(filename=thisExp.dataFileName)
    
    # Start ioHub server
    ioServer = io.launchHubServer(window=win, **ioConfig)
    
    # store ioServer object in the device manager
    deviceManager.ioServer = ioServer
    
    # create a default keyboard (e.g. to check for escape)
    if deviceManager.getDevice('defaultKeyboard') is None:
        deviceManager.addDevice(
            deviceClass='keyboard', deviceName='defaultKeyboard', backend='iohub'
        )
    if deviceManager.getDevice('key_resp') is None:
        # initialise key_resp
        key_resp = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp',
        )
    if deviceManager.getDevice('key_resp_2') is None:
        # initialise key_resp_2
        key_resp_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_2',
        )
    if deviceManager.getDevice('key_resp_3') is None:
        # initialise key_resp_3
        key_resp_3 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_3',
        )
    if deviceManager.getDevice('key_resp_4') is None:
        # initialise key_resp_4
        key_resp_4 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_4',
        )
    if deviceManager.getDevice('key_resp_5') is None:
        # initialise key_resp_5
        key_resp_5 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_5',
        )
    if deviceManager.getDevice('right_keyresp') is None:
        # initialise right_keyresp
        right_keyresp = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='right_keyresp',
        )
    if deviceManager.getDevice('right_keyresp_2') is None:
        # initialise right_keyresp_2
        right_keyresp_2 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='right_keyresp_2',
        )
    if deviceManager.getDevice('key_resp_6') is None:
        # initialise key_resp_6
        key_resp_6 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_6',
        )
    if deviceManager.getDevice('key_resp_7') is None:
        # initialise key_resp_7
        key_resp_7 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_7',
        )
    if deviceManager.getDevice('key_resp_8') is None:
        # initialise key_resp_8
        key_resp_8 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_8',
        )
    if deviceManager.getDevice('key_resp_9') is None:
        # initialise key_resp_9
        key_resp_9 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_9',
        )
    if deviceManager.getDevice('key_resp_10') is None:
        # initialise key_resp_10
        key_resp_10 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_10',
        )
    if deviceManager.getDevice('key_resp_11') is None:
        # initialise key_resp_11
        key_resp_11 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_11',
        )
    if deviceManager.getDevice('key_resp_12') is None:
        # initialise key_resp_12
        key_resp_12 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_12',
        )
    if deviceManager.getDevice('key_resp_13') is None:
        # initialise key_resp_13
        key_resp_13 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_13',
        )
    if deviceManager.getDevice('key_resp_21') is None:
        # initialise key_resp_21
        key_resp_21 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_21',
        )
    if deviceManager.getDevice('key_resp_15') is None:
        # initialise key_resp_15
        key_resp_15 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_15',
        )
    if deviceManager.getDevice('key_resp_22') is None:
        # initialise key_resp_22
        key_resp_22 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_22',
        )
    if deviceManager.getDevice('key_resp_16') is None:
        # initialise key_resp_16
        key_resp_16 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_16',
        )
    if deviceManager.getDevice('key_resp_24') is None:
        # initialise key_resp_24
        key_resp_24 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_24',
        )
    if deviceManager.getDevice('key_resp_14') is None:
        # initialise key_resp_14
        key_resp_14 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_14',
        )
    if deviceManager.getDevice('key_resp_23') is None:
        # initialise key_resp_23
        key_resp_23 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_23',
        )
    if deviceManager.getDevice('key_resp_17') is None:
        # initialise key_resp_17
        key_resp_17 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_17',
        )
    if deviceManager.getDevice('key_resp_25') is None:
        # initialise key_resp_25
        key_resp_25 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_25',
        )
    if deviceManager.getDevice('key_resp_18') is None:
        # initialise key_resp_18
        key_resp_18 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_18',
        )
    if deviceManager.getDevice('key_resp_28') is None:
        # initialise key_resp_28
        key_resp_28 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_28',
        )
    if deviceManager.getDevice('key_resp_19') is None:
        # initialise key_resp_19
        key_resp_19 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_19',
        )
    if deviceManager.getDevice('key_resp_26') is None:
        # initialise key_resp_26
        key_resp_26 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_26',
        )
    if deviceManager.getDevice('key_resp_20') is None:
        # initialise key_resp_20
        key_resp_20 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_20',
        )
    if deviceManager.getDevice('key_resp_27') is None:
        # initialise key_resp_27
        key_resp_27 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_27',
        )
    if deviceManager.getDevice('key_resp_29') is None:
        # initialise key_resp_29
        key_resp_29 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_29',
        )
    if deviceManager.getDevice('key_resp_30') is None:
        # initialise key_resp_30
        key_resp_30 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_30',
        )
    if deviceManager.getDevice('key_resp_31') is None:
        # initialise key_resp_31
        key_resp_31 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_31',
        )
    if deviceManager.getDevice('key_resp_32') is None:
        # initialise key_resp_32
        key_resp_32 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_32',
        )
    if deviceManager.getDevice('key_resp_33') is None:
        # initialise key_resp_33
        key_resp_33 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_33',
        )
    if deviceManager.getDevice('key_resp_34') is None:
        # initialise key_resp_34
        key_resp_34 = deviceManager.addDevice(
            deviceClass='keyboard',
            deviceName='key_resp_34',
        )
    # return True if completed successfully
    return True

def pauseExperiment(thisExp, win=None, timers=[], playbackComponents=[]):
    """
    Pause this experiment, preventing the flow from advancing to the next routine until resumed.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window for this experiment.
    timers : list, tuple
        List of timers to reset once pausing is finished.
    playbackComponents : list, tuple
        List of any components with a `pause` method which need to be paused.
    """
    # if we are not paused, do nothing
    if thisExp.status != PAUSED:
        return
    
    # start a timer to figure out how long we're paused for
    pauseTimer = core.Clock()
    # pause any playback components
    for comp in playbackComponents:
        comp.pause()
    # make sure we have a keyboard
    defaultKeyboard = deviceManager.getDevice('defaultKeyboard')
    if defaultKeyboard is None:
        defaultKeyboard = deviceManager.addKeyboard(
            deviceClass='keyboard',
            deviceName='defaultKeyboard',
            backend='ioHub',
        )
    # run a while loop while we wait to unpause
    while thisExp.status == PAUSED:
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=['escape']):
            endExperiment(thisExp, win=win)
        # sleep 1ms so other threads can execute
        clock.time.sleep(0.001)
    # if stop was requested while paused, quit
    if thisExp.status == FINISHED:
        endExperiment(thisExp, win=win)
    # resume any playback components
    for comp in playbackComponents:
        comp.play()
    # reset any timers
    for timer in timers:
        timer.addTime(-pauseTimer.getTime())


def run(expInfo, thisExp, win, globalClock=None, thisSession=None):
    """
    Run the experiment flow.
    
    Parameters
    ==========
    expInfo : dict
        Information about this experiment, created by the `setupExpInfo` function.
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    psychopy.visual.Window
        Window in which to run this experiment.
    globalClock : psychopy.core.clock.Clock or None
        Clock to get global time from - supply None to make a new one.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    # mark experiment as started
    thisExp.status = STARTED
    # make sure window is set to foreground to prevent losing focus
    win.winHandle.activate()
    # make sure variables created by exec are available globally
    exec = environmenttools.setExecEnvironment(globals())
    # get device handles from dict of input devices
    ioServer = deviceManager.ioServer
    # get/create a default keyboard (e.g. to check for escape)
    defaultKeyboard = deviceManager.getDevice('defaultKeyboard')
    if defaultKeyboard is None:
        deviceManager.addDevice(
            deviceClass='keyboard', deviceName='defaultKeyboard', backend='ioHub'
        )
    eyetracker = deviceManager.getDevice('eyetracker')
    # make sure we're running in the directory for this experiment
    os.chdir(_thisDir)
    # get filename from ExperimentHandler for convenience
    filename = thisExp.dataFileName
    frameTolerance = 0.001  # how close to onset before 'same' frame
    endExpNow = False  # flag for 'escape' or other condition => quit the exp
    # get frame duration from frame rate in expInfo
    if 'frameRate' in expInfo and expInfo['frameRate'] is not None:
        frameDur = 1.0 / round(expInfo['frameRate'])
    else:
        frameDur = 1.0 / 60.0  # could not measure, so guess
    
    # Start Code - component code to be run after the window creation
    
    # --- Initialize components for Routine "Intro" ---
    text = visual.TextStim(win=win, name='text',
        text='The Spatial Stroop Task',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.08, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp = keyboard.Keyboard(deviceName='key_resp')
    
    # --- Initialize components for Routine "instr1" ---
    text_2 = visual.TextStim(win=win, name='text_2',
        text='In this next task, you will respond to different visual stimuli as quickly and accurately as possible',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_3 = visual.TextStim(win=win, name='text_3',
        text='Press Space Bar to continue',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_2 = keyboard.Keyboard(deviceName='key_resp_2')
    
    # --- Initialize components for Routine "instr2" ---
    text_4 = visual.TextStim(win=win, name='text_4',
        text='You will need to pay attention to either the direction of the arrow or the meaning of the word that is shown.\n',
        font='Arial',
        pos=(0, 0.1), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_5 = visual.TextStim(win=win, name='text_5',
        text='Press Space Bar to continue',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_3 = keyboard.Keyboard(deviceName='key_resp_3')
    
    # --- Initialize components for Routine "instr3" ---
    text_6 = visual.TextStim(win=win, name='text_6',
        text='For the arrow, you will have to choose its direction:\nleft, right, up, or down, by using the keyboard\n\n',
        font='Arial',
        pos=(0, 0.2), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_7 = visual.TextStim(win=win, name='text_7',
        text='Press Space Bar to continue',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_4 = keyboard.Keyboard(deviceName='key_resp_4')
    text_8 = visual.TextStim(win=win, name='text_8',
        text='Left arrow key (←)\nRight arrow key (→)\nUp arrow key (↑)\nDown arrow key (↓)',
        font='Arial',
        pos=(0, 0.05), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "instr4" ---
    text_9 = visual.TextStim(win=win, name='text_9',
        text='For the words, you will have to classify their meaning as:\nleft, right, up, or down.\n\n',
        font='Arial',
        pos=(0, 0.2), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_10 = visual.TextStim(win=win, name='text_10',
        text='Press Space Bar to continue',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_5 = keyboard.Keyboard(deviceName='key_resp_5')
    text_11 = visual.TextStim(win=win, name='text_11',
        text='Left arrow key (←)\nRight arrow key (→)\nUp arrow key (↑)\nDown arrow key (↓)',
        font='Arial',
        pos=(0, 0.05), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    
    # --- Initialize components for Routine "ex_leftarrow" ---
    blacksquare = visual.Rect(
        win=win, name='blacksquare',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    press_right = visual.TextStim(win=win, name='press_right',
        text='Press the right arrow key to continue',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    right_keyresp = keyboard.Keyboard(deviceName='right_keyresp')
    arrow_r = visual.ShapeStim(
        win=win, name='arrow_r', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    white_cross = visual.ShapeStim(
        win=win, name='white_cross', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    text_12 = visual.TextStim(win=win, name='text_12',
        text='A trial in which you will have to pay attention to the direction of the arrow will look like this:\n',
        font='Arial',
        pos=(0, 0.37), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    
    # --- Initialize components for Routine "ex_RIGHT" ---
    blacksquare_2 = visual.Rect(
        win=win, name='blacksquare_2',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    press_right_2 = visual.TextStim(win=win, name='press_right_2',
        text='Press the right arrow key to continue',
        font='Arial',
        pos=(0, -0.4), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    right_keyresp_2 = keyboard.Keyboard(deviceName='right_keyresp_2')
    white_cross_2 = visual.ShapeStim(
        win=win, name='white_cross_2', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    text_13 = visual.TextStim(win=win, name='text_13',
        text='A trial in which you will have to pay attention to the meaning of the word will look like this:\n',
        font='Arial',
        pos=(0, 0.37), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    RIGHT = visual.TextStim(win=win, name='RIGHT',
        text='RIGHT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-5.0);
    
    # --- Initialize components for Routine "lets_practice" ---
    practice_text = visual.TextStim(win=win, name='practice_text',
        text="Let's practice",
        font='Arial',
        pos=(0, 0.2), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    key_resp_6 = keyboard.Keyboard(deviceName='key_resp_6')
    
    # --- Initialize components for Routine "empty_square" ---
    blacksquare_3 = visual.Rect(
        win=win, name='blacksquare_3',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_3 = visual.ShapeStim(
        win=win, name='white_cross_3', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "LR_squares" ---
    blacksquare_4 = visual.Rect(
        win=win, name='blacksquare_4',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_4 = visual.ShapeStim(
        win=win, name='white_cross_4', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    whitesquare = visual.Rect(
        win=win, name='whitesquare',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    whitesquare_2 = visual.Rect(
        win=win, name='whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    
    # --- Initialize components for Routine "empty_square" ---
    blacksquare_3 = visual.Rect(
        win=win, name='blacksquare_3',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_3 = visual.ShapeStim(
        win=win, name='white_cross_3', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "test1" ---
    blacksquare_5 = visual.Rect(
        win=win, name='blacksquare_5',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_5 = visual.ShapeStim(
        win=win, name='white_cross_5', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    arrow_l = visual.ShapeStim(
        win=win, name='arrow_l', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    key_resp_7 = keyboard.Keyboard(deviceName='key_resp_7')
    # Run 'Begin Experiment' code from code
    feedbackText = ""
    
    
    # --- Initialize components for Routine "feedback" ---
    text_16 = visual.TextStim(win=win, name='text_16',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "empty_square" ---
    blacksquare_3 = visual.Rect(
        win=win, name='blacksquare_3',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_3 = visual.ShapeStim(
        win=win, name='white_cross_3', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "UD_squares" ---
    blacksquare_6 = visual.Rect(
        win=win, name='blacksquare_6',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_6 = visual.ShapeStim(
        win=win, name='white_cross_6', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    up_whitesquare = visual.Rect(
        win=win, name='up_whitesquare',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    down_whitesquare = visual.Rect(
        win=win, name='down_whitesquare',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    
    # --- Initialize components for Routine "empty_square" ---
    blacksquare_3 = visual.Rect(
        win=win, name='blacksquare_3',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_3 = visual.ShapeStim(
        win=win, name='white_cross_3', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "test2" ---
    blacksquare_7 = visual.Rect(
        win=win, name='blacksquare_7',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_7 = visual.ShapeStim(
        win=win, name='white_cross_7', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    arrow_d = visual.ShapeStim(
        win=win, name='arrow_d', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    key_resp_8 = keyboard.Keyboard(deviceName='key_resp_8')
    # Run 'Begin Experiment' code from code_2
    feedbackText = ""
    
    
    # --- Initialize components for Routine "feedback" ---
    text_16 = visual.TextStim(win=win, name='text_16',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "empty_square" ---
    blacksquare_3 = visual.Rect(
        win=win, name='blacksquare_3',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_3 = visual.ShapeStim(
        win=win, name='white_cross_3', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "UD_squares" ---
    blacksquare_6 = visual.Rect(
        win=win, name='blacksquare_6',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_6 = visual.ShapeStim(
        win=win, name='white_cross_6', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    up_whitesquare = visual.Rect(
        win=win, name='up_whitesquare',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    down_whitesquare = visual.Rect(
        win=win, name='down_whitesquare',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    
    # --- Initialize components for Routine "empty_square" ---
    blacksquare_3 = visual.Rect(
        win=win, name='blacksquare_3',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_3 = visual.ShapeStim(
        win=win, name='white_cross_3', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "test3" ---
    blacksquare_8 = visual.Rect(
        win=win, name='blacksquare_8',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_8 = visual.ShapeStim(
        win=win, name='white_cross_8', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_9 = keyboard.Keyboard(deviceName='key_resp_9')
    # Run 'Begin Experiment' code from code_3
    feedbackText = ""
    
    DOWN = visual.TextStim(win=win, name='DOWN',
        text='DOWN',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "feedback" ---
    text_16 = visual.TextStim(win=win, name='text_16',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "empty_square" ---
    blacksquare_3 = visual.Rect(
        win=win, name='blacksquare_3',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_3 = visual.ShapeStim(
        win=win, name='white_cross_3', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "LR_squares" ---
    blacksquare_4 = visual.Rect(
        win=win, name='blacksquare_4',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_4 = visual.ShapeStim(
        win=win, name='white_cross_4', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    whitesquare = visual.Rect(
        win=win, name='whitesquare',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-2.0, interpolate=True)
    whitesquare_2 = visual.Rect(
        win=win, name='whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    
    # --- Initialize components for Routine "empty_square" ---
    blacksquare_3 = visual.Rect(
        win=win, name='blacksquare_3',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_3 = visual.ShapeStim(
        win=win, name='white_cross_3', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    
    # --- Initialize components for Routine "test4" ---
    blacksquare_9 = visual.Rect(
        win=win, name='blacksquare_9',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_9 = visual.ShapeStim(
        win=win, name='white_cross_9', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_10 = keyboard.Keyboard(deviceName='key_resp_10')
    # Run 'Begin Experiment' code from code_4
    feedbackText = ""
    
    LEFT = visual.TextStim(win=win, name='LEFT',
        text='LEFT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-4.0);
    
    # --- Initialize components for Routine "feedback" ---
    text_16 = visual.TextStim(win=win, name='text_16',
        text='',
        font='Arial',
        pos=(0, 0), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "instr5" ---
    text_17 = visual.TextStim(win=win, name='text_17',
        text='From now on, the trials will start. Remember to try to respond as fast and accurate as possible. \n',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_18 = visual.TextStim(win=win, name='text_18',
        text='Press Space Bar to continue',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_11 = keyboard.Keyboard(deviceName='key_resp_11')
    
    # --- Initialize components for Routine "instr6" ---
    text_19 = visual.TextStim(win=win, name='text_19',
        text='You will go over 6 blocks. You can take a short break between blocks.\n\n\n',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_20 = visual.TextStim(win=win, name='text_20',
        text='Whenever you are ready,\npress Space Bar to continue ',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_12 = keyboard.Keyboard(deviceName='key_resp_12')
    
    # --- Initialize components for Routine "block1" ---
    text_21 = visual.TextStim(win=win, name='text_21',
        text='Block 1',
        font='Arial',
        pos=(0, 0.1), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "block1_router" ---
    # Run 'Begin Experiment' code from code_5
    import random  # in Begin Experiment
    
    all_routines = [
        "LEFT_on_right", "RIGHT_on_right", "LEFT_on_left", "RIGHT_on_left",
        "UP_on_up", "DOWN_on_up", "UP_on_down", "DOWN_on_down",
        "leftA_on_right", "leftA_on_left", "rightA_on_right", "rightA_on_left",
        "upA_on_up", "upA_on_down", "downA_on_down", "downA_on_up"
    ]
    
    schedule = random.choices(all_routines)
    trial_index = 0
    
    
    
    
    # --- Initialize components for Routine "LEFT_on_right" ---
    blacksquare_10 = visual.Rect(
        win=win, name='blacksquare_10',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_10 = visual.ShapeStim(
        win=win, name='white_cross_10', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_13 = keyboard.Keyboard(deviceName='key_resp_13')
    LEFT_2 = visual.TextStim(win=win, name='LEFT_2',
        text='LEFT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_3 = visual.Rect(
        win=win, name='whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_4 = visual.Rect(
        win=win, name='whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_right" ---
    blacksquare_18 = visual.Rect(
        win=win, name='blacksquare_18',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_18 = visual.ShapeStim(
        win=win, name='white_cross_18', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_21 = keyboard.Keyboard(deviceName='key_resp_21')
    arrow_l_2 = visual.ShapeStim(
        win=win, name='arrow_l_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_5 = visual.Rect(
        win=win, name='whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_12 = visual.Rect(
        win=win, name='whitesquare_12',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "LEFT_on_left" ---
    blacksquare_12 = visual.Rect(
        win=win, name='blacksquare_12',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_12 = visual.ShapeStim(
        win=win, name='white_cross_12', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_15 = keyboard.Keyboard(deviceName='key_resp_15')
    LEFT_4 = visual.TextStim(win=win, name='LEFT_4',
        text='LEFT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_6 = visual.Rect(
        win=win, name='whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_13 = visual.Rect(
        win=win, name='whitesquare_13',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_left" ---
    blacksquare_19 = visual.Rect(
        win=win, name='blacksquare_19',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_19 = visual.ShapeStim(
        win=win, name='white_cross_19', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_22 = keyboard.Keyboard(deviceName='key_resp_22')
    arrow_l_3 = visual.ShapeStim(
        win=win, name='arrow_l_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_7 = visual.Rect(
        win=win, name='whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_14 = visual.Rect(
        win=win, name='whitesquare_14',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_left" ---
    blacksquare_13 = visual.Rect(
        win=win, name='blacksquare_13',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_13 = visual.ShapeStim(
        win=win, name='white_cross_13', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_16 = keyboard.Keyboard(deviceName='key_resp_16')
    RIGHT_5 = visual.TextStim(win=win, name='RIGHT_5',
        text='RIGHT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_8 = visual.Rect(
        win=win, name='whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_15 = visual.Rect(
        win=win, name='whitesquare_15',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_left" ---
    blacksquare_21 = visual.Rect(
        win=win, name='blacksquare_21',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_21 = visual.ShapeStim(
        win=win, name='white_cross_21', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_24 = keyboard.Keyboard(deviceName='key_resp_24')
    arrow_l_5 = visual.ShapeStim(
        win=win, name='arrow_l_5', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_9 = visual.Rect(
        win=win, name='whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_16 = visual.Rect(
        win=win, name='whitesquare_16',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_right" ---
    blacksquare_11 = visual.Rect(
        win=win, name='blacksquare_11',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_11 = visual.ShapeStim(
        win=win, name='white_cross_11', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_14 = keyboard.Keyboard(deviceName='key_resp_14')
    RIGHT_3 = visual.TextStim(win=win, name='RIGHT_3',
        text='RIGHT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_10 = visual.Rect(
        win=win, name='whitesquare_10',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_17 = visual.Rect(
        win=win, name='whitesquare_17',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_right" ---
    blacksquare_20 = visual.Rect(
        win=win, name='blacksquare_20',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_20 = visual.ShapeStim(
        win=win, name='white_cross_20', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_23 = keyboard.Keyboard(deviceName='key_resp_23')
    arrow_l_4 = visual.ShapeStim(
        win=win, name='arrow_l_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_11 = visual.Rect(
        win=win, name='whitesquare_11',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_18 = visual.Rect(
        win=win, name='whitesquare_18',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_up" ---
    blacksquare_14 = visual.Rect(
        win=win, name='blacksquare_14',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_14 = visual.ShapeStim(
        win=win, name='white_cross_14', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_17 = keyboard.Keyboard(deviceName='key_resp_17')
    UP_5 = visual.TextStim(win=win, name='UP_5',
        text='UP',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_2 = visual.Rect(
        win=win, name='up_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_2 = visual.Rect(
        win=win, name='down_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_up" ---
    blacksquare_22 = visual.Rect(
        win=win, name='blacksquare_22',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_22 = visual.ShapeStim(
        win=win, name='white_cross_22', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_25 = keyboard.Keyboard(deviceName='key_resp_25')
    arrow_u = visual.ShapeStim(
        win=win, name='arrow_u', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_3 = visual.Rect(
        win=win, name='up_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_3 = visual.Rect(
        win=win, name='down_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_up" ---
    blacksquare_15 = visual.Rect(
        win=win, name='blacksquare_15',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_15 = visual.ShapeStim(
        win=win, name='white_cross_15', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_18 = keyboard.Keyboard(deviceName='key_resp_18')
    UP = visual.TextStim(win=win, name='UP',
        text='DOWN\n',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_4 = visual.Rect(
        win=win, name='up_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_4 = visual.Rect(
        win=win, name='down_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_up" ---
    blacksquare_25 = visual.Rect(
        win=win, name='blacksquare_25',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_25 = visual.ShapeStim(
        win=win, name='white_cross_25', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_28 = keyboard.Keyboard(deviceName='key_resp_28')
    arrow_u_4 = visual.ShapeStim(
        win=win, name='arrow_u_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_5 = visual.Rect(
        win=win, name='up_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_5 = visual.Rect(
        win=win, name='down_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_down" ---
    blacksquare_16 = visual.Rect(
        win=win, name='blacksquare_16',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_16 = visual.ShapeStim(
        win=win, name='white_cross_16', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_19 = keyboard.Keyboard(deviceName='key_resp_19')
    UP_6 = visual.TextStim(win=win, name='UP_6',
        text='UP',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_6 = visual.Rect(
        win=win, name='up_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_6 = visual.Rect(
        win=win, name='down_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_down" ---
    blacksquare_23 = visual.Rect(
        win=win, name='blacksquare_23',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_23 = visual.ShapeStim(
        win=win, name='white_cross_23', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_26 = keyboard.Keyboard(deviceName='key_resp_26')
    arrow_u_2 = visual.ShapeStim(
        win=win, name='arrow_u_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_7 = visual.Rect(
        win=win, name='up_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_7 = visual.Rect(
        win=win, name='down_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_down" ---
    blacksquare_17 = visual.Rect(
        win=win, name='blacksquare_17',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_17 = visual.ShapeStim(
        win=win, name='white_cross_17', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_20 = keyboard.Keyboard(deviceName='key_resp_20')
    UP_7 = visual.TextStim(win=win, name='UP_7',
        text='DOWN',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_8 = visual.Rect(
        win=win, name='up_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_8 = visual.Rect(
        win=win, name='down_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_down" ---
    blacksquare_24 = visual.Rect(
        win=win, name='blacksquare_24',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_24 = visual.ShapeStim(
        win=win, name='white_cross_24', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_27 = keyboard.Keyboard(deviceName='key_resp_27')
    arrow_u_3 = visual.ShapeStim(
        win=win, name='arrow_u_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_9 = visual.Rect(
        win=win, name='up_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_9 = visual.Rect(
        win=win, name='down_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "end_block1" ---
    text_22 = visual.TextStim(win=win, name='text_22',
        text='This is the end of Block 1. Take a short break if needed.',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_23 = visual.TextStim(win=win, name='text_23',
        text='Whenever ready,\npress Space Bar to start Block 2',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_29 = keyboard.Keyboard(deviceName='key_resp_29')
    
    # --- Initialize components for Routine "block2" ---
    text_24 = visual.TextStim(win=win, name='text_24',
        text='Block 2',
        font='Arial',
        pos=(0, 0.1), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "block2_router" ---
    # Run 'Begin Experiment' code from code_22
    
    
    
    # --- Initialize components for Routine "LEFT_on_right" ---
    blacksquare_10 = visual.Rect(
        win=win, name='blacksquare_10',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_10 = visual.ShapeStim(
        win=win, name='white_cross_10', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_13 = keyboard.Keyboard(deviceName='key_resp_13')
    LEFT_2 = visual.TextStim(win=win, name='LEFT_2',
        text='LEFT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_3 = visual.Rect(
        win=win, name='whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_4 = visual.Rect(
        win=win, name='whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_right" ---
    blacksquare_11 = visual.Rect(
        win=win, name='blacksquare_11',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_11 = visual.ShapeStim(
        win=win, name='white_cross_11', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_14 = keyboard.Keyboard(deviceName='key_resp_14')
    RIGHT_3 = visual.TextStim(win=win, name='RIGHT_3',
        text='RIGHT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_10 = visual.Rect(
        win=win, name='whitesquare_10',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_17 = visual.Rect(
        win=win, name='whitesquare_17',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "LEFT_on_left" ---
    blacksquare_12 = visual.Rect(
        win=win, name='blacksquare_12',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_12 = visual.ShapeStim(
        win=win, name='white_cross_12', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_15 = keyboard.Keyboard(deviceName='key_resp_15')
    LEFT_4 = visual.TextStim(win=win, name='LEFT_4',
        text='LEFT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_6 = visual.Rect(
        win=win, name='whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_13 = visual.Rect(
        win=win, name='whitesquare_13',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_left" ---
    blacksquare_13 = visual.Rect(
        win=win, name='blacksquare_13',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_13 = visual.ShapeStim(
        win=win, name='white_cross_13', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_16 = keyboard.Keyboard(deviceName='key_resp_16')
    RIGHT_5 = visual.TextStim(win=win, name='RIGHT_5',
        text='RIGHT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_8 = visual.Rect(
        win=win, name='whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_15 = visual.Rect(
        win=win, name='whitesquare_15',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_up" ---
    blacksquare_14 = visual.Rect(
        win=win, name='blacksquare_14',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_14 = visual.ShapeStim(
        win=win, name='white_cross_14', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_17 = keyboard.Keyboard(deviceName='key_resp_17')
    UP_5 = visual.TextStim(win=win, name='UP_5',
        text='UP',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_2 = visual.Rect(
        win=win, name='up_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_2 = visual.Rect(
        win=win, name='down_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_up" ---
    blacksquare_15 = visual.Rect(
        win=win, name='blacksquare_15',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_15 = visual.ShapeStim(
        win=win, name='white_cross_15', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_18 = keyboard.Keyboard(deviceName='key_resp_18')
    UP = visual.TextStim(win=win, name='UP',
        text='DOWN\n',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_4 = visual.Rect(
        win=win, name='up_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_4 = visual.Rect(
        win=win, name='down_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_down" ---
    blacksquare_16 = visual.Rect(
        win=win, name='blacksquare_16',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_16 = visual.ShapeStim(
        win=win, name='white_cross_16', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_19 = keyboard.Keyboard(deviceName='key_resp_19')
    UP_6 = visual.TextStim(win=win, name='UP_6',
        text='UP',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_6 = visual.Rect(
        win=win, name='up_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_6 = visual.Rect(
        win=win, name='down_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_down" ---
    blacksquare_17 = visual.Rect(
        win=win, name='blacksquare_17',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_17 = visual.ShapeStim(
        win=win, name='white_cross_17', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_20 = keyboard.Keyboard(deviceName='key_resp_20')
    UP_7 = visual.TextStim(win=win, name='UP_7',
        text='DOWN',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_8 = visual.Rect(
        win=win, name='up_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_8 = visual.Rect(
        win=win, name='down_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_right" ---
    blacksquare_18 = visual.Rect(
        win=win, name='blacksquare_18',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_18 = visual.ShapeStim(
        win=win, name='white_cross_18', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_21 = keyboard.Keyboard(deviceName='key_resp_21')
    arrow_l_2 = visual.ShapeStim(
        win=win, name='arrow_l_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_5 = visual.Rect(
        win=win, name='whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_12 = visual.Rect(
        win=win, name='whitesquare_12',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_left" ---
    blacksquare_19 = visual.Rect(
        win=win, name='blacksquare_19',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_19 = visual.ShapeStim(
        win=win, name='white_cross_19', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_22 = keyboard.Keyboard(deviceName='key_resp_22')
    arrow_l_3 = visual.ShapeStim(
        win=win, name='arrow_l_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_7 = visual.Rect(
        win=win, name='whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_14 = visual.Rect(
        win=win, name='whitesquare_14',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_right" ---
    blacksquare_20 = visual.Rect(
        win=win, name='blacksquare_20',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_20 = visual.ShapeStim(
        win=win, name='white_cross_20', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_23 = keyboard.Keyboard(deviceName='key_resp_23')
    arrow_l_4 = visual.ShapeStim(
        win=win, name='arrow_l_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_11 = visual.Rect(
        win=win, name='whitesquare_11',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_18 = visual.Rect(
        win=win, name='whitesquare_18',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_left" ---
    blacksquare_21 = visual.Rect(
        win=win, name='blacksquare_21',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_21 = visual.ShapeStim(
        win=win, name='white_cross_21', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_24 = keyboard.Keyboard(deviceName='key_resp_24')
    arrow_l_5 = visual.ShapeStim(
        win=win, name='arrow_l_5', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_9 = visual.Rect(
        win=win, name='whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_16 = visual.Rect(
        win=win, name='whitesquare_16',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_up" ---
    blacksquare_22 = visual.Rect(
        win=win, name='blacksquare_22',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_22 = visual.ShapeStim(
        win=win, name='white_cross_22', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_25 = keyboard.Keyboard(deviceName='key_resp_25')
    arrow_u = visual.ShapeStim(
        win=win, name='arrow_u', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_3 = visual.Rect(
        win=win, name='up_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_3 = visual.Rect(
        win=win, name='down_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_down" ---
    blacksquare_23 = visual.Rect(
        win=win, name='blacksquare_23',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_23 = visual.ShapeStim(
        win=win, name='white_cross_23', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_26 = keyboard.Keyboard(deviceName='key_resp_26')
    arrow_u_2 = visual.ShapeStim(
        win=win, name='arrow_u_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_7 = visual.Rect(
        win=win, name='up_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_7 = visual.Rect(
        win=win, name='down_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_down" ---
    blacksquare_24 = visual.Rect(
        win=win, name='blacksquare_24',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_24 = visual.ShapeStim(
        win=win, name='white_cross_24', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_27 = keyboard.Keyboard(deviceName='key_resp_27')
    arrow_u_3 = visual.ShapeStim(
        win=win, name='arrow_u_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_9 = visual.Rect(
        win=win, name='up_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_9 = visual.Rect(
        win=win, name='down_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_up" ---
    blacksquare_25 = visual.Rect(
        win=win, name='blacksquare_25',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_25 = visual.ShapeStim(
        win=win, name='white_cross_25', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_28 = keyboard.Keyboard(deviceName='key_resp_28')
    arrow_u_4 = visual.ShapeStim(
        win=win, name='arrow_u_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_5 = visual.Rect(
        win=win, name='up_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_5 = visual.Rect(
        win=win, name='down_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "end_block2" ---
    text_29 = visual.TextStim(win=win, name='text_29',
        text='This is the end of Block 2. Take a short break if needed.',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_30 = visual.TextStim(win=win, name='text_30',
        text='Whenever ready,\npress Space Bar to start Block 3',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_30 = keyboard.Keyboard(deviceName='key_resp_30')
    
    # --- Initialize components for Routine "block3" ---
    text_25 = visual.TextStim(win=win, name='text_25',
        text='Block 3',
        font='Arial',
        pos=(0, 0.1), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "block3_router" ---
    # Run 'Begin Experiment' code from code_23
    import random
    
    all_routines = [
        "LEFT_on_right", "RIGHT_on_right", "LEFT_on_left", "RIGHT_on_left",
        "UP_on_up", "DOWN_on_up", "UP_on_down", "DOWN_on_down",
        "leftA_on_right", "leftA_on_left", "rightA_on_right", "rightA_on_left",
        "upA_on_up", "upA_on_down", "downA_on_down", "downA_on_up"
    ]
    
    schedule = random.choices(all_routines, k=32)
    trial_index = 0
    
    
    # --- Initialize components for Routine "LEFT_on_right" ---
    blacksquare_10 = visual.Rect(
        win=win, name='blacksquare_10',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_10 = visual.ShapeStim(
        win=win, name='white_cross_10', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_13 = keyboard.Keyboard(deviceName='key_resp_13')
    LEFT_2 = visual.TextStim(win=win, name='LEFT_2',
        text='LEFT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_3 = visual.Rect(
        win=win, name='whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_4 = visual.Rect(
        win=win, name='whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_right" ---
    blacksquare_11 = visual.Rect(
        win=win, name='blacksquare_11',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_11 = visual.ShapeStim(
        win=win, name='white_cross_11', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_14 = keyboard.Keyboard(deviceName='key_resp_14')
    RIGHT_3 = visual.TextStim(win=win, name='RIGHT_3',
        text='RIGHT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_10 = visual.Rect(
        win=win, name='whitesquare_10',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_17 = visual.Rect(
        win=win, name='whitesquare_17',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "LEFT_on_left" ---
    blacksquare_12 = visual.Rect(
        win=win, name='blacksquare_12',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_12 = visual.ShapeStim(
        win=win, name='white_cross_12', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_15 = keyboard.Keyboard(deviceName='key_resp_15')
    LEFT_4 = visual.TextStim(win=win, name='LEFT_4',
        text='LEFT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_6 = visual.Rect(
        win=win, name='whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_13 = visual.Rect(
        win=win, name='whitesquare_13',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_left" ---
    blacksquare_13 = visual.Rect(
        win=win, name='blacksquare_13',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_13 = visual.ShapeStim(
        win=win, name='white_cross_13', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_16 = keyboard.Keyboard(deviceName='key_resp_16')
    RIGHT_5 = visual.TextStim(win=win, name='RIGHT_5',
        text='RIGHT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_8 = visual.Rect(
        win=win, name='whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_15 = visual.Rect(
        win=win, name='whitesquare_15',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_up" ---
    blacksquare_14 = visual.Rect(
        win=win, name='blacksquare_14',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_14 = visual.ShapeStim(
        win=win, name='white_cross_14', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_17 = keyboard.Keyboard(deviceName='key_resp_17')
    UP_5 = visual.TextStim(win=win, name='UP_5',
        text='UP',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_2 = visual.Rect(
        win=win, name='up_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_2 = visual.Rect(
        win=win, name='down_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_up" ---
    blacksquare_15 = visual.Rect(
        win=win, name='blacksquare_15',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_15 = visual.ShapeStim(
        win=win, name='white_cross_15', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_18 = keyboard.Keyboard(deviceName='key_resp_18')
    UP = visual.TextStim(win=win, name='UP',
        text='DOWN\n',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_4 = visual.Rect(
        win=win, name='up_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_4 = visual.Rect(
        win=win, name='down_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_down" ---
    blacksquare_16 = visual.Rect(
        win=win, name='blacksquare_16',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_16 = visual.ShapeStim(
        win=win, name='white_cross_16', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_19 = keyboard.Keyboard(deviceName='key_resp_19')
    UP_6 = visual.TextStim(win=win, name='UP_6',
        text='UP',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_6 = visual.Rect(
        win=win, name='up_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_6 = visual.Rect(
        win=win, name='down_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_down" ---
    blacksquare_17 = visual.Rect(
        win=win, name='blacksquare_17',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_17 = visual.ShapeStim(
        win=win, name='white_cross_17', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_20 = keyboard.Keyboard(deviceName='key_resp_20')
    UP_7 = visual.TextStim(win=win, name='UP_7',
        text='DOWN',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_8 = visual.Rect(
        win=win, name='up_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_8 = visual.Rect(
        win=win, name='down_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_right" ---
    blacksquare_18 = visual.Rect(
        win=win, name='blacksquare_18',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_18 = visual.ShapeStim(
        win=win, name='white_cross_18', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_21 = keyboard.Keyboard(deviceName='key_resp_21')
    arrow_l_2 = visual.ShapeStim(
        win=win, name='arrow_l_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_5 = visual.Rect(
        win=win, name='whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_12 = visual.Rect(
        win=win, name='whitesquare_12',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_left" ---
    blacksquare_19 = visual.Rect(
        win=win, name='blacksquare_19',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_19 = visual.ShapeStim(
        win=win, name='white_cross_19', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_22 = keyboard.Keyboard(deviceName='key_resp_22')
    arrow_l_3 = visual.ShapeStim(
        win=win, name='arrow_l_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_7 = visual.Rect(
        win=win, name='whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_14 = visual.Rect(
        win=win, name='whitesquare_14',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_right" ---
    blacksquare_20 = visual.Rect(
        win=win, name='blacksquare_20',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_20 = visual.ShapeStim(
        win=win, name='white_cross_20', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_23 = keyboard.Keyboard(deviceName='key_resp_23')
    arrow_l_4 = visual.ShapeStim(
        win=win, name='arrow_l_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_11 = visual.Rect(
        win=win, name='whitesquare_11',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_18 = visual.Rect(
        win=win, name='whitesquare_18',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_left" ---
    blacksquare_21 = visual.Rect(
        win=win, name='blacksquare_21',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_21 = visual.ShapeStim(
        win=win, name='white_cross_21', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_24 = keyboard.Keyboard(deviceName='key_resp_24')
    arrow_l_5 = visual.ShapeStim(
        win=win, name='arrow_l_5', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_9 = visual.Rect(
        win=win, name='whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_16 = visual.Rect(
        win=win, name='whitesquare_16',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_up" ---
    blacksquare_22 = visual.Rect(
        win=win, name='blacksquare_22',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_22 = visual.ShapeStim(
        win=win, name='white_cross_22', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_25 = keyboard.Keyboard(deviceName='key_resp_25')
    arrow_u = visual.ShapeStim(
        win=win, name='arrow_u', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_3 = visual.Rect(
        win=win, name='up_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_3 = visual.Rect(
        win=win, name='down_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_down" ---
    blacksquare_23 = visual.Rect(
        win=win, name='blacksquare_23',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_23 = visual.ShapeStim(
        win=win, name='white_cross_23', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_26 = keyboard.Keyboard(deviceName='key_resp_26')
    arrow_u_2 = visual.ShapeStim(
        win=win, name='arrow_u_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_7 = visual.Rect(
        win=win, name='up_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_7 = visual.Rect(
        win=win, name='down_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_down" ---
    blacksquare_24 = visual.Rect(
        win=win, name='blacksquare_24',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_24 = visual.ShapeStim(
        win=win, name='white_cross_24', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_27 = keyboard.Keyboard(deviceName='key_resp_27')
    arrow_u_3 = visual.ShapeStim(
        win=win, name='arrow_u_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_9 = visual.Rect(
        win=win, name='up_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_9 = visual.Rect(
        win=win, name='down_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_up" ---
    blacksquare_25 = visual.Rect(
        win=win, name='blacksquare_25',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_25 = visual.ShapeStim(
        win=win, name='white_cross_25', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_28 = keyboard.Keyboard(deviceName='key_resp_28')
    arrow_u_4 = visual.ShapeStim(
        win=win, name='arrow_u_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_5 = visual.Rect(
        win=win, name='up_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_5 = visual.Rect(
        win=win, name='down_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "end_block3" ---
    text_31 = visual.TextStim(win=win, name='text_31',
        text='This is the end of Block 3. Take a short break if needed.',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_32 = visual.TextStim(win=win, name='text_32',
        text='Whenever ready,\npress Space Bar to start Block 4',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_31 = keyboard.Keyboard(deviceName='key_resp_31')
    
    # --- Initialize components for Routine "block4" ---
    text_26 = visual.TextStim(win=win, name='text_26',
        text='Block 4',
        font='Arial',
        pos=(0, 0.1), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "block4_router" ---
    # Run 'Begin Experiment' code from code_24
    import random
    
    all_routines = [
        "LEFT_on_right", "RIGHT_on_right", "LEFT_on_left", "RIGHT_on_left",
        "UP_on_up", "DOWN_on_up", "UP_on_down", "DOWN_on_down",
        "leftA_on_right", "leftA_on_left", "rightA_on_right", "rightA_on_left",
        "upA_on_up", "upA_on_down", "downA_on_down", "downA_on_up"
    ]
    
    schedule = random.choices(all_routines, k=32)
    trial_index = 0
    
    
    # --- Initialize components for Routine "LEFT_on_right" ---
    blacksquare_10 = visual.Rect(
        win=win, name='blacksquare_10',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_10 = visual.ShapeStim(
        win=win, name='white_cross_10', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_13 = keyboard.Keyboard(deviceName='key_resp_13')
    LEFT_2 = visual.TextStim(win=win, name='LEFT_2',
        text='LEFT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_3 = visual.Rect(
        win=win, name='whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_4 = visual.Rect(
        win=win, name='whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_right" ---
    blacksquare_11 = visual.Rect(
        win=win, name='blacksquare_11',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_11 = visual.ShapeStim(
        win=win, name='white_cross_11', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_14 = keyboard.Keyboard(deviceName='key_resp_14')
    RIGHT_3 = visual.TextStim(win=win, name='RIGHT_3',
        text='RIGHT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_10 = visual.Rect(
        win=win, name='whitesquare_10',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_17 = visual.Rect(
        win=win, name='whitesquare_17',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "LEFT_on_left" ---
    blacksquare_12 = visual.Rect(
        win=win, name='blacksquare_12',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_12 = visual.ShapeStim(
        win=win, name='white_cross_12', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_15 = keyboard.Keyboard(deviceName='key_resp_15')
    LEFT_4 = visual.TextStim(win=win, name='LEFT_4',
        text='LEFT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_6 = visual.Rect(
        win=win, name='whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_13 = visual.Rect(
        win=win, name='whitesquare_13',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_left" ---
    blacksquare_13 = visual.Rect(
        win=win, name='blacksquare_13',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_13 = visual.ShapeStim(
        win=win, name='white_cross_13', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_16 = keyboard.Keyboard(deviceName='key_resp_16')
    RIGHT_5 = visual.TextStim(win=win, name='RIGHT_5',
        text='RIGHT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_8 = visual.Rect(
        win=win, name='whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_15 = visual.Rect(
        win=win, name='whitesquare_15',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_up" ---
    blacksquare_14 = visual.Rect(
        win=win, name='blacksquare_14',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_14 = visual.ShapeStim(
        win=win, name='white_cross_14', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_17 = keyboard.Keyboard(deviceName='key_resp_17')
    UP_5 = visual.TextStim(win=win, name='UP_5',
        text='UP',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_2 = visual.Rect(
        win=win, name='up_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_2 = visual.Rect(
        win=win, name='down_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_up" ---
    blacksquare_15 = visual.Rect(
        win=win, name='blacksquare_15',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_15 = visual.ShapeStim(
        win=win, name='white_cross_15', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_18 = keyboard.Keyboard(deviceName='key_resp_18')
    UP = visual.TextStim(win=win, name='UP',
        text='DOWN\n',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_4 = visual.Rect(
        win=win, name='up_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_4 = visual.Rect(
        win=win, name='down_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_down" ---
    blacksquare_16 = visual.Rect(
        win=win, name='blacksquare_16',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_16 = visual.ShapeStim(
        win=win, name='white_cross_16', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_19 = keyboard.Keyboard(deviceName='key_resp_19')
    UP_6 = visual.TextStim(win=win, name='UP_6',
        text='UP',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_6 = visual.Rect(
        win=win, name='up_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_6 = visual.Rect(
        win=win, name='down_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_down" ---
    blacksquare_17 = visual.Rect(
        win=win, name='blacksquare_17',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_17 = visual.ShapeStim(
        win=win, name='white_cross_17', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_20 = keyboard.Keyboard(deviceName='key_resp_20')
    UP_7 = visual.TextStim(win=win, name='UP_7',
        text='DOWN',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_8 = visual.Rect(
        win=win, name='up_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_8 = visual.Rect(
        win=win, name='down_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_right" ---
    blacksquare_18 = visual.Rect(
        win=win, name='blacksquare_18',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_18 = visual.ShapeStim(
        win=win, name='white_cross_18', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_21 = keyboard.Keyboard(deviceName='key_resp_21')
    arrow_l_2 = visual.ShapeStim(
        win=win, name='arrow_l_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_5 = visual.Rect(
        win=win, name='whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_12 = visual.Rect(
        win=win, name='whitesquare_12',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_left" ---
    blacksquare_19 = visual.Rect(
        win=win, name='blacksquare_19',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_19 = visual.ShapeStim(
        win=win, name='white_cross_19', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_22 = keyboard.Keyboard(deviceName='key_resp_22')
    arrow_l_3 = visual.ShapeStim(
        win=win, name='arrow_l_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_7 = visual.Rect(
        win=win, name='whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_14 = visual.Rect(
        win=win, name='whitesquare_14',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_right" ---
    blacksquare_20 = visual.Rect(
        win=win, name='blacksquare_20',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_20 = visual.ShapeStim(
        win=win, name='white_cross_20', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_23 = keyboard.Keyboard(deviceName='key_resp_23')
    arrow_l_4 = visual.ShapeStim(
        win=win, name='arrow_l_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_11 = visual.Rect(
        win=win, name='whitesquare_11',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_18 = visual.Rect(
        win=win, name='whitesquare_18',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_left" ---
    blacksquare_21 = visual.Rect(
        win=win, name='blacksquare_21',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_21 = visual.ShapeStim(
        win=win, name='white_cross_21', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_24 = keyboard.Keyboard(deviceName='key_resp_24')
    arrow_l_5 = visual.ShapeStim(
        win=win, name='arrow_l_5', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_9 = visual.Rect(
        win=win, name='whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_16 = visual.Rect(
        win=win, name='whitesquare_16',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_up" ---
    blacksquare_22 = visual.Rect(
        win=win, name='blacksquare_22',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_22 = visual.ShapeStim(
        win=win, name='white_cross_22', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_25 = keyboard.Keyboard(deviceName='key_resp_25')
    arrow_u = visual.ShapeStim(
        win=win, name='arrow_u', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_3 = visual.Rect(
        win=win, name='up_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_3 = visual.Rect(
        win=win, name='down_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_down" ---
    blacksquare_23 = visual.Rect(
        win=win, name='blacksquare_23',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_23 = visual.ShapeStim(
        win=win, name='white_cross_23', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_26 = keyboard.Keyboard(deviceName='key_resp_26')
    arrow_u_2 = visual.ShapeStim(
        win=win, name='arrow_u_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_7 = visual.Rect(
        win=win, name='up_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_7 = visual.Rect(
        win=win, name='down_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_down" ---
    blacksquare_24 = visual.Rect(
        win=win, name='blacksquare_24',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_24 = visual.ShapeStim(
        win=win, name='white_cross_24', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_27 = keyboard.Keyboard(deviceName='key_resp_27')
    arrow_u_3 = visual.ShapeStim(
        win=win, name='arrow_u_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_9 = visual.Rect(
        win=win, name='up_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_9 = visual.Rect(
        win=win, name='down_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_up" ---
    blacksquare_25 = visual.Rect(
        win=win, name='blacksquare_25',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_25 = visual.ShapeStim(
        win=win, name='white_cross_25', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_28 = keyboard.Keyboard(deviceName='key_resp_28')
    arrow_u_4 = visual.ShapeStim(
        win=win, name='arrow_u_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_5 = visual.Rect(
        win=win, name='up_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_5 = visual.Rect(
        win=win, name='down_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "end_block4" ---
    text_33 = visual.TextStim(win=win, name='text_33',
        text='This is the end of Block 4. Take a short break if needed.',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_34 = visual.TextStim(win=win, name='text_34',
        text='Whenever ready,\npress Space Bar to start Block 5',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_32 = keyboard.Keyboard(deviceName='key_resp_32')
    
    # --- Initialize components for Routine "block5" ---
    text_27 = visual.TextStim(win=win, name='text_27',
        text='Block 5',
        font='Arial',
        pos=(0, 0.1), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "block5_router" ---
    # Run 'Begin Experiment' code from code_25
    import random
    
    all_routines = [
        "LEFT_on_right", "RIGHT_on_right", "LEFT_on_left", "RIGHT_on_left",
        "UP_on_up", "DOWN_on_up", "UP_on_down", "DOWN_on_down",
        "leftA_on_right", "leftA_on_left", "rightA_on_right", "rightA_on_left",
        "upA_on_up", "upA_on_down", "downA_on_down", "downA_on_up"
    ]
    
    schedule = random.choices(all_routines, k=32)
    trial_index = 0
    
    
    # --- Initialize components for Routine "LEFT_on_right" ---
    blacksquare_10 = visual.Rect(
        win=win, name='blacksquare_10',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_10 = visual.ShapeStim(
        win=win, name='white_cross_10', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_13 = keyboard.Keyboard(deviceName='key_resp_13')
    LEFT_2 = visual.TextStim(win=win, name='LEFT_2',
        text='LEFT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_3 = visual.Rect(
        win=win, name='whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_4 = visual.Rect(
        win=win, name='whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_right" ---
    blacksquare_11 = visual.Rect(
        win=win, name='blacksquare_11',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_11 = visual.ShapeStim(
        win=win, name='white_cross_11', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_14 = keyboard.Keyboard(deviceName='key_resp_14')
    RIGHT_3 = visual.TextStim(win=win, name='RIGHT_3',
        text='RIGHT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_10 = visual.Rect(
        win=win, name='whitesquare_10',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_17 = visual.Rect(
        win=win, name='whitesquare_17',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "LEFT_on_left" ---
    blacksquare_12 = visual.Rect(
        win=win, name='blacksquare_12',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_12 = visual.ShapeStim(
        win=win, name='white_cross_12', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_15 = keyboard.Keyboard(deviceName='key_resp_15')
    LEFT_4 = visual.TextStim(win=win, name='LEFT_4',
        text='LEFT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_6 = visual.Rect(
        win=win, name='whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_13 = visual.Rect(
        win=win, name='whitesquare_13',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_left" ---
    blacksquare_13 = visual.Rect(
        win=win, name='blacksquare_13',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_13 = visual.ShapeStim(
        win=win, name='white_cross_13', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_16 = keyboard.Keyboard(deviceName='key_resp_16')
    RIGHT_5 = visual.TextStim(win=win, name='RIGHT_5',
        text='RIGHT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_8 = visual.Rect(
        win=win, name='whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_15 = visual.Rect(
        win=win, name='whitesquare_15',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_up" ---
    blacksquare_14 = visual.Rect(
        win=win, name='blacksquare_14',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_14 = visual.ShapeStim(
        win=win, name='white_cross_14', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_17 = keyboard.Keyboard(deviceName='key_resp_17')
    UP_5 = visual.TextStim(win=win, name='UP_5',
        text='UP',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_2 = visual.Rect(
        win=win, name='up_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_2 = visual.Rect(
        win=win, name='down_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_up" ---
    blacksquare_15 = visual.Rect(
        win=win, name='blacksquare_15',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_15 = visual.ShapeStim(
        win=win, name='white_cross_15', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_18 = keyboard.Keyboard(deviceName='key_resp_18')
    UP = visual.TextStim(win=win, name='UP',
        text='DOWN\n',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_4 = visual.Rect(
        win=win, name='up_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_4 = visual.Rect(
        win=win, name='down_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_down" ---
    blacksquare_16 = visual.Rect(
        win=win, name='blacksquare_16',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_16 = visual.ShapeStim(
        win=win, name='white_cross_16', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_19 = keyboard.Keyboard(deviceName='key_resp_19')
    UP_6 = visual.TextStim(win=win, name='UP_6',
        text='UP',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_6 = visual.Rect(
        win=win, name='up_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_6 = visual.Rect(
        win=win, name='down_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_down" ---
    blacksquare_17 = visual.Rect(
        win=win, name='blacksquare_17',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_17 = visual.ShapeStim(
        win=win, name='white_cross_17', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_20 = keyboard.Keyboard(deviceName='key_resp_20')
    UP_7 = visual.TextStim(win=win, name='UP_7',
        text='DOWN',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_8 = visual.Rect(
        win=win, name='up_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_8 = visual.Rect(
        win=win, name='down_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_right" ---
    blacksquare_18 = visual.Rect(
        win=win, name='blacksquare_18',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_18 = visual.ShapeStim(
        win=win, name='white_cross_18', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_21 = keyboard.Keyboard(deviceName='key_resp_21')
    arrow_l_2 = visual.ShapeStim(
        win=win, name='arrow_l_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_5 = visual.Rect(
        win=win, name='whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_12 = visual.Rect(
        win=win, name='whitesquare_12',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_left" ---
    blacksquare_19 = visual.Rect(
        win=win, name='blacksquare_19',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_19 = visual.ShapeStim(
        win=win, name='white_cross_19', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_22 = keyboard.Keyboard(deviceName='key_resp_22')
    arrow_l_3 = visual.ShapeStim(
        win=win, name='arrow_l_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_7 = visual.Rect(
        win=win, name='whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_14 = visual.Rect(
        win=win, name='whitesquare_14',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_right" ---
    blacksquare_20 = visual.Rect(
        win=win, name='blacksquare_20',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_20 = visual.ShapeStim(
        win=win, name='white_cross_20', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_23 = keyboard.Keyboard(deviceName='key_resp_23')
    arrow_l_4 = visual.ShapeStim(
        win=win, name='arrow_l_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_11 = visual.Rect(
        win=win, name='whitesquare_11',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_18 = visual.Rect(
        win=win, name='whitesquare_18',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_left" ---
    blacksquare_21 = visual.Rect(
        win=win, name='blacksquare_21',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_21 = visual.ShapeStim(
        win=win, name='white_cross_21', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_24 = keyboard.Keyboard(deviceName='key_resp_24')
    arrow_l_5 = visual.ShapeStim(
        win=win, name='arrow_l_5', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_9 = visual.Rect(
        win=win, name='whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_16 = visual.Rect(
        win=win, name='whitesquare_16',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_up" ---
    blacksquare_22 = visual.Rect(
        win=win, name='blacksquare_22',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_22 = visual.ShapeStim(
        win=win, name='white_cross_22', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_25 = keyboard.Keyboard(deviceName='key_resp_25')
    arrow_u = visual.ShapeStim(
        win=win, name='arrow_u', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_3 = visual.Rect(
        win=win, name='up_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_3 = visual.Rect(
        win=win, name='down_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_down" ---
    blacksquare_23 = visual.Rect(
        win=win, name='blacksquare_23',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_23 = visual.ShapeStim(
        win=win, name='white_cross_23', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_26 = keyboard.Keyboard(deviceName='key_resp_26')
    arrow_u_2 = visual.ShapeStim(
        win=win, name='arrow_u_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_7 = visual.Rect(
        win=win, name='up_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_7 = visual.Rect(
        win=win, name='down_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_down" ---
    blacksquare_24 = visual.Rect(
        win=win, name='blacksquare_24',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_24 = visual.ShapeStim(
        win=win, name='white_cross_24', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_27 = keyboard.Keyboard(deviceName='key_resp_27')
    arrow_u_3 = visual.ShapeStim(
        win=win, name='arrow_u_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_9 = visual.Rect(
        win=win, name='up_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_9 = visual.Rect(
        win=win, name='down_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_up" ---
    blacksquare_25 = visual.Rect(
        win=win, name='blacksquare_25',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_25 = visual.ShapeStim(
        win=win, name='white_cross_25', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_28 = keyboard.Keyboard(deviceName='key_resp_28')
    arrow_u_4 = visual.ShapeStim(
        win=win, name='arrow_u_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_5 = visual.Rect(
        win=win, name='up_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_5 = visual.Rect(
        win=win, name='down_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "end_block5" ---
    text_35 = visual.TextStim(win=win, name='text_35',
        text='This is the end of Block 5. Take a short break if needed.',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_36 = visual.TextStim(win=win, name='text_36',
        text='Whenever ready,\npress Space Bar to start Block 6',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_33 = keyboard.Keyboard(deviceName='key_resp_33')
    
    # --- Initialize components for Routine "block6" ---
    text_28 = visual.TextStim(win=win, name='text_28',
        text='Block 6',
        font='Arial',
        pos=(0, 0.1), draggable=False, height=0.05, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    
    # --- Initialize components for Routine "block6_router" ---
    # Run 'Begin Experiment' code from code_26
    import random
    
    all_routines = [
        "LEFT_on_right", "RIGHT_on_right", "LEFT_on_left", "RIGHT_on_left",
        "UP_on_up", "DOWN_on_up", "UP_on_down", "DOWN_on_down",
        "leftA_on_right", "leftA_on_left", "rightA_on_right", "rightA_on_left",
        "upA_on_up", "upA_on_down", "downA_on_down", "downA_on_up"
    ]
    
    schedule = random.choices(all_routines, k=32)
    trial_index = 0
    
    
    # --- Initialize components for Routine "LEFT_on_right" ---
    blacksquare_10 = visual.Rect(
        win=win, name='blacksquare_10',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_10 = visual.ShapeStim(
        win=win, name='white_cross_10', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_13 = keyboard.Keyboard(deviceName='key_resp_13')
    LEFT_2 = visual.TextStim(win=win, name='LEFT_2',
        text='LEFT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_3 = visual.Rect(
        win=win, name='whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_4 = visual.Rect(
        win=win, name='whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_right" ---
    blacksquare_11 = visual.Rect(
        win=win, name='blacksquare_11',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_11 = visual.ShapeStim(
        win=win, name='white_cross_11', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_14 = keyboard.Keyboard(deviceName='key_resp_14')
    RIGHT_3 = visual.TextStim(win=win, name='RIGHT_3',
        text='RIGHT',
        font='Arial',
        pos=(0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_10 = visual.Rect(
        win=win, name='whitesquare_10',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_17 = visual.Rect(
        win=win, name='whitesquare_17',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "LEFT_on_left" ---
    blacksquare_12 = visual.Rect(
        win=win, name='blacksquare_12',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_12 = visual.ShapeStim(
        win=win, name='white_cross_12', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_15 = keyboard.Keyboard(deviceName='key_resp_15')
    LEFT_4 = visual.TextStim(win=win, name='LEFT_4',
        text='LEFT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_6 = visual.Rect(
        win=win, name='whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_13 = visual.Rect(
        win=win, name='whitesquare_13',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "RIGHT_on_left" ---
    blacksquare_13 = visual.Rect(
        win=win, name='blacksquare_13',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_13 = visual.ShapeStim(
        win=win, name='white_cross_13', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_16 = keyboard.Keyboard(deviceName='key_resp_16')
    RIGHT_5 = visual.TextStim(win=win, name='RIGHT_5',
        text='RIGHT',
        font='Arial',
        pos=(-0.15, 0), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    whitesquare_8 = visual.Rect(
        win=win, name='whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_15 = visual.Rect(
        win=win, name='whitesquare_15',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_up" ---
    blacksquare_14 = visual.Rect(
        win=win, name='blacksquare_14',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_14 = visual.ShapeStim(
        win=win, name='white_cross_14', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_17 = keyboard.Keyboard(deviceName='key_resp_17')
    UP_5 = visual.TextStim(win=win, name='UP_5',
        text='UP',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_2 = visual.Rect(
        win=win, name='up_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_2 = visual.Rect(
        win=win, name='down_whitesquare_2',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_up" ---
    blacksquare_15 = visual.Rect(
        win=win, name='blacksquare_15',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_15 = visual.ShapeStim(
        win=win, name='white_cross_15', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_18 = keyboard.Keyboard(deviceName='key_resp_18')
    UP = visual.TextStim(win=win, name='UP',
        text='DOWN\n',
        font='Arial',
        pos=(0, 0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_4 = visual.Rect(
        win=win, name='up_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_4 = visual.Rect(
        win=win, name='down_whitesquare_4',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "UP_on_down" ---
    blacksquare_16 = visual.Rect(
        win=win, name='blacksquare_16',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_16 = visual.ShapeStim(
        win=win, name='white_cross_16', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_19 = keyboard.Keyboard(deviceName='key_resp_19')
    UP_6 = visual.TextStim(win=win, name='UP_6',
        text='UP',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_6 = visual.Rect(
        win=win, name='up_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_6 = visual.Rect(
        win=win, name='down_whitesquare_6',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "DOWN_on_down" ---
    blacksquare_17 = visual.Rect(
        win=win, name='blacksquare_17',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_17 = visual.ShapeStim(
        win=win, name='white_cross_17', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_20 = keyboard.Keyboard(deviceName='key_resp_20')
    UP_7 = visual.TextStim(win=win, name='UP_7',
        text='DOWN',
        font='Arial',
        pos=(0, -0.15), draggable=False, height=0.039, wrapWidth=None, ori=0.0, 
        color='white', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-3.0);
    up_whitesquare_8 = visual.Rect(
        win=win, name='up_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_8 = visual.Rect(
        win=win, name='down_whitesquare_8',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_right" ---
    blacksquare_18 = visual.Rect(
        win=win, name='blacksquare_18',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_18 = visual.ShapeStim(
        win=win, name='white_cross_18', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_21 = keyboard.Keyboard(deviceName='key_resp_21')
    arrow_l_2 = visual.ShapeStim(
        win=win, name='arrow_l_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_5 = visual.Rect(
        win=win, name='whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_12 = visual.Rect(
        win=win, name='whitesquare_12',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "leftA_on_left" ---
    blacksquare_19 = visual.Rect(
        win=win, name='blacksquare_19',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_19 = visual.ShapeStim(
        win=win, name='white_cross_19', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_22 = keyboard.Keyboard(deviceName='key_resp_22')
    arrow_l_3 = visual.ShapeStim(
        win=win, name='arrow_l_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=-90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_7 = visual.Rect(
        win=win, name='whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_14 = visual.Rect(
        win=win, name='whitesquare_14',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_right" ---
    blacksquare_20 = visual.Rect(
        win=win, name='blacksquare_20',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_20 = visual.ShapeStim(
        win=win, name='white_cross_20', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_23 = keyboard.Keyboard(deviceName='key_resp_23')
    arrow_l_4 = visual.ShapeStim(
        win=win, name='arrow_l_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_11 = visual.Rect(
        win=win, name='whitesquare_11',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_18 = visual.Rect(
        win=win, name='whitesquare_18',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "rightA_on_left" ---
    blacksquare_21 = visual.Rect(
        win=win, name='blacksquare_21',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_21 = visual.ShapeStim(
        win=win, name='white_cross_21', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_24 = keyboard.Keyboard(deviceName='key_resp_24')
    arrow_l_5 = visual.ShapeStim(
        win=win, name='arrow_l_5', vertices='arrow',
        size=(0.028, 0.11),
        ori=90.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    whitesquare_9 = visual.Rect(
        win=win, name='whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    whitesquare_16 = visual.Rect(
        win=win, name='whitesquare_16',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(-0.15, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_up" ---
    blacksquare_22 = visual.Rect(
        win=win, name='blacksquare_22',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_22 = visual.ShapeStim(
        win=win, name='white_cross_22', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_25 = keyboard.Keyboard(deviceName='key_resp_25')
    arrow_u = visual.ShapeStim(
        win=win, name='arrow_u', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_3 = visual.Rect(
        win=win, name='up_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_3 = visual.Rect(
        win=win, name='down_whitesquare_3',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "upA_on_down" ---
    blacksquare_23 = visual.Rect(
        win=win, name='blacksquare_23',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_23 = visual.ShapeStim(
        win=win, name='white_cross_23', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_26 = keyboard.Keyboard(deviceName='key_resp_26')
    arrow_u_2 = visual.ShapeStim(
        win=win, name='arrow_u_2', vertices='arrow',
        size=(0.028, 0.11),
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_7 = visual.Rect(
        win=win, name='up_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_7 = visual.Rect(
        win=win, name='down_whitesquare_7',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_down" ---
    blacksquare_24 = visual.Rect(
        win=win, name='blacksquare_24',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_24 = visual.ShapeStim(
        win=win, name='white_cross_24', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_27 = keyboard.Keyboard(deviceName='key_resp_27')
    arrow_u_3 = visual.ShapeStim(
        win=win, name='arrow_u_3', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_9 = visual.Rect(
        win=win, name='up_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_9 = visual.Rect(
        win=win, name='down_whitesquare_9',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "downA_on_up" ---
    blacksquare_25 = visual.Rect(
        win=win, name='blacksquare_25',
        width=(0.6, 0.6)[0], height=(0.6, 0.6)[1],
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='black',
        opacity=None, depth=0.0, interpolate=True)
    white_cross_25 = visual.ShapeStim(
        win=win, name='white_cross_25', vertices='cross',
        size=(0.02, 0.02),
        ori=0.0, pos=(0, 0), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-1.0, interpolate=True)
    key_resp_28 = keyboard.Keyboard(deviceName='key_resp_28')
    arrow_u_4 = visual.ShapeStim(
        win=win, name='arrow_u_4', vertices='arrow',
        size=(0.028, 0.11),
        ori=180.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=2.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-3.0, interpolate=True)
    up_whitesquare_5 = visual.Rect(
        win=win, name='up_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, 0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-4.0, interpolate=True)
    down_whitesquare_5 = visual.Rect(
        win=win, name='down_whitesquare_5',
        width=(0.1, 0.1)[0], height=(0.1, 0.1)[1],
        ori=0.0, pos=(0, -0.15), draggable=False, anchor='center',
        lineWidth=1.0,
        colorSpace='rgb', lineColor='white', fillColor='white',
        opacity=None, depth=-5.0, interpolate=True)
    
    # --- Initialize components for Routine "end" ---
    text_37 = visual.TextStim(win=win, name='text_37',
        text='Thank you!\nThis task is now finished',
        font='Arial',
        pos=(0, 0.07), draggable=False, height=0.035, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=0.0);
    text_38 = visual.TextStim(win=win, name='text_38',
        text='Press space bar to continue',
        font='Arial',
        pos=(0, -0.3), draggable=False, height=0.02, wrapWidth=None, ori=0.0, 
        color='black', colorSpace='rgb', opacity=None, 
        languageStyle='LTR',
        depth=-1.0);
    key_resp_34 = keyboard.Keyboard(deviceName='key_resp_34')
    
    # create some handy timers
    
    # global clock to track the time since experiment started
    if globalClock is None:
        # create a clock if not given one
        globalClock = core.Clock()
    if isinstance(globalClock, str):
        # if given a string, make a clock accoridng to it
        if globalClock == 'float':
            # get timestamps as a simple value
            globalClock = core.Clock(format='float')
        elif globalClock == 'iso':
            # get timestamps in ISO format
            globalClock = core.Clock(format='%Y-%m-%d_%H:%M:%S.%f%z')
        else:
            # get timestamps in a custom format
            globalClock = core.Clock(format=globalClock)
    if ioServer is not None:
        ioServer.syncClock(globalClock)
    logging.setDefaultClock(globalClock)
    # routine timer to track time remaining of each (possibly non-slip) routine
    routineTimer = core.Clock()
    win.flip()  # flip window to reset last flip timer
    # store the exact time the global clock started
    expInfo['expStart'] = data.getDateStr(
        format='%Y-%m-%d %Hh%M.%S.%f %z', fractionalSecondDigits=6
    )
    
    # --- Prepare to start Routine "Intro" ---
    # create an object to store info about Routine Intro
    Intro = data.Routine(
        name='Intro',
        components=[text, key_resp],
    )
    Intro.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp
    key_resp.keys = []
    key_resp.rt = []
    _key_resp_allKeys = []
    # store start times for Intro
    Intro.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    Intro.tStart = globalClock.getTime(format='float')
    Intro.status = STARTED
    thisExp.addData('Intro.started', Intro.tStart)
    Intro.maxDuration = None
    # keep track of which components have finished
    IntroComponents = Intro.components
    for thisComponent in Intro.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "Intro" ---
    Intro.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text* updates
        
        # if text is starting this frame...
        if text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text.frameNStart = frameN  # exact frame index
            text.tStart = t  # local t and not account for scr refresh
            text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text.started')
            # update status
            text.status = STARTED
            text.setAutoDraw(True)
        
        # if text is active this frame...
        if text.status == STARTED:
            # update params
            pass
        
        # *key_resp* updates
        waitOnFlip = False
        
        # if key_resp is starting this frame...
        if key_resp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp.frameNStart = frameN  # exact frame index
            key_resp.tStart = t  # local t and not account for scr refresh
            key_resp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp.started')
            # update status
            key_resp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp.status == STARTED and not waitOnFlip:
            theseKeys = key_resp.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_allKeys.extend(theseKeys)
            if len(_key_resp_allKeys):
                key_resp.keys = _key_resp_allKeys[-1].name  # just the last key pressed
                key_resp.rt = _key_resp_allKeys[-1].rt
                key_resp.duration = _key_resp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            Intro.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in Intro.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "Intro" ---
    for thisComponent in Intro.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for Intro
    Intro.tStop = globalClock.getTime(format='float')
    Intro.tStopRefresh = tThisFlipGlobal
    thisExp.addData('Intro.stopped', Intro.tStop)
    # check responses
    if key_resp.keys in ['', [], None]:  # No response was made
        key_resp.keys = None
    thisExp.addData('key_resp.keys',key_resp.keys)
    if key_resp.keys != None:  # we had a response
        thisExp.addData('key_resp.rt', key_resp.rt)
        thisExp.addData('key_resp.duration', key_resp.duration)
    thisExp.nextEntry()
    # the Routine "Intro" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instr1" ---
    # create an object to store info about Routine instr1
    instr1 = data.Routine(
        name='instr1',
        components=[text_2, text_3, key_resp_2],
    )
    instr1.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_2
    key_resp_2.keys = []
    key_resp_2.rt = []
    _key_resp_2_allKeys = []
    # store start times for instr1
    instr1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instr1.tStart = globalClock.getTime(format='float')
    instr1.status = STARTED
    thisExp.addData('instr1.started', instr1.tStart)
    instr1.maxDuration = None
    # keep track of which components have finished
    instr1Components = instr1.components
    for thisComponent in instr1.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instr1" ---
    instr1.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_2* updates
        
        # if text_2 is starting this frame...
        if text_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_2.frameNStart = frameN  # exact frame index
            text_2.tStart = t  # local t and not account for scr refresh
            text_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_2.started')
            # update status
            text_2.status = STARTED
            text_2.setAutoDraw(True)
        
        # if text_2 is active this frame...
        if text_2.status == STARTED:
            # update params
            pass
        
        # *text_3* updates
        
        # if text_3 is starting this frame...
        if text_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_3.frameNStart = frameN  # exact frame index
            text_3.tStart = t  # local t and not account for scr refresh
            text_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_3.started')
            # update status
            text_3.status = STARTED
            text_3.setAutoDraw(True)
        
        # if text_3 is active this frame...
        if text_3.status == STARTED:
            # update params
            pass
        
        # *key_resp_2* updates
        waitOnFlip = False
        
        # if key_resp_2 is starting this frame...
        if key_resp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_2.frameNStart = frameN  # exact frame index
            key_resp_2.tStart = t  # local t and not account for scr refresh
            key_resp_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_2.started')
            # update status
            key_resp_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_2.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_2.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_2_allKeys.extend(theseKeys)
            if len(_key_resp_2_allKeys):
                key_resp_2.keys = _key_resp_2_allKeys[-1].name  # just the last key pressed
                key_resp_2.rt = _key_resp_2_allKeys[-1].rt
                key_resp_2.duration = _key_resp_2_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instr1.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instr1.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instr1" ---
    for thisComponent in instr1.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instr1
    instr1.tStop = globalClock.getTime(format='float')
    instr1.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instr1.stopped', instr1.tStop)
    # check responses
    if key_resp_2.keys in ['', [], None]:  # No response was made
        key_resp_2.keys = None
    thisExp.addData('key_resp_2.keys',key_resp_2.keys)
    if key_resp_2.keys != None:  # we had a response
        thisExp.addData('key_resp_2.rt', key_resp_2.rt)
        thisExp.addData('key_resp_2.duration', key_resp_2.duration)
    thisExp.nextEntry()
    # the Routine "instr1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instr2" ---
    # create an object to store info about Routine instr2
    instr2 = data.Routine(
        name='instr2',
        components=[text_4, text_5, key_resp_3],
    )
    instr2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_3
    key_resp_3.keys = []
    key_resp_3.rt = []
    _key_resp_3_allKeys = []
    # store start times for instr2
    instr2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instr2.tStart = globalClock.getTime(format='float')
    instr2.status = STARTED
    thisExp.addData('instr2.started', instr2.tStart)
    instr2.maxDuration = None
    # keep track of which components have finished
    instr2Components = instr2.components
    for thisComponent in instr2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instr2" ---
    instr2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_4* updates
        
        # if text_4 is starting this frame...
        if text_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_4.frameNStart = frameN  # exact frame index
            text_4.tStart = t  # local t and not account for scr refresh
            text_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_4.started')
            # update status
            text_4.status = STARTED
            text_4.setAutoDraw(True)
        
        # if text_4 is active this frame...
        if text_4.status == STARTED:
            # update params
            pass
        
        # *text_5* updates
        
        # if text_5 is starting this frame...
        if text_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_5.frameNStart = frameN  # exact frame index
            text_5.tStart = t  # local t and not account for scr refresh
            text_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_5.started')
            # update status
            text_5.status = STARTED
            text_5.setAutoDraw(True)
        
        # if text_5 is active this frame...
        if text_5.status == STARTED:
            # update params
            pass
        
        # *key_resp_3* updates
        waitOnFlip = False
        
        # if key_resp_3 is starting this frame...
        if key_resp_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_3.frameNStart = frameN  # exact frame index
            key_resp_3.tStart = t  # local t and not account for scr refresh
            key_resp_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_3.started')
            # update status
            key_resp_3.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_3.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_3.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_3.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_3.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_3_allKeys.extend(theseKeys)
            if len(_key_resp_3_allKeys):
                key_resp_3.keys = _key_resp_3_allKeys[-1].name  # just the last key pressed
                key_resp_3.rt = _key_resp_3_allKeys[-1].rt
                key_resp_3.duration = _key_resp_3_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instr2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instr2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instr2" ---
    for thisComponent in instr2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instr2
    instr2.tStop = globalClock.getTime(format='float')
    instr2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instr2.stopped', instr2.tStop)
    # check responses
    if key_resp_3.keys in ['', [], None]:  # No response was made
        key_resp_3.keys = None
    thisExp.addData('key_resp_3.keys',key_resp_3.keys)
    if key_resp_3.keys != None:  # we had a response
        thisExp.addData('key_resp_3.rt', key_resp_3.rt)
        thisExp.addData('key_resp_3.duration', key_resp_3.duration)
    thisExp.nextEntry()
    # the Routine "instr2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instr3" ---
    # create an object to store info about Routine instr3
    instr3 = data.Routine(
        name='instr3',
        components=[text_6, text_7, key_resp_4, text_8],
    )
    instr3.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_4
    key_resp_4.keys = []
    key_resp_4.rt = []
    _key_resp_4_allKeys = []
    # store start times for instr3
    instr3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instr3.tStart = globalClock.getTime(format='float')
    instr3.status = STARTED
    thisExp.addData('instr3.started', instr3.tStart)
    instr3.maxDuration = None
    # keep track of which components have finished
    instr3Components = instr3.components
    for thisComponent in instr3.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instr3" ---
    instr3.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_6* updates
        
        # if text_6 is starting this frame...
        if text_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_6.frameNStart = frameN  # exact frame index
            text_6.tStart = t  # local t and not account for scr refresh
            text_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_6.started')
            # update status
            text_6.status = STARTED
            text_6.setAutoDraw(True)
        
        # if text_6 is active this frame...
        if text_6.status == STARTED:
            # update params
            pass
        
        # *text_7* updates
        
        # if text_7 is starting this frame...
        if text_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_7.frameNStart = frameN  # exact frame index
            text_7.tStart = t  # local t and not account for scr refresh
            text_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_7.started')
            # update status
            text_7.status = STARTED
            text_7.setAutoDraw(True)
        
        # if text_7 is active this frame...
        if text_7.status == STARTED:
            # update params
            pass
        
        # *key_resp_4* updates
        waitOnFlip = False
        
        # if key_resp_4 is starting this frame...
        if key_resp_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_4.frameNStart = frameN  # exact frame index
            key_resp_4.tStart = t  # local t and not account for scr refresh
            key_resp_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_4.started')
            # update status
            key_resp_4.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_4.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_4.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_4.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_4.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_4_allKeys.extend(theseKeys)
            if len(_key_resp_4_allKeys):
                key_resp_4.keys = _key_resp_4_allKeys[-1].name  # just the last key pressed
                key_resp_4.rt = _key_resp_4_allKeys[-1].rt
                key_resp_4.duration = _key_resp_4_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_8* updates
        
        # if text_8 is starting this frame...
        if text_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_8.frameNStart = frameN  # exact frame index
            text_8.tStart = t  # local t and not account for scr refresh
            text_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_8.started')
            # update status
            text_8.status = STARTED
            text_8.setAutoDraw(True)
        
        # if text_8 is active this frame...
        if text_8.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instr3.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instr3.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instr3" ---
    for thisComponent in instr3.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instr3
    instr3.tStop = globalClock.getTime(format='float')
    instr3.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instr3.stopped', instr3.tStop)
    # check responses
    if key_resp_4.keys in ['', [], None]:  # No response was made
        key_resp_4.keys = None
    thisExp.addData('key_resp_4.keys',key_resp_4.keys)
    if key_resp_4.keys != None:  # we had a response
        thisExp.addData('key_resp_4.rt', key_resp_4.rt)
        thisExp.addData('key_resp_4.duration', key_resp_4.duration)
    thisExp.nextEntry()
    # the Routine "instr3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instr4" ---
    # create an object to store info about Routine instr4
    instr4 = data.Routine(
        name='instr4',
        components=[text_9, text_10, key_resp_5, text_11],
    )
    instr4.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_5
    key_resp_5.keys = []
    key_resp_5.rt = []
    _key_resp_5_allKeys = []
    # store start times for instr4
    instr4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instr4.tStart = globalClock.getTime(format='float')
    instr4.status = STARTED
    thisExp.addData('instr4.started', instr4.tStart)
    instr4.maxDuration = None
    # keep track of which components have finished
    instr4Components = instr4.components
    for thisComponent in instr4.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instr4" ---
    instr4.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_9* updates
        
        # if text_9 is starting this frame...
        if text_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_9.frameNStart = frameN  # exact frame index
            text_9.tStart = t  # local t and not account for scr refresh
            text_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_9.started')
            # update status
            text_9.status = STARTED
            text_9.setAutoDraw(True)
        
        # if text_9 is active this frame...
        if text_9.status == STARTED:
            # update params
            pass
        
        # *text_10* updates
        
        # if text_10 is starting this frame...
        if text_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_10.frameNStart = frameN  # exact frame index
            text_10.tStart = t  # local t and not account for scr refresh
            text_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_10, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_10.started')
            # update status
            text_10.status = STARTED
            text_10.setAutoDraw(True)
        
        # if text_10 is active this frame...
        if text_10.status == STARTED:
            # update params
            pass
        
        # *key_resp_5* updates
        waitOnFlip = False
        
        # if key_resp_5 is starting this frame...
        if key_resp_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_5.frameNStart = frameN  # exact frame index
            key_resp_5.tStart = t  # local t and not account for scr refresh
            key_resp_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_5.started')
            # update status
            key_resp_5.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_5.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_5.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_5.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_5.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_5_allKeys.extend(theseKeys)
            if len(_key_resp_5_allKeys):
                key_resp_5.keys = _key_resp_5_allKeys[-1].name  # just the last key pressed
                key_resp_5.rt = _key_resp_5_allKeys[-1].rt
                key_resp_5.duration = _key_resp_5_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *text_11* updates
        
        # if text_11 is starting this frame...
        if text_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_11.frameNStart = frameN  # exact frame index
            text_11.tStart = t  # local t and not account for scr refresh
            text_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_11.started')
            # update status
            text_11.status = STARTED
            text_11.setAutoDraw(True)
        
        # if text_11 is active this frame...
        if text_11.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instr4.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instr4.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instr4" ---
    for thisComponent in instr4.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instr4
    instr4.tStop = globalClock.getTime(format='float')
    instr4.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instr4.stopped', instr4.tStop)
    # check responses
    if key_resp_5.keys in ['', [], None]:  # No response was made
        key_resp_5.keys = None
    thisExp.addData('key_resp_5.keys',key_resp_5.keys)
    if key_resp_5.keys != None:  # we had a response
        thisExp.addData('key_resp_5.rt', key_resp_5.rt)
        thisExp.addData('key_resp_5.duration', key_resp_5.duration)
    thisExp.nextEntry()
    # the Routine "instr4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "ex_leftarrow" ---
    # create an object to store info about Routine ex_leftarrow
    ex_leftarrow = data.Routine(
        name='ex_leftarrow',
        components=[blacksquare, press_right, right_keyresp, arrow_r, white_cross, text_12],
    )
    ex_leftarrow.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for right_keyresp
    right_keyresp.keys = []
    right_keyresp.rt = []
    _right_keyresp_allKeys = []
    # store start times for ex_leftarrow
    ex_leftarrow.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    ex_leftarrow.tStart = globalClock.getTime(format='float')
    ex_leftarrow.status = STARTED
    thisExp.addData('ex_leftarrow.started', ex_leftarrow.tStart)
    ex_leftarrow.maxDuration = None
    # keep track of which components have finished
    ex_leftarrowComponents = ex_leftarrow.components
    for thisComponent in ex_leftarrow.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "ex_leftarrow" ---
    ex_leftarrow.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare* updates
        
        # if blacksquare is starting this frame...
        if blacksquare.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare.frameNStart = frameN  # exact frame index
            blacksquare.tStart = t  # local t and not account for scr refresh
            blacksquare.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare.started')
            # update status
            blacksquare.status = STARTED
            blacksquare.setAutoDraw(True)
        
        # if blacksquare is active this frame...
        if blacksquare.status == STARTED:
            # update params
            pass
        
        # *press_right* updates
        
        # if press_right is starting this frame...
        if press_right.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            press_right.frameNStart = frameN  # exact frame index
            press_right.tStart = t  # local t and not account for scr refresh
            press_right.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(press_right, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'press_right.started')
            # update status
            press_right.status = STARTED
            press_right.setAutoDraw(True)
        
        # if press_right is active this frame...
        if press_right.status == STARTED:
            # update params
            pass
        
        # *right_keyresp* updates
        waitOnFlip = False
        
        # if right_keyresp is starting this frame...
        if right_keyresp.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            right_keyresp.frameNStart = frameN  # exact frame index
            right_keyresp.tStart = t  # local t and not account for scr refresh
            right_keyresp.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(right_keyresp, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'right_keyresp.started')
            # update status
            right_keyresp.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(right_keyresp.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(right_keyresp.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if right_keyresp.status == STARTED and not waitOnFlip:
            theseKeys = right_keyresp.getKeys(keyList=['right'], ignoreKeys=["escape"], waitRelease=False)
            _right_keyresp_allKeys.extend(theseKeys)
            if len(_right_keyresp_allKeys):
                right_keyresp.keys = _right_keyresp_allKeys[-1].name  # just the last key pressed
                right_keyresp.rt = _right_keyresp_allKeys[-1].rt
                right_keyresp.duration = _right_keyresp_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *arrow_r* updates
        
        # if arrow_r is starting this frame...
        if arrow_r.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            arrow_r.frameNStart = frameN  # exact frame index
            arrow_r.tStart = t  # local t and not account for scr refresh
            arrow_r.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(arrow_r, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'arrow_r.started')
            # update status
            arrow_r.status = STARTED
            arrow_r.setAutoDraw(True)
        
        # if arrow_r is active this frame...
        if arrow_r.status == STARTED:
            # update params
            pass
        
        # *white_cross* updates
        
        # if white_cross is starting this frame...
        if white_cross.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross.frameNStart = frameN  # exact frame index
            white_cross.tStart = t  # local t and not account for scr refresh
            white_cross.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross.started')
            # update status
            white_cross.status = STARTED
            white_cross.setAutoDraw(True)
        
        # if white_cross is active this frame...
        if white_cross.status == STARTED:
            # update params
            pass
        
        # *text_12* updates
        
        # if text_12 is starting this frame...
        if text_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_12.frameNStart = frameN  # exact frame index
            text_12.tStart = t  # local t and not account for scr refresh
            text_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_12, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_12.started')
            # update status
            text_12.status = STARTED
            text_12.setAutoDraw(True)
        
        # if text_12 is active this frame...
        if text_12.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            ex_leftarrow.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in ex_leftarrow.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "ex_leftarrow" ---
    for thisComponent in ex_leftarrow.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for ex_leftarrow
    ex_leftarrow.tStop = globalClock.getTime(format='float')
    ex_leftarrow.tStopRefresh = tThisFlipGlobal
    thisExp.addData('ex_leftarrow.stopped', ex_leftarrow.tStop)
    # check responses
    if right_keyresp.keys in ['', [], None]:  # No response was made
        right_keyresp.keys = None
    thisExp.addData('right_keyresp.keys',right_keyresp.keys)
    if right_keyresp.keys != None:  # we had a response
        thisExp.addData('right_keyresp.rt', right_keyresp.rt)
        thisExp.addData('right_keyresp.duration', right_keyresp.duration)
    thisExp.nextEntry()
    # the Routine "ex_leftarrow" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "ex_RIGHT" ---
    # create an object to store info about Routine ex_RIGHT
    ex_RIGHT = data.Routine(
        name='ex_RIGHT',
        components=[blacksquare_2, press_right_2, right_keyresp_2, white_cross_2, text_13, RIGHT],
    )
    ex_RIGHT.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for right_keyresp_2
    right_keyresp_2.keys = []
    right_keyresp_2.rt = []
    _right_keyresp_2_allKeys = []
    # store start times for ex_RIGHT
    ex_RIGHT.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    ex_RIGHT.tStart = globalClock.getTime(format='float')
    ex_RIGHT.status = STARTED
    thisExp.addData('ex_RIGHT.started', ex_RIGHT.tStart)
    ex_RIGHT.maxDuration = None
    # keep track of which components have finished
    ex_RIGHTComponents = ex_RIGHT.components
    for thisComponent in ex_RIGHT.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "ex_RIGHT" ---
    ex_RIGHT.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_2* updates
        
        # if blacksquare_2 is starting this frame...
        if blacksquare_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_2.frameNStart = frameN  # exact frame index
            blacksquare_2.tStart = t  # local t and not account for scr refresh
            blacksquare_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_2.started')
            # update status
            blacksquare_2.status = STARTED
            blacksquare_2.setAutoDraw(True)
        
        # if blacksquare_2 is active this frame...
        if blacksquare_2.status == STARTED:
            # update params
            pass
        
        # *press_right_2* updates
        
        # if press_right_2 is starting this frame...
        if press_right_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            press_right_2.frameNStart = frameN  # exact frame index
            press_right_2.tStart = t  # local t and not account for scr refresh
            press_right_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(press_right_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'press_right_2.started')
            # update status
            press_right_2.status = STARTED
            press_right_2.setAutoDraw(True)
        
        # if press_right_2 is active this frame...
        if press_right_2.status == STARTED:
            # update params
            pass
        
        # *right_keyresp_2* updates
        waitOnFlip = False
        
        # if right_keyresp_2 is starting this frame...
        if right_keyresp_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            right_keyresp_2.frameNStart = frameN  # exact frame index
            right_keyresp_2.tStart = t  # local t and not account for scr refresh
            right_keyresp_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(right_keyresp_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'right_keyresp_2.started')
            # update status
            right_keyresp_2.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(right_keyresp_2.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(right_keyresp_2.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if right_keyresp_2.status == STARTED and not waitOnFlip:
            theseKeys = right_keyresp_2.getKeys(keyList=['right'], ignoreKeys=["escape"], waitRelease=False)
            _right_keyresp_2_allKeys.extend(theseKeys)
            if len(_right_keyresp_2_allKeys):
                right_keyresp_2.keys = _right_keyresp_2_allKeys[-1].name  # just the last key pressed
                right_keyresp_2.rt = _right_keyresp_2_allKeys[-1].rt
                right_keyresp_2.duration = _right_keyresp_2_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # *white_cross_2* updates
        
        # if white_cross_2 is starting this frame...
        if white_cross_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_2.frameNStart = frameN  # exact frame index
            white_cross_2.tStart = t  # local t and not account for scr refresh
            white_cross_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_2.started')
            # update status
            white_cross_2.status = STARTED
            white_cross_2.setAutoDraw(True)
        
        # if white_cross_2 is active this frame...
        if white_cross_2.status == STARTED:
            # update params
            pass
        
        # *text_13* updates
        
        # if text_13 is starting this frame...
        if text_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_13.frameNStart = frameN  # exact frame index
            text_13.tStart = t  # local t and not account for scr refresh
            text_13.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_13, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_13.started')
            # update status
            text_13.status = STARTED
            text_13.setAutoDraw(True)
        
        # if text_13 is active this frame...
        if text_13.status == STARTED:
            # update params
            pass
        
        # *RIGHT* updates
        
        # if RIGHT is starting this frame...
        if RIGHT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            RIGHT.frameNStart = frameN  # exact frame index
            RIGHT.tStart = t  # local t and not account for scr refresh
            RIGHT.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(RIGHT, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'RIGHT.started')
            # update status
            RIGHT.status = STARTED
            RIGHT.setAutoDraw(True)
        
        # if RIGHT is active this frame...
        if RIGHT.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            ex_RIGHT.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in ex_RIGHT.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "ex_RIGHT" ---
    for thisComponent in ex_RIGHT.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for ex_RIGHT
    ex_RIGHT.tStop = globalClock.getTime(format='float')
    ex_RIGHT.tStopRefresh = tThisFlipGlobal
    thisExp.addData('ex_RIGHT.stopped', ex_RIGHT.tStop)
    # check responses
    if right_keyresp_2.keys in ['', [], None]:  # No response was made
        right_keyresp_2.keys = None
    thisExp.addData('right_keyresp_2.keys',right_keyresp_2.keys)
    if right_keyresp_2.keys != None:  # we had a response
        thisExp.addData('right_keyresp_2.rt', right_keyresp_2.rt)
        thisExp.addData('right_keyresp_2.duration', right_keyresp_2.duration)
    thisExp.nextEntry()
    # the Routine "ex_RIGHT" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "lets_practice" ---
    # create an object to store info about Routine lets_practice
    lets_practice = data.Routine(
        name='lets_practice',
        components=[practice_text, key_resp_6],
    )
    lets_practice.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_6
    key_resp_6.keys = []
    key_resp_6.rt = []
    _key_resp_6_allKeys = []
    # store start times for lets_practice
    lets_practice.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    lets_practice.tStart = globalClock.getTime(format='float')
    lets_practice.status = STARTED
    thisExp.addData('lets_practice.started', lets_practice.tStart)
    lets_practice.maxDuration = None
    # keep track of which components have finished
    lets_practiceComponents = lets_practice.components
    for thisComponent in lets_practice.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "lets_practice" ---
    lets_practice.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *practice_text* updates
        
        # if practice_text is starting this frame...
        if practice_text.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            practice_text.frameNStart = frameN  # exact frame index
            practice_text.tStart = t  # local t and not account for scr refresh
            practice_text.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(practice_text, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'practice_text.started')
            # update status
            practice_text.status = STARTED
            practice_text.setAutoDraw(True)
        
        # if practice_text is active this frame...
        if practice_text.status == STARTED:
            # update params
            pass
        
        # *key_resp_6* updates
        waitOnFlip = False
        
        # if key_resp_6 is starting this frame...
        if key_resp_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_6.frameNStart = frameN  # exact frame index
            key_resp_6.tStart = t  # local t and not account for scr refresh
            key_resp_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_6.started')
            # update status
            key_resp_6.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_6.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_6.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_6.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_6.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_6_allKeys.extend(theseKeys)
            if len(_key_resp_6_allKeys):
                key_resp_6.keys = _key_resp_6_allKeys[-1].name  # just the last key pressed
                key_resp_6.rt = _key_resp_6_allKeys[-1].rt
                key_resp_6.duration = _key_resp_6_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            lets_practice.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in lets_practice.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "lets_practice" ---
    for thisComponent in lets_practice.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for lets_practice
    lets_practice.tStop = globalClock.getTime(format='float')
    lets_practice.tStopRefresh = tThisFlipGlobal
    thisExp.addData('lets_practice.stopped', lets_practice.tStop)
    # check responses
    if key_resp_6.keys in ['', [], None]:  # No response was made
        key_resp_6.keys = None
    thisExp.addData('key_resp_6.keys',key_resp_6.keys)
    if key_resp_6.keys != None:  # we had a response
        thisExp.addData('key_resp_6.rt', key_resp_6.rt)
        thisExp.addData('key_resp_6.duration', key_resp_6.duration)
    thisExp.nextEntry()
    # the Routine "lets_practice" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "empty_square" ---
    # create an object to store info about Routine empty_square
    empty_square = data.Routine(
        name='empty_square',
        components=[blacksquare_3, white_cross_3],
    )
    empty_square.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for empty_square
    empty_square.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    empty_square.tStart = globalClock.getTime(format='float')
    empty_square.status = STARTED
    thisExp.addData('empty_square.started', empty_square.tStart)
    empty_square.maxDuration = None
    # keep track of which components have finished
    empty_squareComponents = empty_square.components
    for thisComponent in empty_square.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "empty_square" ---
    empty_square.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.4:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_3* updates
        
        # if blacksquare_3 is starting this frame...
        if blacksquare_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_3.frameNStart = frameN  # exact frame index
            blacksquare_3.tStart = t  # local t and not account for scr refresh
            blacksquare_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_3.started')
            # update status
            blacksquare_3.status = STARTED
            blacksquare_3.setAutoDraw(True)
        
        # if blacksquare_3 is active this frame...
        if blacksquare_3.status == STARTED:
            # update params
            pass
        
        # if blacksquare_3 is stopping this frame...
        if blacksquare_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_3.tStop = t  # not accounting for scr refresh
                blacksquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_3.stopped')
                # update status
                blacksquare_3.status = FINISHED
                blacksquare_3.setAutoDraw(False)
        
        # *white_cross_3* updates
        
        # if white_cross_3 is starting this frame...
        if white_cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_3.frameNStart = frameN  # exact frame index
            white_cross_3.tStart = t  # local t and not account for scr refresh
            white_cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_3.started')
            # update status
            white_cross_3.status = STARTED
            white_cross_3.setAutoDraw(True)
        
        # if white_cross_3 is active this frame...
        if white_cross_3.status == STARTED:
            # update params
            pass
        
        # if white_cross_3 is stopping this frame...
        if white_cross_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_3.tStop = t  # not accounting for scr refresh
                white_cross_3.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_3.stopped')
                # update status
                white_cross_3.status = FINISHED
                white_cross_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            empty_square.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in empty_square.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "empty_square" ---
    for thisComponent in empty_square.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for empty_square
    empty_square.tStop = globalClock.getTime(format='float')
    empty_square.tStopRefresh = tThisFlipGlobal
    thisExp.addData('empty_square.stopped', empty_square.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if empty_square.maxDurationReached:
        routineTimer.addTime(-empty_square.maxDuration)
    elif empty_square.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.400000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "LR_squares" ---
    # create an object to store info about Routine LR_squares
    LR_squares = data.Routine(
        name='LR_squares',
        components=[blacksquare_4, white_cross_4, whitesquare, whitesquare_2],
    )
    LR_squares.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for LR_squares
    LR_squares.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    LR_squares.tStart = globalClock.getTime(format='float')
    LR_squares.status = STARTED
    thisExp.addData('LR_squares.started', LR_squares.tStart)
    LR_squares.maxDuration = None
    # keep track of which components have finished
    LR_squaresComponents = LR_squares.components
    for thisComponent in LR_squares.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "LR_squares" ---
    LR_squares.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.1:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_4* updates
        
        # if blacksquare_4 is starting this frame...
        if blacksquare_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_4.frameNStart = frameN  # exact frame index
            blacksquare_4.tStart = t  # local t and not account for scr refresh
            blacksquare_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_4.started')
            # update status
            blacksquare_4.status = STARTED
            blacksquare_4.setAutoDraw(True)
        
        # if blacksquare_4 is active this frame...
        if blacksquare_4.status == STARTED:
            # update params
            pass
        
        # if blacksquare_4 is stopping this frame...
        if blacksquare_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_4.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_4.tStop = t  # not accounting for scr refresh
                blacksquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_4.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_4.stopped')
                # update status
                blacksquare_4.status = FINISHED
                blacksquare_4.setAutoDraw(False)
        
        # *white_cross_4* updates
        
        # if white_cross_4 is starting this frame...
        if white_cross_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_4.frameNStart = frameN  # exact frame index
            white_cross_4.tStart = t  # local t and not account for scr refresh
            white_cross_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_4.started')
            # update status
            white_cross_4.status = STARTED
            white_cross_4.setAutoDraw(True)
        
        # if white_cross_4 is active this frame...
        if white_cross_4.status == STARTED:
            # update params
            pass
        
        # if white_cross_4 is stopping this frame...
        if white_cross_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_4.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_4.tStop = t  # not accounting for scr refresh
                white_cross_4.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_4.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_4.stopped')
                # update status
                white_cross_4.status = FINISHED
                white_cross_4.setAutoDraw(False)
        
        # *whitesquare* updates
        
        # if whitesquare is starting this frame...
        if whitesquare.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            whitesquare.frameNStart = frameN  # exact frame index
            whitesquare.tStart = t  # local t and not account for scr refresh
            whitesquare.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(whitesquare, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'whitesquare.started')
            # update status
            whitesquare.status = STARTED
            whitesquare.setAutoDraw(True)
        
        # if whitesquare is active this frame...
        if whitesquare.status == STARTED:
            # update params
            pass
        
        # if whitesquare is stopping this frame...
        if whitesquare.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > whitesquare.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                whitesquare.tStop = t  # not accounting for scr refresh
                whitesquare.tStopRefresh = tThisFlipGlobal  # on global time
                whitesquare.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare.stopped')
                # update status
                whitesquare.status = FINISHED
                whitesquare.setAutoDraw(False)
        
        # *whitesquare_2* updates
        
        # if whitesquare_2 is starting this frame...
        if whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            whitesquare_2.frameNStart = frameN  # exact frame index
            whitesquare_2.tStart = t  # local t and not account for scr refresh
            whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(whitesquare_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'whitesquare_2.started')
            # update status
            whitesquare_2.status = STARTED
            whitesquare_2.setAutoDraw(True)
        
        # if whitesquare_2 is active this frame...
        if whitesquare_2.status == STARTED:
            # update params
            pass
        
        # if whitesquare_2 is stopping this frame...
        if whitesquare_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                whitesquare_2.tStop = t  # not accounting for scr refresh
                whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                whitesquare_2.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_2.stopped')
                # update status
                whitesquare_2.status = FINISHED
                whitesquare_2.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            LR_squares.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in LR_squares.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "LR_squares" ---
    for thisComponent in LR_squares.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for LR_squares
    LR_squares.tStop = globalClock.getTime(format='float')
    LR_squares.tStopRefresh = tThisFlipGlobal
    thisExp.addData('LR_squares.stopped', LR_squares.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if LR_squares.maxDurationReached:
        routineTimer.addTime(-LR_squares.maxDuration)
    elif LR_squares.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.100000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "empty_square" ---
    # create an object to store info about Routine empty_square
    empty_square = data.Routine(
        name='empty_square',
        components=[blacksquare_3, white_cross_3],
    )
    empty_square.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for empty_square
    empty_square.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    empty_square.tStart = globalClock.getTime(format='float')
    empty_square.status = STARTED
    thisExp.addData('empty_square.started', empty_square.tStart)
    empty_square.maxDuration = None
    # keep track of which components have finished
    empty_squareComponents = empty_square.components
    for thisComponent in empty_square.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "empty_square" ---
    empty_square.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.4:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_3* updates
        
        # if blacksquare_3 is starting this frame...
        if blacksquare_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_3.frameNStart = frameN  # exact frame index
            blacksquare_3.tStart = t  # local t and not account for scr refresh
            blacksquare_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_3.started')
            # update status
            blacksquare_3.status = STARTED
            blacksquare_3.setAutoDraw(True)
        
        # if blacksquare_3 is active this frame...
        if blacksquare_3.status == STARTED:
            # update params
            pass
        
        # if blacksquare_3 is stopping this frame...
        if blacksquare_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_3.tStop = t  # not accounting for scr refresh
                blacksquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_3.stopped')
                # update status
                blacksquare_3.status = FINISHED
                blacksquare_3.setAutoDraw(False)
        
        # *white_cross_3* updates
        
        # if white_cross_3 is starting this frame...
        if white_cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_3.frameNStart = frameN  # exact frame index
            white_cross_3.tStart = t  # local t and not account for scr refresh
            white_cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_3.started')
            # update status
            white_cross_3.status = STARTED
            white_cross_3.setAutoDraw(True)
        
        # if white_cross_3 is active this frame...
        if white_cross_3.status == STARTED:
            # update params
            pass
        
        # if white_cross_3 is stopping this frame...
        if white_cross_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_3.tStop = t  # not accounting for scr refresh
                white_cross_3.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_3.stopped')
                # update status
                white_cross_3.status = FINISHED
                white_cross_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            empty_square.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in empty_square.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "empty_square" ---
    for thisComponent in empty_square.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for empty_square
    empty_square.tStop = globalClock.getTime(format='float')
    empty_square.tStopRefresh = tThisFlipGlobal
    thisExp.addData('empty_square.stopped', empty_square.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if empty_square.maxDurationReached:
        routineTimer.addTime(-empty_square.maxDuration)
    elif empty_square.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.400000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "test1" ---
    # create an object to store info about Routine test1
    test1 = data.Routine(
        name='test1',
        components=[blacksquare_5, white_cross_5, arrow_l, key_resp_7],
    )
    test1.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_7
    key_resp_7.keys = []
    key_resp_7.rt = []
    _key_resp_7_allKeys = []
    # Run 'Begin Routine' code from code
    
    
    # store start times for test1
    test1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    test1.tStart = globalClock.getTime(format='float')
    test1.status = STARTED
    thisExp.addData('test1.started', test1.tStart)
    test1.maxDuration = None
    # keep track of which components have finished
    test1Components = test1.components
    for thisComponent in test1.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "test1" ---
    test1.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_5* updates
        
        # if blacksquare_5 is starting this frame...
        if blacksquare_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_5.frameNStart = frameN  # exact frame index
            blacksquare_5.tStart = t  # local t and not account for scr refresh
            blacksquare_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_5.started')
            # update status
            blacksquare_5.status = STARTED
            blacksquare_5.setAutoDraw(True)
        
        # if blacksquare_5 is active this frame...
        if blacksquare_5.status == STARTED:
            # update params
            pass
        
        # *white_cross_5* updates
        
        # if white_cross_5 is starting this frame...
        if white_cross_5.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_5.frameNStart = frameN  # exact frame index
            white_cross_5.tStart = t  # local t and not account for scr refresh
            white_cross_5.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_5, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_5.started')
            # update status
            white_cross_5.status = STARTED
            white_cross_5.setAutoDraw(True)
        
        # if white_cross_5 is active this frame...
        if white_cross_5.status == STARTED:
            # update params
            pass
        
        # *arrow_l* updates
        
        # if arrow_l is starting this frame...
        if arrow_l.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            arrow_l.frameNStart = frameN  # exact frame index
            arrow_l.tStart = t  # local t and not account for scr refresh
            arrow_l.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(arrow_l, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'arrow_l.started')
            # update status
            arrow_l.status = STARTED
            arrow_l.setAutoDraw(True)
        
        # if arrow_l is active this frame...
        if arrow_l.status == STARTED:
            # update params
            pass
        
        # *key_resp_7* updates
        waitOnFlip = False
        
        # if key_resp_7 is starting this frame...
        if key_resp_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_7.frameNStart = frameN  # exact frame index
            key_resp_7.tStart = t  # local t and not account for scr refresh
            key_resp_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_7.started')
            # update status
            key_resp_7.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_7.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_7.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_7.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_7.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_7_allKeys.extend(theseKeys)
            if len(_key_resp_7_allKeys):
                key_resp_7.keys = _key_resp_7_allKeys[-1].name  # just the last key pressed
                key_resp_7.rt = _key_resp_7_allKeys[-1].rt
                key_resp_7.duration = _key_resp_7_allKeys[-1].duration
                # was this correct?
                if (key_resp_7.keys == str('left')) or (key_resp_7.keys == 'left'):
                    key_resp_7.corr = 1
                else:
                    key_resp_7.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            test1.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in test1.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "test1" ---
    for thisComponent in test1.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for test1
    test1.tStop = globalClock.getTime(format='float')
    test1.tStopRefresh = tThisFlipGlobal
    thisExp.addData('test1.stopped', test1.tStop)
    # check responses
    if key_resp_7.keys in ['', [], None]:  # No response was made
        key_resp_7.keys = None
        # was no response the correct answer?!
        if str('left').lower() == 'none':
           key_resp_7.corr = 1;  # correct non-response
        else:
           key_resp_7.corr = 0;  # failed to respond (incorrectly)
    # store data for thisExp (ExperimentHandler)
    thisExp.addData('key_resp_7.keys',key_resp_7.keys)
    thisExp.addData('key_resp_7.corr', key_resp_7.corr)
    if key_resp_7.keys != None:  # we had a response
        thisExp.addData('key_resp_7.rt', key_resp_7.rt)
        thisExp.addData('key_resp_7.duration', key_resp_7.duration)
    # Run 'End Routine' code from code
    if key_resp_7.corr:
        feedbackText = "Correct"
    else:
        feedbackText = "Incorrect"
    
    thisExp.nextEntry()
    # the Routine "test1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "feedback" ---
    # create an object to store info about Routine feedback
    feedback = data.Routine(
        name='feedback',
        components=[text_16],
    )
    feedback.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for feedback
    feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    feedback.tStart = globalClock.getTime(format='float')
    feedback.status = STARTED
    thisExp.addData('feedback.started', feedback.tStart)
    feedback.maxDuration = None
    # keep track of which components have finished
    feedbackComponents = feedback.components
    for thisComponent in feedback.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "feedback" ---
    feedback.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 1.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_16* updates
        
        # if text_16 is starting this frame...
        if text_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_16.frameNStart = frameN  # exact frame index
            text_16.tStart = t  # local t and not account for scr refresh
            text_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_16, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_16.started')
            # update status
            text_16.status = STARTED
            text_16.setAutoDraw(True)
        
        # if text_16 is active this frame...
        if text_16.status == STARTED:
            # update params
            text_16.setText(feedbackText
            , log=False)
        
        # if text_16 is stopping this frame...
        if text_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_16.tStartRefresh + 1-frameTolerance:
                # keep track of stop time/frame for later
                text_16.tStop = t  # not accounting for scr refresh
                text_16.tStopRefresh = tThisFlipGlobal  # on global time
                text_16.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_16.stopped')
                # update status
                text_16.status = FINISHED
                text_16.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            feedback.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "feedback" ---
    for thisComponent in feedback.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for feedback
    feedback.tStop = globalClock.getTime(format='float')
    feedback.tStopRefresh = tThisFlipGlobal
    thisExp.addData('feedback.stopped', feedback.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if feedback.maxDurationReached:
        routineTimer.addTime(-feedback.maxDuration)
    elif feedback.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-1.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "empty_square" ---
    # create an object to store info about Routine empty_square
    empty_square = data.Routine(
        name='empty_square',
        components=[blacksquare_3, white_cross_3],
    )
    empty_square.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for empty_square
    empty_square.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    empty_square.tStart = globalClock.getTime(format='float')
    empty_square.status = STARTED
    thisExp.addData('empty_square.started', empty_square.tStart)
    empty_square.maxDuration = None
    # keep track of which components have finished
    empty_squareComponents = empty_square.components
    for thisComponent in empty_square.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "empty_square" ---
    empty_square.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.4:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_3* updates
        
        # if blacksquare_3 is starting this frame...
        if blacksquare_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_3.frameNStart = frameN  # exact frame index
            blacksquare_3.tStart = t  # local t and not account for scr refresh
            blacksquare_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_3.started')
            # update status
            blacksquare_3.status = STARTED
            blacksquare_3.setAutoDraw(True)
        
        # if blacksquare_3 is active this frame...
        if blacksquare_3.status == STARTED:
            # update params
            pass
        
        # if blacksquare_3 is stopping this frame...
        if blacksquare_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_3.tStop = t  # not accounting for scr refresh
                blacksquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_3.stopped')
                # update status
                blacksquare_3.status = FINISHED
                blacksquare_3.setAutoDraw(False)
        
        # *white_cross_3* updates
        
        # if white_cross_3 is starting this frame...
        if white_cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_3.frameNStart = frameN  # exact frame index
            white_cross_3.tStart = t  # local t and not account for scr refresh
            white_cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_3.started')
            # update status
            white_cross_3.status = STARTED
            white_cross_3.setAutoDraw(True)
        
        # if white_cross_3 is active this frame...
        if white_cross_3.status == STARTED:
            # update params
            pass
        
        # if white_cross_3 is stopping this frame...
        if white_cross_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_3.tStop = t  # not accounting for scr refresh
                white_cross_3.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_3.stopped')
                # update status
                white_cross_3.status = FINISHED
                white_cross_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            empty_square.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in empty_square.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "empty_square" ---
    for thisComponent in empty_square.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for empty_square
    empty_square.tStop = globalClock.getTime(format='float')
    empty_square.tStopRefresh = tThisFlipGlobal
    thisExp.addData('empty_square.stopped', empty_square.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if empty_square.maxDurationReached:
        routineTimer.addTime(-empty_square.maxDuration)
    elif empty_square.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.400000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "UD_squares" ---
    # create an object to store info about Routine UD_squares
    UD_squares = data.Routine(
        name='UD_squares',
        components=[blacksquare_6, white_cross_6, up_whitesquare, down_whitesquare],
    )
    UD_squares.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for UD_squares
    UD_squares.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    UD_squares.tStart = globalClock.getTime(format='float')
    UD_squares.status = STARTED
    thisExp.addData('UD_squares.started', UD_squares.tStart)
    UD_squares.maxDuration = None
    # keep track of which components have finished
    UD_squaresComponents = UD_squares.components
    for thisComponent in UD_squares.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "UD_squares" ---
    UD_squares.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.1:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_6* updates
        
        # if blacksquare_6 is starting this frame...
        if blacksquare_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_6.frameNStart = frameN  # exact frame index
            blacksquare_6.tStart = t  # local t and not account for scr refresh
            blacksquare_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_6.started')
            # update status
            blacksquare_6.status = STARTED
            blacksquare_6.setAutoDraw(True)
        
        # if blacksquare_6 is active this frame...
        if blacksquare_6.status == STARTED:
            # update params
            pass
        
        # if blacksquare_6 is stopping this frame...
        if blacksquare_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_6.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_6.tStop = t  # not accounting for scr refresh
                blacksquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_6.stopped')
                # update status
                blacksquare_6.status = FINISHED
                blacksquare_6.setAutoDraw(False)
        
        # *white_cross_6* updates
        
        # if white_cross_6 is starting this frame...
        if white_cross_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_6.frameNStart = frameN  # exact frame index
            white_cross_6.tStart = t  # local t and not account for scr refresh
            white_cross_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_6.started')
            # update status
            white_cross_6.status = STARTED
            white_cross_6.setAutoDraw(True)
        
        # if white_cross_6 is active this frame...
        if white_cross_6.status == STARTED:
            # update params
            pass
        
        # if white_cross_6 is stopping this frame...
        if white_cross_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_6.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_6.tStop = t  # not accounting for scr refresh
                white_cross_6.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_6.stopped')
                # update status
                white_cross_6.status = FINISHED
                white_cross_6.setAutoDraw(False)
        
        # *up_whitesquare* updates
        
        # if up_whitesquare is starting this frame...
        if up_whitesquare.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            up_whitesquare.frameNStart = frameN  # exact frame index
            up_whitesquare.tStart = t  # local t and not account for scr refresh
            up_whitesquare.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(up_whitesquare, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'up_whitesquare.started')
            # update status
            up_whitesquare.status = STARTED
            up_whitesquare.setAutoDraw(True)
        
        # if up_whitesquare is active this frame...
        if up_whitesquare.status == STARTED:
            # update params
            pass
        
        # if up_whitesquare is stopping this frame...
        if up_whitesquare.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > up_whitesquare.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                up_whitesquare.tStop = t  # not accounting for scr refresh
                up_whitesquare.tStopRefresh = tThisFlipGlobal  # on global time
                up_whitesquare.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare.stopped')
                # update status
                up_whitesquare.status = FINISHED
                up_whitesquare.setAutoDraw(False)
        
        # *down_whitesquare* updates
        
        # if down_whitesquare is starting this frame...
        if down_whitesquare.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            down_whitesquare.frameNStart = frameN  # exact frame index
            down_whitesquare.tStart = t  # local t and not account for scr refresh
            down_whitesquare.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(down_whitesquare, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'down_whitesquare.started')
            # update status
            down_whitesquare.status = STARTED
            down_whitesquare.setAutoDraw(True)
        
        # if down_whitesquare is active this frame...
        if down_whitesquare.status == STARTED:
            # update params
            pass
        
        # if down_whitesquare is stopping this frame...
        if down_whitesquare.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > down_whitesquare.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                down_whitesquare.tStop = t  # not accounting for scr refresh
                down_whitesquare.tStopRefresh = tThisFlipGlobal  # on global time
                down_whitesquare.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare.stopped')
                # update status
                down_whitesquare.status = FINISHED
                down_whitesquare.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            UD_squares.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in UD_squares.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "UD_squares" ---
    for thisComponent in UD_squares.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for UD_squares
    UD_squares.tStop = globalClock.getTime(format='float')
    UD_squares.tStopRefresh = tThisFlipGlobal
    thisExp.addData('UD_squares.stopped', UD_squares.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if UD_squares.maxDurationReached:
        routineTimer.addTime(-UD_squares.maxDuration)
    elif UD_squares.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.100000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "empty_square" ---
    # create an object to store info about Routine empty_square
    empty_square = data.Routine(
        name='empty_square',
        components=[blacksquare_3, white_cross_3],
    )
    empty_square.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for empty_square
    empty_square.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    empty_square.tStart = globalClock.getTime(format='float')
    empty_square.status = STARTED
    thisExp.addData('empty_square.started', empty_square.tStart)
    empty_square.maxDuration = None
    # keep track of which components have finished
    empty_squareComponents = empty_square.components
    for thisComponent in empty_square.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "empty_square" ---
    empty_square.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.4:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_3* updates
        
        # if blacksquare_3 is starting this frame...
        if blacksquare_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_3.frameNStart = frameN  # exact frame index
            blacksquare_3.tStart = t  # local t and not account for scr refresh
            blacksquare_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_3.started')
            # update status
            blacksquare_3.status = STARTED
            blacksquare_3.setAutoDraw(True)
        
        # if blacksquare_3 is active this frame...
        if blacksquare_3.status == STARTED:
            # update params
            pass
        
        # if blacksquare_3 is stopping this frame...
        if blacksquare_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_3.tStop = t  # not accounting for scr refresh
                blacksquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_3.stopped')
                # update status
                blacksquare_3.status = FINISHED
                blacksquare_3.setAutoDraw(False)
        
        # *white_cross_3* updates
        
        # if white_cross_3 is starting this frame...
        if white_cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_3.frameNStart = frameN  # exact frame index
            white_cross_3.tStart = t  # local t and not account for scr refresh
            white_cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_3.started')
            # update status
            white_cross_3.status = STARTED
            white_cross_3.setAutoDraw(True)
        
        # if white_cross_3 is active this frame...
        if white_cross_3.status == STARTED:
            # update params
            pass
        
        # if white_cross_3 is stopping this frame...
        if white_cross_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_3.tStop = t  # not accounting for scr refresh
                white_cross_3.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_3.stopped')
                # update status
                white_cross_3.status = FINISHED
                white_cross_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            empty_square.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in empty_square.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "empty_square" ---
    for thisComponent in empty_square.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for empty_square
    empty_square.tStop = globalClock.getTime(format='float')
    empty_square.tStopRefresh = tThisFlipGlobal
    thisExp.addData('empty_square.stopped', empty_square.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if empty_square.maxDurationReached:
        routineTimer.addTime(-empty_square.maxDuration)
    elif empty_square.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.400000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "test2" ---
    # create an object to store info about Routine test2
    test2 = data.Routine(
        name='test2',
        components=[blacksquare_7, white_cross_7, arrow_d, key_resp_8],
    )
    test2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_8
    key_resp_8.keys = []
    key_resp_8.rt = []
    _key_resp_8_allKeys = []
    # Run 'Begin Routine' code from code_2
    
    
    # store start times for test2
    test2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    test2.tStart = globalClock.getTime(format='float')
    test2.status = STARTED
    thisExp.addData('test2.started', test2.tStart)
    test2.maxDuration = None
    # keep track of which components have finished
    test2Components = test2.components
    for thisComponent in test2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "test2" ---
    test2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_7* updates
        
        # if blacksquare_7 is starting this frame...
        if blacksquare_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_7.frameNStart = frameN  # exact frame index
            blacksquare_7.tStart = t  # local t and not account for scr refresh
            blacksquare_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_7.started')
            # update status
            blacksquare_7.status = STARTED
            blacksquare_7.setAutoDraw(True)
        
        # if blacksquare_7 is active this frame...
        if blacksquare_7.status == STARTED:
            # update params
            pass
        
        # *white_cross_7* updates
        
        # if white_cross_7 is starting this frame...
        if white_cross_7.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_7.frameNStart = frameN  # exact frame index
            white_cross_7.tStart = t  # local t and not account for scr refresh
            white_cross_7.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_7, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_7.started')
            # update status
            white_cross_7.status = STARTED
            white_cross_7.setAutoDraw(True)
        
        # if white_cross_7 is active this frame...
        if white_cross_7.status == STARTED:
            # update params
            pass
        
        # *arrow_d* updates
        
        # if arrow_d is starting this frame...
        if arrow_d.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            arrow_d.frameNStart = frameN  # exact frame index
            arrow_d.tStart = t  # local t and not account for scr refresh
            arrow_d.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(arrow_d, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'arrow_d.started')
            # update status
            arrow_d.status = STARTED
            arrow_d.setAutoDraw(True)
        
        # if arrow_d is active this frame...
        if arrow_d.status == STARTED:
            # update params
            pass
        
        # *key_resp_8* updates
        waitOnFlip = False
        
        # if key_resp_8 is starting this frame...
        if key_resp_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_8.frameNStart = frameN  # exact frame index
            key_resp_8.tStart = t  # local t and not account for scr refresh
            key_resp_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_8.started')
            # update status
            key_resp_8.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_8.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_8.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_8.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_8.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_8_allKeys.extend(theseKeys)
            if len(_key_resp_8_allKeys):
                key_resp_8.keys = _key_resp_8_allKeys[-1].name  # just the last key pressed
                key_resp_8.rt = _key_resp_8_allKeys[-1].rt
                key_resp_8.duration = _key_resp_8_allKeys[-1].duration
                # was this correct?
                if (key_resp_8.keys == str('down')) or (key_resp_8.keys == 'down'):
                    key_resp_8.corr = 1
                else:
                    key_resp_8.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            test2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in test2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "test2" ---
    for thisComponent in test2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for test2
    test2.tStop = globalClock.getTime(format='float')
    test2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('test2.stopped', test2.tStop)
    # check responses
    if key_resp_8.keys in ['', [], None]:  # No response was made
        key_resp_8.keys = None
        # was no response the correct answer?!
        if str('down').lower() == 'none':
           key_resp_8.corr = 1;  # correct non-response
        else:
           key_resp_8.corr = 0;  # failed to respond (incorrectly)
    # store data for thisExp (ExperimentHandler)
    thisExp.addData('key_resp_8.keys',key_resp_8.keys)
    thisExp.addData('key_resp_8.corr', key_resp_8.corr)
    if key_resp_8.keys != None:  # we had a response
        thisExp.addData('key_resp_8.rt', key_resp_8.rt)
        thisExp.addData('key_resp_8.duration', key_resp_8.duration)
    # Run 'End Routine' code from code_2
    if key_resp_8.corr:
        feedbackText = "Correct"
    else:
        feedbackText = "Incorrect"
    
    thisExp.nextEntry()
    # the Routine "test2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "feedback" ---
    # create an object to store info about Routine feedback
    feedback = data.Routine(
        name='feedback',
        components=[text_16],
    )
    feedback.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for feedback
    feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    feedback.tStart = globalClock.getTime(format='float')
    feedback.status = STARTED
    thisExp.addData('feedback.started', feedback.tStart)
    feedback.maxDuration = None
    # keep track of which components have finished
    feedbackComponents = feedback.components
    for thisComponent in feedback.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "feedback" ---
    feedback.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 1.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_16* updates
        
        # if text_16 is starting this frame...
        if text_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_16.frameNStart = frameN  # exact frame index
            text_16.tStart = t  # local t and not account for scr refresh
            text_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_16, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_16.started')
            # update status
            text_16.status = STARTED
            text_16.setAutoDraw(True)
        
        # if text_16 is active this frame...
        if text_16.status == STARTED:
            # update params
            text_16.setText(feedbackText
            , log=False)
        
        # if text_16 is stopping this frame...
        if text_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_16.tStartRefresh + 1-frameTolerance:
                # keep track of stop time/frame for later
                text_16.tStop = t  # not accounting for scr refresh
                text_16.tStopRefresh = tThisFlipGlobal  # on global time
                text_16.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_16.stopped')
                # update status
                text_16.status = FINISHED
                text_16.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            feedback.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "feedback" ---
    for thisComponent in feedback.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for feedback
    feedback.tStop = globalClock.getTime(format='float')
    feedback.tStopRefresh = tThisFlipGlobal
    thisExp.addData('feedback.stopped', feedback.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if feedback.maxDurationReached:
        routineTimer.addTime(-feedback.maxDuration)
    elif feedback.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-1.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "empty_square" ---
    # create an object to store info about Routine empty_square
    empty_square = data.Routine(
        name='empty_square',
        components=[blacksquare_3, white_cross_3],
    )
    empty_square.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for empty_square
    empty_square.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    empty_square.tStart = globalClock.getTime(format='float')
    empty_square.status = STARTED
    thisExp.addData('empty_square.started', empty_square.tStart)
    empty_square.maxDuration = None
    # keep track of which components have finished
    empty_squareComponents = empty_square.components
    for thisComponent in empty_square.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "empty_square" ---
    empty_square.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.4:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_3* updates
        
        # if blacksquare_3 is starting this frame...
        if blacksquare_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_3.frameNStart = frameN  # exact frame index
            blacksquare_3.tStart = t  # local t and not account for scr refresh
            blacksquare_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_3.started')
            # update status
            blacksquare_3.status = STARTED
            blacksquare_3.setAutoDraw(True)
        
        # if blacksquare_3 is active this frame...
        if blacksquare_3.status == STARTED:
            # update params
            pass
        
        # if blacksquare_3 is stopping this frame...
        if blacksquare_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_3.tStop = t  # not accounting for scr refresh
                blacksquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_3.stopped')
                # update status
                blacksquare_3.status = FINISHED
                blacksquare_3.setAutoDraw(False)
        
        # *white_cross_3* updates
        
        # if white_cross_3 is starting this frame...
        if white_cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_3.frameNStart = frameN  # exact frame index
            white_cross_3.tStart = t  # local t and not account for scr refresh
            white_cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_3.started')
            # update status
            white_cross_3.status = STARTED
            white_cross_3.setAutoDraw(True)
        
        # if white_cross_3 is active this frame...
        if white_cross_3.status == STARTED:
            # update params
            pass
        
        # if white_cross_3 is stopping this frame...
        if white_cross_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_3.tStop = t  # not accounting for scr refresh
                white_cross_3.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_3.stopped')
                # update status
                white_cross_3.status = FINISHED
                white_cross_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            empty_square.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in empty_square.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "empty_square" ---
    for thisComponent in empty_square.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for empty_square
    empty_square.tStop = globalClock.getTime(format='float')
    empty_square.tStopRefresh = tThisFlipGlobal
    thisExp.addData('empty_square.stopped', empty_square.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if empty_square.maxDurationReached:
        routineTimer.addTime(-empty_square.maxDuration)
    elif empty_square.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.400000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "UD_squares" ---
    # create an object to store info about Routine UD_squares
    UD_squares = data.Routine(
        name='UD_squares',
        components=[blacksquare_6, white_cross_6, up_whitesquare, down_whitesquare],
    )
    UD_squares.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for UD_squares
    UD_squares.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    UD_squares.tStart = globalClock.getTime(format='float')
    UD_squares.status = STARTED
    thisExp.addData('UD_squares.started', UD_squares.tStart)
    UD_squares.maxDuration = None
    # keep track of which components have finished
    UD_squaresComponents = UD_squares.components
    for thisComponent in UD_squares.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "UD_squares" ---
    UD_squares.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.1:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_6* updates
        
        # if blacksquare_6 is starting this frame...
        if blacksquare_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_6.frameNStart = frameN  # exact frame index
            blacksquare_6.tStart = t  # local t and not account for scr refresh
            blacksquare_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_6.started')
            # update status
            blacksquare_6.status = STARTED
            blacksquare_6.setAutoDraw(True)
        
        # if blacksquare_6 is active this frame...
        if blacksquare_6.status == STARTED:
            # update params
            pass
        
        # if blacksquare_6 is stopping this frame...
        if blacksquare_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_6.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_6.tStop = t  # not accounting for scr refresh
                blacksquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_6.stopped')
                # update status
                blacksquare_6.status = FINISHED
                blacksquare_6.setAutoDraw(False)
        
        # *white_cross_6* updates
        
        # if white_cross_6 is starting this frame...
        if white_cross_6.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_6.frameNStart = frameN  # exact frame index
            white_cross_6.tStart = t  # local t and not account for scr refresh
            white_cross_6.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_6, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_6.started')
            # update status
            white_cross_6.status = STARTED
            white_cross_6.setAutoDraw(True)
        
        # if white_cross_6 is active this frame...
        if white_cross_6.status == STARTED:
            # update params
            pass
        
        # if white_cross_6 is stopping this frame...
        if white_cross_6.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_6.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_6.tStop = t  # not accounting for scr refresh
                white_cross_6.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_6.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_6.stopped')
                # update status
                white_cross_6.status = FINISHED
                white_cross_6.setAutoDraw(False)
        
        # *up_whitesquare* updates
        
        # if up_whitesquare is starting this frame...
        if up_whitesquare.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            up_whitesquare.frameNStart = frameN  # exact frame index
            up_whitesquare.tStart = t  # local t and not account for scr refresh
            up_whitesquare.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(up_whitesquare, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'up_whitesquare.started')
            # update status
            up_whitesquare.status = STARTED
            up_whitesquare.setAutoDraw(True)
        
        # if up_whitesquare is active this frame...
        if up_whitesquare.status == STARTED:
            # update params
            pass
        
        # if up_whitesquare is stopping this frame...
        if up_whitesquare.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > up_whitesquare.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                up_whitesquare.tStop = t  # not accounting for scr refresh
                up_whitesquare.tStopRefresh = tThisFlipGlobal  # on global time
                up_whitesquare.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare.stopped')
                # update status
                up_whitesquare.status = FINISHED
                up_whitesquare.setAutoDraw(False)
        
        # *down_whitesquare* updates
        
        # if down_whitesquare is starting this frame...
        if down_whitesquare.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            down_whitesquare.frameNStart = frameN  # exact frame index
            down_whitesquare.tStart = t  # local t and not account for scr refresh
            down_whitesquare.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(down_whitesquare, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'down_whitesquare.started')
            # update status
            down_whitesquare.status = STARTED
            down_whitesquare.setAutoDraw(True)
        
        # if down_whitesquare is active this frame...
        if down_whitesquare.status == STARTED:
            # update params
            pass
        
        # if down_whitesquare is stopping this frame...
        if down_whitesquare.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > down_whitesquare.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                down_whitesquare.tStop = t  # not accounting for scr refresh
                down_whitesquare.tStopRefresh = tThisFlipGlobal  # on global time
                down_whitesquare.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare.stopped')
                # update status
                down_whitesquare.status = FINISHED
                down_whitesquare.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            UD_squares.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in UD_squares.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "UD_squares" ---
    for thisComponent in UD_squares.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for UD_squares
    UD_squares.tStop = globalClock.getTime(format='float')
    UD_squares.tStopRefresh = tThisFlipGlobal
    thisExp.addData('UD_squares.stopped', UD_squares.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if UD_squares.maxDurationReached:
        routineTimer.addTime(-UD_squares.maxDuration)
    elif UD_squares.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.100000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "empty_square" ---
    # create an object to store info about Routine empty_square
    empty_square = data.Routine(
        name='empty_square',
        components=[blacksquare_3, white_cross_3],
    )
    empty_square.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for empty_square
    empty_square.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    empty_square.tStart = globalClock.getTime(format='float')
    empty_square.status = STARTED
    thisExp.addData('empty_square.started', empty_square.tStart)
    empty_square.maxDuration = None
    # keep track of which components have finished
    empty_squareComponents = empty_square.components
    for thisComponent in empty_square.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "empty_square" ---
    empty_square.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.4:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_3* updates
        
        # if blacksquare_3 is starting this frame...
        if blacksquare_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_3.frameNStart = frameN  # exact frame index
            blacksquare_3.tStart = t  # local t and not account for scr refresh
            blacksquare_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_3.started')
            # update status
            blacksquare_3.status = STARTED
            blacksquare_3.setAutoDraw(True)
        
        # if blacksquare_3 is active this frame...
        if blacksquare_3.status == STARTED:
            # update params
            pass
        
        # if blacksquare_3 is stopping this frame...
        if blacksquare_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_3.tStop = t  # not accounting for scr refresh
                blacksquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_3.stopped')
                # update status
                blacksquare_3.status = FINISHED
                blacksquare_3.setAutoDraw(False)
        
        # *white_cross_3* updates
        
        # if white_cross_3 is starting this frame...
        if white_cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_3.frameNStart = frameN  # exact frame index
            white_cross_3.tStart = t  # local t and not account for scr refresh
            white_cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_3.started')
            # update status
            white_cross_3.status = STARTED
            white_cross_3.setAutoDraw(True)
        
        # if white_cross_3 is active this frame...
        if white_cross_3.status == STARTED:
            # update params
            pass
        
        # if white_cross_3 is stopping this frame...
        if white_cross_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_3.tStop = t  # not accounting for scr refresh
                white_cross_3.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_3.stopped')
                # update status
                white_cross_3.status = FINISHED
                white_cross_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            empty_square.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in empty_square.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "empty_square" ---
    for thisComponent in empty_square.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for empty_square
    empty_square.tStop = globalClock.getTime(format='float')
    empty_square.tStopRefresh = tThisFlipGlobal
    thisExp.addData('empty_square.stopped', empty_square.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if empty_square.maxDurationReached:
        routineTimer.addTime(-empty_square.maxDuration)
    elif empty_square.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.400000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "test3" ---
    # create an object to store info about Routine test3
    test3 = data.Routine(
        name='test3',
        components=[blacksquare_8, white_cross_8, key_resp_9, DOWN],
    )
    test3.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_9
    key_resp_9.keys = []
    key_resp_9.rt = []
    _key_resp_9_allKeys = []
    # Run 'Begin Routine' code from code_3
    
    
    # store start times for test3
    test3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    test3.tStart = globalClock.getTime(format='float')
    test3.status = STARTED
    thisExp.addData('test3.started', test3.tStart)
    test3.maxDuration = None
    # keep track of which components have finished
    test3Components = test3.components
    for thisComponent in test3.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "test3" ---
    test3.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_8* updates
        
        # if blacksquare_8 is starting this frame...
        if blacksquare_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_8.frameNStart = frameN  # exact frame index
            blacksquare_8.tStart = t  # local t and not account for scr refresh
            blacksquare_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_8.started')
            # update status
            blacksquare_8.status = STARTED
            blacksquare_8.setAutoDraw(True)
        
        # if blacksquare_8 is active this frame...
        if blacksquare_8.status == STARTED:
            # update params
            pass
        
        # *white_cross_8* updates
        
        # if white_cross_8 is starting this frame...
        if white_cross_8.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_8.frameNStart = frameN  # exact frame index
            white_cross_8.tStart = t  # local t and not account for scr refresh
            white_cross_8.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_8, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_8.started')
            # update status
            white_cross_8.status = STARTED
            white_cross_8.setAutoDraw(True)
        
        # if white_cross_8 is active this frame...
        if white_cross_8.status == STARTED:
            # update params
            pass
        
        # *key_resp_9* updates
        waitOnFlip = False
        
        # if key_resp_9 is starting this frame...
        if key_resp_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_9.frameNStart = frameN  # exact frame index
            key_resp_9.tStart = t  # local t and not account for scr refresh
            key_resp_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_9.started')
            # update status
            key_resp_9.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_9.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_9.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_9.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_9.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_9_allKeys.extend(theseKeys)
            if len(_key_resp_9_allKeys):
                key_resp_9.keys = _key_resp_9_allKeys[-1].name  # just the last key pressed
                key_resp_9.rt = _key_resp_9_allKeys[-1].rt
                key_resp_9.duration = _key_resp_9_allKeys[-1].duration
                # was this correct?
                if (key_resp_9.keys == str('down')) or (key_resp_9.keys == 'down'):
                    key_resp_9.corr = 1
                else:
                    key_resp_9.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *DOWN* updates
        
        # if DOWN is starting this frame...
        if DOWN.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            DOWN.frameNStart = frameN  # exact frame index
            DOWN.tStart = t  # local t and not account for scr refresh
            DOWN.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(DOWN, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'DOWN.started')
            # update status
            DOWN.status = STARTED
            DOWN.setAutoDraw(True)
        
        # if DOWN is active this frame...
        if DOWN.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            test3.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in test3.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "test3" ---
    for thisComponent in test3.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for test3
    test3.tStop = globalClock.getTime(format='float')
    test3.tStopRefresh = tThisFlipGlobal
    thisExp.addData('test3.stopped', test3.tStop)
    # check responses
    if key_resp_9.keys in ['', [], None]:  # No response was made
        key_resp_9.keys = None
        # was no response the correct answer?!
        if str('down').lower() == 'none':
           key_resp_9.corr = 1;  # correct non-response
        else:
           key_resp_9.corr = 0;  # failed to respond (incorrectly)
    # store data for thisExp (ExperimentHandler)
    thisExp.addData('key_resp_9.keys',key_resp_9.keys)
    thisExp.addData('key_resp_9.corr', key_resp_9.corr)
    if key_resp_9.keys != None:  # we had a response
        thisExp.addData('key_resp_9.rt', key_resp_9.rt)
        thisExp.addData('key_resp_9.duration', key_resp_9.duration)
    # Run 'End Routine' code from code_3
    if key_resp_9.corr:
        feedbackText = "Correct"
    else:
        feedbackText = "Incorrect"
    
    thisExp.nextEntry()
    # the Routine "test3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "feedback" ---
    # create an object to store info about Routine feedback
    feedback = data.Routine(
        name='feedback',
        components=[text_16],
    )
    feedback.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for feedback
    feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    feedback.tStart = globalClock.getTime(format='float')
    feedback.status = STARTED
    thisExp.addData('feedback.started', feedback.tStart)
    feedback.maxDuration = None
    # keep track of which components have finished
    feedbackComponents = feedback.components
    for thisComponent in feedback.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "feedback" ---
    feedback.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 1.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_16* updates
        
        # if text_16 is starting this frame...
        if text_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_16.frameNStart = frameN  # exact frame index
            text_16.tStart = t  # local t and not account for scr refresh
            text_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_16, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_16.started')
            # update status
            text_16.status = STARTED
            text_16.setAutoDraw(True)
        
        # if text_16 is active this frame...
        if text_16.status == STARTED:
            # update params
            text_16.setText(feedbackText
            , log=False)
        
        # if text_16 is stopping this frame...
        if text_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_16.tStartRefresh + 1-frameTolerance:
                # keep track of stop time/frame for later
                text_16.tStop = t  # not accounting for scr refresh
                text_16.tStopRefresh = tThisFlipGlobal  # on global time
                text_16.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_16.stopped')
                # update status
                text_16.status = FINISHED
                text_16.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            feedback.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "feedback" ---
    for thisComponent in feedback.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for feedback
    feedback.tStop = globalClock.getTime(format='float')
    feedback.tStopRefresh = tThisFlipGlobal
    thisExp.addData('feedback.stopped', feedback.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if feedback.maxDurationReached:
        routineTimer.addTime(-feedback.maxDuration)
    elif feedback.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-1.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "empty_square" ---
    # create an object to store info about Routine empty_square
    empty_square = data.Routine(
        name='empty_square',
        components=[blacksquare_3, white_cross_3],
    )
    empty_square.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for empty_square
    empty_square.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    empty_square.tStart = globalClock.getTime(format='float')
    empty_square.status = STARTED
    thisExp.addData('empty_square.started', empty_square.tStart)
    empty_square.maxDuration = None
    # keep track of which components have finished
    empty_squareComponents = empty_square.components
    for thisComponent in empty_square.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "empty_square" ---
    empty_square.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.4:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_3* updates
        
        # if blacksquare_3 is starting this frame...
        if blacksquare_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_3.frameNStart = frameN  # exact frame index
            blacksquare_3.tStart = t  # local t and not account for scr refresh
            blacksquare_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_3.started')
            # update status
            blacksquare_3.status = STARTED
            blacksquare_3.setAutoDraw(True)
        
        # if blacksquare_3 is active this frame...
        if blacksquare_3.status == STARTED:
            # update params
            pass
        
        # if blacksquare_3 is stopping this frame...
        if blacksquare_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_3.tStop = t  # not accounting for scr refresh
                blacksquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_3.stopped')
                # update status
                blacksquare_3.status = FINISHED
                blacksquare_3.setAutoDraw(False)
        
        # *white_cross_3* updates
        
        # if white_cross_3 is starting this frame...
        if white_cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_3.frameNStart = frameN  # exact frame index
            white_cross_3.tStart = t  # local t and not account for scr refresh
            white_cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_3.started')
            # update status
            white_cross_3.status = STARTED
            white_cross_3.setAutoDraw(True)
        
        # if white_cross_3 is active this frame...
        if white_cross_3.status == STARTED:
            # update params
            pass
        
        # if white_cross_3 is stopping this frame...
        if white_cross_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_3.tStop = t  # not accounting for scr refresh
                white_cross_3.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_3.stopped')
                # update status
                white_cross_3.status = FINISHED
                white_cross_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            empty_square.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in empty_square.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "empty_square" ---
    for thisComponent in empty_square.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for empty_square
    empty_square.tStop = globalClock.getTime(format='float')
    empty_square.tStopRefresh = tThisFlipGlobal
    thisExp.addData('empty_square.stopped', empty_square.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if empty_square.maxDurationReached:
        routineTimer.addTime(-empty_square.maxDuration)
    elif empty_square.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.400000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "LR_squares" ---
    # create an object to store info about Routine LR_squares
    LR_squares = data.Routine(
        name='LR_squares',
        components=[blacksquare_4, white_cross_4, whitesquare, whitesquare_2],
    )
    LR_squares.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for LR_squares
    LR_squares.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    LR_squares.tStart = globalClock.getTime(format='float')
    LR_squares.status = STARTED
    thisExp.addData('LR_squares.started', LR_squares.tStart)
    LR_squares.maxDuration = None
    # keep track of which components have finished
    LR_squaresComponents = LR_squares.components
    for thisComponent in LR_squares.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "LR_squares" ---
    LR_squares.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.1:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_4* updates
        
        # if blacksquare_4 is starting this frame...
        if blacksquare_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_4.frameNStart = frameN  # exact frame index
            blacksquare_4.tStart = t  # local t and not account for scr refresh
            blacksquare_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_4.started')
            # update status
            blacksquare_4.status = STARTED
            blacksquare_4.setAutoDraw(True)
        
        # if blacksquare_4 is active this frame...
        if blacksquare_4.status == STARTED:
            # update params
            pass
        
        # if blacksquare_4 is stopping this frame...
        if blacksquare_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_4.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_4.tStop = t  # not accounting for scr refresh
                blacksquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_4.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_4.stopped')
                # update status
                blacksquare_4.status = FINISHED
                blacksquare_4.setAutoDraw(False)
        
        # *white_cross_4* updates
        
        # if white_cross_4 is starting this frame...
        if white_cross_4.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_4.frameNStart = frameN  # exact frame index
            white_cross_4.tStart = t  # local t and not account for scr refresh
            white_cross_4.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_4, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_4.started')
            # update status
            white_cross_4.status = STARTED
            white_cross_4.setAutoDraw(True)
        
        # if white_cross_4 is active this frame...
        if white_cross_4.status == STARTED:
            # update params
            pass
        
        # if white_cross_4 is stopping this frame...
        if white_cross_4.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_4.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_4.tStop = t  # not accounting for scr refresh
                white_cross_4.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_4.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_4.stopped')
                # update status
                white_cross_4.status = FINISHED
                white_cross_4.setAutoDraw(False)
        
        # *whitesquare* updates
        
        # if whitesquare is starting this frame...
        if whitesquare.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            whitesquare.frameNStart = frameN  # exact frame index
            whitesquare.tStart = t  # local t and not account for scr refresh
            whitesquare.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(whitesquare, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'whitesquare.started')
            # update status
            whitesquare.status = STARTED
            whitesquare.setAutoDraw(True)
        
        # if whitesquare is active this frame...
        if whitesquare.status == STARTED:
            # update params
            pass
        
        # if whitesquare is stopping this frame...
        if whitesquare.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > whitesquare.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                whitesquare.tStop = t  # not accounting for scr refresh
                whitesquare.tStopRefresh = tThisFlipGlobal  # on global time
                whitesquare.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare.stopped')
                # update status
                whitesquare.status = FINISHED
                whitesquare.setAutoDraw(False)
        
        # *whitesquare_2* updates
        
        # if whitesquare_2 is starting this frame...
        if whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            whitesquare_2.frameNStart = frameN  # exact frame index
            whitesquare_2.tStart = t  # local t and not account for scr refresh
            whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(whitesquare_2, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'whitesquare_2.started')
            # update status
            whitesquare_2.status = STARTED
            whitesquare_2.setAutoDraw(True)
        
        # if whitesquare_2 is active this frame...
        if whitesquare_2.status == STARTED:
            # update params
            pass
        
        # if whitesquare_2 is stopping this frame...
        if whitesquare_2.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                # keep track of stop time/frame for later
                whitesquare_2.tStop = t  # not accounting for scr refresh
                whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                whitesquare_2.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_2.stopped')
                # update status
                whitesquare_2.status = FINISHED
                whitesquare_2.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            LR_squares.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in LR_squares.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "LR_squares" ---
    for thisComponent in LR_squares.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for LR_squares
    LR_squares.tStop = globalClock.getTime(format='float')
    LR_squares.tStopRefresh = tThisFlipGlobal
    thisExp.addData('LR_squares.stopped', LR_squares.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if LR_squares.maxDurationReached:
        routineTimer.addTime(-LR_squares.maxDuration)
    elif LR_squares.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.100000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "empty_square" ---
    # create an object to store info about Routine empty_square
    empty_square = data.Routine(
        name='empty_square',
        components=[blacksquare_3, white_cross_3],
    )
    empty_square.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for empty_square
    empty_square.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    empty_square.tStart = globalClock.getTime(format='float')
    empty_square.status = STARTED
    thisExp.addData('empty_square.started', empty_square.tStart)
    empty_square.maxDuration = None
    # keep track of which components have finished
    empty_squareComponents = empty_square.components
    for thisComponent in empty_square.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "empty_square" ---
    empty_square.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 0.4:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_3* updates
        
        # if blacksquare_3 is starting this frame...
        if blacksquare_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_3.frameNStart = frameN  # exact frame index
            blacksquare_3.tStart = t  # local t and not account for scr refresh
            blacksquare_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_3.started')
            # update status
            blacksquare_3.status = STARTED
            blacksquare_3.setAutoDraw(True)
        
        # if blacksquare_3 is active this frame...
        if blacksquare_3.status == STARTED:
            # update params
            pass
        
        # if blacksquare_3 is stopping this frame...
        if blacksquare_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > blacksquare_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                blacksquare_3.tStop = t  # not accounting for scr refresh
                blacksquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                blacksquare_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_3.stopped')
                # update status
                blacksquare_3.status = FINISHED
                blacksquare_3.setAutoDraw(False)
        
        # *white_cross_3* updates
        
        # if white_cross_3 is starting this frame...
        if white_cross_3.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_3.frameNStart = frameN  # exact frame index
            white_cross_3.tStart = t  # local t and not account for scr refresh
            white_cross_3.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_3, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_3.started')
            # update status
            white_cross_3.status = STARTED
            white_cross_3.setAutoDraw(True)
        
        # if white_cross_3 is active this frame...
        if white_cross_3.status == STARTED:
            # update params
            pass
        
        # if white_cross_3 is stopping this frame...
        if white_cross_3.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > white_cross_3.tStartRefresh + 0.4-frameTolerance:
                # keep track of stop time/frame for later
                white_cross_3.tStop = t  # not accounting for scr refresh
                white_cross_3.tStopRefresh = tThisFlipGlobal  # on global time
                white_cross_3.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_3.stopped')
                # update status
                white_cross_3.status = FINISHED
                white_cross_3.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            empty_square.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in empty_square.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "empty_square" ---
    for thisComponent in empty_square.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for empty_square
    empty_square.tStop = globalClock.getTime(format='float')
    empty_square.tStopRefresh = tThisFlipGlobal
    thisExp.addData('empty_square.stopped', empty_square.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if empty_square.maxDurationReached:
        routineTimer.addTime(-empty_square.maxDuration)
    elif empty_square.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-0.400000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "test4" ---
    # create an object to store info about Routine test4
    test4 = data.Routine(
        name='test4',
        components=[blacksquare_9, white_cross_9, key_resp_10, LEFT],
    )
    test4.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_10
    key_resp_10.keys = []
    key_resp_10.rt = []
    _key_resp_10_allKeys = []
    # Run 'Begin Routine' code from code_4
    
    
    # store start times for test4
    test4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    test4.tStart = globalClock.getTime(format='float')
    test4.status = STARTED
    thisExp.addData('test4.started', test4.tStart)
    test4.maxDuration = None
    # keep track of which components have finished
    test4Components = test4.components
    for thisComponent in test4.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "test4" ---
    test4.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *blacksquare_9* updates
        
        # if blacksquare_9 is starting this frame...
        if blacksquare_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            blacksquare_9.frameNStart = frameN  # exact frame index
            blacksquare_9.tStart = t  # local t and not account for scr refresh
            blacksquare_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(blacksquare_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'blacksquare_9.started')
            # update status
            blacksquare_9.status = STARTED
            blacksquare_9.setAutoDraw(True)
        
        # if blacksquare_9 is active this frame...
        if blacksquare_9.status == STARTED:
            # update params
            pass
        
        # *white_cross_9* updates
        
        # if white_cross_9 is starting this frame...
        if white_cross_9.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            white_cross_9.frameNStart = frameN  # exact frame index
            white_cross_9.tStart = t  # local t and not account for scr refresh
            white_cross_9.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(white_cross_9, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'white_cross_9.started')
            # update status
            white_cross_9.status = STARTED
            white_cross_9.setAutoDraw(True)
        
        # if white_cross_9 is active this frame...
        if white_cross_9.status == STARTED:
            # update params
            pass
        
        # *key_resp_10* updates
        waitOnFlip = False
        
        # if key_resp_10 is starting this frame...
        if key_resp_10.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_10.frameNStart = frameN  # exact frame index
            key_resp_10.tStart = t  # local t and not account for scr refresh
            key_resp_10.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_10, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_10.started')
            # update status
            key_resp_10.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_10.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_10.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_10.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_10.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_10_allKeys.extend(theseKeys)
            if len(_key_resp_10_allKeys):
                key_resp_10.keys = _key_resp_10_allKeys[-1].name  # just the last key pressed
                key_resp_10.rt = _key_resp_10_allKeys[-1].rt
                key_resp_10.duration = _key_resp_10_allKeys[-1].duration
                # was this correct?
                if (key_resp_10.keys == str('left')) or (key_resp_10.keys == 'left'):
                    key_resp_10.corr = 1
                else:
                    key_resp_10.corr = 0
                # a response ends the routine
                continueRoutine = False
        
        # *LEFT* updates
        
        # if LEFT is starting this frame...
        if LEFT.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            LEFT.frameNStart = frameN  # exact frame index
            LEFT.tStart = t  # local t and not account for scr refresh
            LEFT.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(LEFT, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'LEFT.started')
            # update status
            LEFT.status = STARTED
            LEFT.setAutoDraw(True)
        
        # if LEFT is active this frame...
        if LEFT.status == STARTED:
            # update params
            pass
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            test4.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in test4.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "test4" ---
    for thisComponent in test4.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for test4
    test4.tStop = globalClock.getTime(format='float')
    test4.tStopRefresh = tThisFlipGlobal
    thisExp.addData('test4.stopped', test4.tStop)
    # check responses
    if key_resp_10.keys in ['', [], None]:  # No response was made
        key_resp_10.keys = None
        # was no response the correct answer?!
        if str('left').lower() == 'none':
           key_resp_10.corr = 1;  # correct non-response
        else:
           key_resp_10.corr = 0;  # failed to respond (incorrectly)
    # store data for thisExp (ExperimentHandler)
    thisExp.addData('key_resp_10.keys',key_resp_10.keys)
    thisExp.addData('key_resp_10.corr', key_resp_10.corr)
    if key_resp_10.keys != None:  # we had a response
        thisExp.addData('key_resp_10.rt', key_resp_10.rt)
        thisExp.addData('key_resp_10.duration', key_resp_10.duration)
    # Run 'End Routine' code from code_4
    if key_resp_10.corr:
        feedbackText = "Correct"
    else:
        feedbackText = "Incorrect"
    
    thisExp.nextEntry()
    # the Routine "test4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "feedback" ---
    # create an object to store info about Routine feedback
    feedback = data.Routine(
        name='feedback',
        components=[text_16],
    )
    feedback.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for feedback
    feedback.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    feedback.tStart = globalClock.getTime(format='float')
    feedback.status = STARTED
    thisExp.addData('feedback.started', feedback.tStart)
    feedback.maxDuration = None
    # keep track of which components have finished
    feedbackComponents = feedback.components
    for thisComponent in feedback.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "feedback" ---
    feedback.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 1.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_16* updates
        
        # if text_16 is starting this frame...
        if text_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_16.frameNStart = frameN  # exact frame index
            text_16.tStart = t  # local t and not account for scr refresh
            text_16.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_16, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_16.started')
            # update status
            text_16.status = STARTED
            text_16.setAutoDraw(True)
        
        # if text_16 is active this frame...
        if text_16.status == STARTED:
            # update params
            text_16.setText(feedbackText
            , log=False)
        
        # if text_16 is stopping this frame...
        if text_16.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_16.tStartRefresh + 1-frameTolerance:
                # keep track of stop time/frame for later
                text_16.tStop = t  # not accounting for scr refresh
                text_16.tStopRefresh = tThisFlipGlobal  # on global time
                text_16.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_16.stopped')
                # update status
                text_16.status = FINISHED
                text_16.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            feedback.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in feedback.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "feedback" ---
    for thisComponent in feedback.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for feedback
    feedback.tStop = globalClock.getTime(format='float')
    feedback.tStopRefresh = tThisFlipGlobal
    thisExp.addData('feedback.stopped', feedback.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if feedback.maxDurationReached:
        routineTimer.addTime(-feedback.maxDuration)
    elif feedback.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-1.000000)
    thisExp.nextEntry()
    
    # --- Prepare to start Routine "instr5" ---
    # create an object to store info about Routine instr5
    instr5 = data.Routine(
        name='instr5',
        components=[text_17, text_18, key_resp_11],
    )
    instr5.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_11
    key_resp_11.keys = []
    key_resp_11.rt = []
    _key_resp_11_allKeys = []
    # store start times for instr5
    instr5.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instr5.tStart = globalClock.getTime(format='float')
    instr5.status = STARTED
    thisExp.addData('instr5.started', instr5.tStart)
    instr5.maxDuration = None
    # keep track of which components have finished
    instr5Components = instr5.components
    for thisComponent in instr5.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instr5" ---
    instr5.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_17* updates
        
        # if text_17 is starting this frame...
        if text_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_17.frameNStart = frameN  # exact frame index
            text_17.tStart = t  # local t and not account for scr refresh
            text_17.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_17, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_17.started')
            # update status
            text_17.status = STARTED
            text_17.setAutoDraw(True)
        
        # if text_17 is active this frame...
        if text_17.status == STARTED:
            # update params
            pass
        
        # *text_18* updates
        
        # if text_18 is starting this frame...
        if text_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_18.frameNStart = frameN  # exact frame index
            text_18.tStart = t  # local t and not account for scr refresh
            text_18.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_18, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_18.started')
            # update status
            text_18.status = STARTED
            text_18.setAutoDraw(True)
        
        # if text_18 is active this frame...
        if text_18.status == STARTED:
            # update params
            pass
        
        # *key_resp_11* updates
        waitOnFlip = False
        
        # if key_resp_11 is starting this frame...
        if key_resp_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_11.frameNStart = frameN  # exact frame index
            key_resp_11.tStart = t  # local t and not account for scr refresh
            key_resp_11.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_11, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_11.started')
            # update status
            key_resp_11.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_11.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_11.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_11.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_11.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_11_allKeys.extend(theseKeys)
            if len(_key_resp_11_allKeys):
                key_resp_11.keys = _key_resp_11_allKeys[-1].name  # just the last key pressed
                key_resp_11.rt = _key_resp_11_allKeys[-1].rt
                key_resp_11.duration = _key_resp_11_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instr5.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instr5.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instr5" ---
    for thisComponent in instr5.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instr5
    instr5.tStop = globalClock.getTime(format='float')
    instr5.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instr5.stopped', instr5.tStop)
    # check responses
    if key_resp_11.keys in ['', [], None]:  # No response was made
        key_resp_11.keys = None
    thisExp.addData('key_resp_11.keys',key_resp_11.keys)
    if key_resp_11.keys != None:  # we had a response
        thisExp.addData('key_resp_11.rt', key_resp_11.rt)
        thisExp.addData('key_resp_11.duration', key_resp_11.duration)
    thisExp.nextEntry()
    # the Routine "instr5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "instr6" ---
    # create an object to store info about Routine instr6
    instr6 = data.Routine(
        name='instr6',
        components=[text_19, text_20, key_resp_12],
    )
    instr6.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_12
    key_resp_12.keys = []
    key_resp_12.rt = []
    _key_resp_12_allKeys = []
    # store start times for instr6
    instr6.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    instr6.tStart = globalClock.getTime(format='float')
    instr6.status = STARTED
    thisExp.addData('instr6.started', instr6.tStart)
    instr6.maxDuration = None
    # keep track of which components have finished
    instr6Components = instr6.components
    for thisComponent in instr6.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "instr6" ---
    instr6.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_19* updates
        
        # if text_19 is starting this frame...
        if text_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_19.frameNStart = frameN  # exact frame index
            text_19.tStart = t  # local t and not account for scr refresh
            text_19.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_19, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_19.started')
            # update status
            text_19.status = STARTED
            text_19.setAutoDraw(True)
        
        # if text_19 is active this frame...
        if text_19.status == STARTED:
            # update params
            pass
        
        # *text_20* updates
        
        # if text_20 is starting this frame...
        if text_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_20.frameNStart = frameN  # exact frame index
            text_20.tStart = t  # local t and not account for scr refresh
            text_20.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_20, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_20.started')
            # update status
            text_20.status = STARTED
            text_20.setAutoDraw(True)
        
        # if text_20 is active this frame...
        if text_20.status == STARTED:
            # update params
            pass
        
        # *key_resp_12* updates
        waitOnFlip = False
        
        # if key_resp_12 is starting this frame...
        if key_resp_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_12.frameNStart = frameN  # exact frame index
            key_resp_12.tStart = t  # local t and not account for scr refresh
            key_resp_12.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_12, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_12.started')
            # update status
            key_resp_12.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_12.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_12.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_12.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_12.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_12_allKeys.extend(theseKeys)
            if len(_key_resp_12_allKeys):
                key_resp_12.keys = _key_resp_12_allKeys[-1].name  # just the last key pressed
                key_resp_12.rt = _key_resp_12_allKeys[-1].rt
                key_resp_12.duration = _key_resp_12_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            instr6.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in instr6.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "instr6" ---
    for thisComponent in instr6.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for instr6
    instr6.tStop = globalClock.getTime(format='float')
    instr6.tStopRefresh = tThisFlipGlobal
    thisExp.addData('instr6.stopped', instr6.tStop)
    # check responses
    if key_resp_12.keys in ['', [], None]:  # No response was made
        key_resp_12.keys = None
    thisExp.addData('key_resp_12.keys',key_resp_12.keys)
    if key_resp_12.keys != None:  # we had a response
        thisExp.addData('key_resp_12.rt', key_resp_12.rt)
        thisExp.addData('key_resp_12.duration', key_resp_12.duration)
    thisExp.nextEntry()
    # the Routine "instr6" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "block1" ---
    # create an object to store info about Routine block1
    block1 = data.Routine(
        name='block1',
        components=[text_21],
    )
    block1.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for block1
    block1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    block1.tStart = globalClock.getTime(format='float')
    block1.status = STARTED
    thisExp.addData('block1.started', block1.tStart)
    block1.maxDuration = None
    # keep track of which components have finished
    block1Components = block1.components
    for thisComponent in block1.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "block1" ---
    block1.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 2.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_21* updates
        
        # if text_21 is starting this frame...
        if text_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_21.frameNStart = frameN  # exact frame index
            text_21.tStart = t  # local t and not account for scr refresh
            text_21.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_21, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_21.started')
            # update status
            text_21.status = STARTED
            text_21.setAutoDraw(True)
        
        # if text_21 is active this frame...
        if text_21.status == STARTED:
            # update params
            pass
        
        # if text_21 is stopping this frame...
        if text_21.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_21.tStartRefresh + 2-frameTolerance:
                # keep track of stop time/frame for later
                text_21.tStop = t  # not accounting for scr refresh
                text_21.tStopRefresh = tThisFlipGlobal  # on global time
                text_21.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_21.stopped')
                # update status
                text_21.status = FINISHED
                text_21.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            block1.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in block1.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "block1" ---
    for thisComponent in block1.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for block1
    block1.tStop = globalClock.getTime(format='float')
    block1.tStopRefresh = tThisFlipGlobal
    thisExp.addData('block1.stopped', block1.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if block1.maxDurationReached:
        routineTimer.addTime(-block1.maxDuration)
    elif block1.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-2.000000)
    thisExp.nextEntry()
    
    # set up handler to look after randomisation of conditions etc
    trials_b1 = data.TrialHandler2(
        name='trials_b1',
        nReps=32.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(trials_b1)  # add the loop to the experiment
    thisTrials_b1 = trials_b1.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_b1.rgb)
    if thisTrials_b1 != None:
        for paramName in thisTrials_b1:
            globals()[paramName] = thisTrials_b1[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_b1 in trials_b1:
        currentLoop = trials_b1
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_b1.rgb)
        if thisTrials_b1 != None:
            for paramName in thisTrials_b1:
                globals()[paramName] = thisTrials_b1[paramName]
        
        # --- Prepare to start Routine "block1_router" ---
        # create an object to store info about Routine block1_router
        block1_router = data.Routine(
            name='block1_router',
            components=[],
        )
        block1_router.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_5
        selected_routine = schedule[trial_index]
        
        
        # store start times for block1_router
        block1_router.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        block1_router.tStart = globalClock.getTime(format='float')
        block1_router.status = STARTED
        thisExp.addData('block1_router.started', block1_router.tStart)
        block1_router.maxDuration = None
        # keep track of which components have finished
        block1_routerComponents = block1_router.components
        for thisComponent in block1_router.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "block1_router" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        block1_router.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                block1_router.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in block1_router.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "block1_router" ---
        for thisComponent in block1_router.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for block1_router
        block1_router.tStop = globalClock.getTime(format='float')
        block1_router.tStopRefresh = tThisFlipGlobal
        thisExp.addData('block1_router.stopped', block1_router.tStop)
        # Run 'End Routine' code from code_5
        trial_index += 1
        
        
        # the Routine "block1_router" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_right" ---
        # create an object to store info about Routine LEFT_on_right
        LEFT_on_right = data.Routine(
            name='LEFT_on_right',
            components=[blacksquare_10, white_cross_10, key_resp_13, LEFT_2, whitesquare_3, whitesquare_4],
        )
        LEFT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_13
        key_resp_13.keys = []
        key_resp_13.rt = []
        _key_resp_13_allKeys = []
        # Run 'Begin Routine' code from code_6
        if currentRoutine != "LEFT_on_right":
            continueRoutine = False
        
        # store start times for LEFT_on_right
        LEFT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_right.tStart = globalClock.getTime(format='float')
        LEFT_on_right.status = STARTED
        thisExp.addData('LEFT_on_right.started', LEFT_on_right.tStart)
        LEFT_on_right.maxDuration = None
        # keep track of which components have finished
        LEFT_on_rightComponents = LEFT_on_right.components
        for thisComponent in LEFT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_10* updates
            
            # if blacksquare_10 is starting this frame...
            if blacksquare_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_10.frameNStart = frameN  # exact frame index
                blacksquare_10.tStart = t  # local t and not account for scr refresh
                blacksquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_10.started')
                # update status
                blacksquare_10.status = STARTED
                blacksquare_10.setAutoDraw(True)
            
            # if blacksquare_10 is active this frame...
            if blacksquare_10.status == STARTED:
                # update params
                pass
            
            # *white_cross_10* updates
            
            # if white_cross_10 is starting this frame...
            if white_cross_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                white_cross_10.frameNStart = frameN  # exact frame index
                white_cross_10.tStart = t  # local t and not account for scr refresh
                white_cross_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_10.started')
                # update status
                white_cross_10.status = STARTED
                white_cross_10.setAutoDraw(True)
            
            # if white_cross_10 is active this frame...
            if white_cross_10.status == STARTED:
                # update params
                pass
            
            # *key_resp_13* updates
            waitOnFlip = False
            
            # if key_resp_13 is starting this frame...
            if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_13.frameNStart = frameN  # exact frame index
                key_resp_13.tStart = t  # local t and not account for scr refresh
                key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_13.started')
                # update status
                key_resp_13.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_13.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_13.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_13_allKeys.extend(theseKeys)
                if len(_key_resp_13_allKeys):
                    key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
                    key_resp_13.rt = _key_resp_13_allKeys[-1].rt
                    key_resp_13.duration = _key_resp_13_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_13.keys == str('left')) or (key_resp_13.keys == 'left'):
                        key_resp_13.corr = 1
                    else:
                        key_resp_13.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_2* updates
            
            # if LEFT_2 is starting this frame...
            if LEFT_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_2.frameNStart = frameN  # exact frame index
                LEFT_2.tStart = t  # local t and not account for scr refresh
                LEFT_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_2.started')
                # update status
                LEFT_2.status = STARTED
                LEFT_2.setAutoDraw(True)
            
            # if LEFT_2 is active this frame...
            if LEFT_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_3* updates
            
            # if whitesquare_3 is starting this frame...
            if whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_3.frameNStart = frameN  # exact frame index
                whitesquare_3.tStart = t  # local t and not account for scr refresh
                whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_3.started')
                # update status
                whitesquare_3.status = STARTED
                whitesquare_3.setAutoDraw(True)
            
            # if whitesquare_3 is active this frame...
            if whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if whitesquare_3 is stopping this frame...
            if whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_3.tStop = t  # not accounting for scr refresh
                    whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_3.stopped')
                    # update status
                    whitesquare_3.status = FINISHED
                    whitesquare_3.setAutoDraw(False)
            
            # *whitesquare_4* updates
            
            # if whitesquare_4 is starting this frame...
            if whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_4.frameNStart = frameN  # exact frame index
                whitesquare_4.tStart = t  # local t and not account for scr refresh
                whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_4.started')
                # update status
                whitesquare_4.status = STARTED
                whitesquare_4.setAutoDraw(True)
            
            # if whitesquare_4 is active this frame...
            if whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if whitesquare_4 is stopping this frame...
            if whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_4.tStop = t  # not accounting for scr refresh
                    whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_4.stopped')
                    # update status
                    whitesquare_4.status = FINISHED
                    whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_right" ---
        for thisComponent in LEFT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_right
        LEFT_on_right.tStop = globalClock.getTime(format='float')
        LEFT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_right.stopped', LEFT_on_right.tStop)
        # check responses
        if key_resp_13.keys in ['', [], None]:  # No response was made
            key_resp_13.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_13.corr = 1;  # correct non-response
            else:
               key_resp_13.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_13.keys',key_resp_13.keys)
        trials_b1.addData('key_resp_13.corr', key_resp_13.corr)
        if key_resp_13.keys != None:  # we had a response
            trials_b1.addData('key_resp_13.rt', key_resp_13.rt)
            trials_b1.addData('key_resp_13.duration', key_resp_13.duration)
        # the Routine "LEFT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_right" ---
        # create an object to store info about Routine leftA_on_right
        leftA_on_right = data.Routine(
            name='leftA_on_right',
            components=[blacksquare_18, white_cross_18, key_resp_21, arrow_l_2, whitesquare_5, whitesquare_12],
        )
        leftA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_21
        key_resp_21.keys = []
        key_resp_21.rt = []
        _key_resp_21_allKeys = []
        # Run 'Begin Routine' code from code_7
        
        
        if currentRoutine != "leftA_on_right":
            continueRoutine = False
        
        # store start times for leftA_on_right
        leftA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_right.tStart = globalClock.getTime(format='float')
        leftA_on_right.status = STARTED
        thisExp.addData('leftA_on_right.started', leftA_on_right.tStart)
        leftA_on_right.maxDuration = None
        # keep track of which components have finished
        leftA_on_rightComponents = leftA_on_right.components
        for thisComponent in leftA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        leftA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_18* updates
            
            # if blacksquare_18 is starting this frame...
            if blacksquare_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_18.frameNStart = frameN  # exact frame index
                blacksquare_18.tStart = t  # local t and not account for scr refresh
                blacksquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_18.started')
                # update status
                blacksquare_18.status = STARTED
                blacksquare_18.setAutoDraw(True)
            
            # if blacksquare_18 is active this frame...
            if blacksquare_18.status == STARTED:
                # update params
                pass
            
            # *white_cross_18* updates
            
            # if white_cross_18 is starting this frame...
            if white_cross_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_18.frameNStart = frameN  # exact frame index
                white_cross_18.tStart = t  # local t and not account for scr refresh
                white_cross_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_18.started')
                # update status
                white_cross_18.status = STARTED
                white_cross_18.setAutoDraw(True)
            
            # if white_cross_18 is active this frame...
            if white_cross_18.status == STARTED:
                # update params
                pass
            
            # *key_resp_21* updates
            waitOnFlip = False
            
            # if key_resp_21 is starting this frame...
            if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_21.frameNStart = frameN  # exact frame index
                key_resp_21.tStart = t  # local t and not account for scr refresh
                key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_21.started')
                # update status
                key_resp_21.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_21.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_21.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_21_allKeys.extend(theseKeys)
                if len(_key_resp_21_allKeys):
                    key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
                    key_resp_21.rt = _key_resp_21_allKeys[-1].rt
                    key_resp_21.duration = _key_resp_21_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_21.keys == str('left')) or (key_resp_21.keys == 'left'):
                        key_resp_21.corr = 1
                    else:
                        key_resp_21.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_2* updates
            
            # if arrow_l_2 is starting this frame...
            if arrow_l_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_2.frameNStart = frameN  # exact frame index
                arrow_l_2.tStart = t  # local t and not account for scr refresh
                arrow_l_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_2.started')
                # update status
                arrow_l_2.status = STARTED
                arrow_l_2.setAutoDraw(True)
            
            # if arrow_l_2 is active this frame...
            if arrow_l_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_5* updates
            
            # if whitesquare_5 is starting this frame...
            if whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_5.frameNStart = frameN  # exact frame index
                whitesquare_5.tStart = t  # local t and not account for scr refresh
                whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_5.started')
                # update status
                whitesquare_5.status = STARTED
                whitesquare_5.setAutoDraw(True)
            
            # if whitesquare_5 is active this frame...
            if whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if whitesquare_5 is stopping this frame...
            if whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_5.tStop = t  # not accounting for scr refresh
                    whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_5.stopped')
                    # update status
                    whitesquare_5.status = FINISHED
                    whitesquare_5.setAutoDraw(False)
            
            # *whitesquare_12* updates
            
            # if whitesquare_12 is starting this frame...
            if whitesquare_12.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_12.frameNStart = frameN  # exact frame index
                whitesquare_12.tStart = t  # local t and not account for scr refresh
                whitesquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_12.started')
                # update status
                whitesquare_12.status = STARTED
                whitesquare_12.setAutoDraw(True)
            
            # if whitesquare_12 is active this frame...
            if whitesquare_12.status == STARTED:
                # update params
                pass
            
            # if whitesquare_12 is stopping this frame...
            if whitesquare_12.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_12.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_12.tStop = t  # not accounting for scr refresh
                    whitesquare_12.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_12.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_12.stopped')
                    # update status
                    whitesquare_12.status = FINISHED
                    whitesquare_12.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_right" ---
        for thisComponent in leftA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_right
        leftA_on_right.tStop = globalClock.getTime(format='float')
        leftA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_right.stopped', leftA_on_right.tStop)
        # check responses
        if key_resp_21.keys in ['', [], None]:  # No response was made
            key_resp_21.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_21.corr = 1;  # correct non-response
            else:
               key_resp_21.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_21.keys',key_resp_21.keys)
        trials_b1.addData('key_resp_21.corr', key_resp_21.corr)
        if key_resp_21.keys != None:  # we had a response
            trials_b1.addData('key_resp_21.rt', key_resp_21.rt)
            trials_b1.addData('key_resp_21.duration', key_resp_21.duration)
        # the Routine "leftA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_left" ---
        # create an object to store info about Routine LEFT_on_left
        LEFT_on_left = data.Routine(
            name='LEFT_on_left',
            components=[blacksquare_12, white_cross_12, key_resp_15, LEFT_4, whitesquare_6, whitesquare_13],
        )
        LEFT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_15
        key_resp_15.keys = []
        key_resp_15.rt = []
        _key_resp_15_allKeys = []
        # Run 'Begin Routine' code from code_8
        
        
        if currentRoutine != "LEFT_on_left":
            continueRoutine = False
        
        # store start times for LEFT_on_left
        LEFT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_left.tStart = globalClock.getTime(format='float')
        LEFT_on_left.status = STARTED
        thisExp.addData('LEFT_on_left.started', LEFT_on_left.tStart)
        LEFT_on_left.maxDuration = None
        # keep track of which components have finished
        LEFT_on_leftComponents = LEFT_on_left.components
        for thisComponent in LEFT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_12* updates
            
            # if blacksquare_12 is starting this frame...
            if blacksquare_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_12.frameNStart = frameN  # exact frame index
                blacksquare_12.tStart = t  # local t and not account for scr refresh
                blacksquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_12.started')
                # update status
                blacksquare_12.status = STARTED
                blacksquare_12.setAutoDraw(True)
            
            # if blacksquare_12 is active this frame...
            if blacksquare_12.status == STARTED:
                # update params
                pass
            
            # *white_cross_12* updates
            
            # if white_cross_12 is starting this frame...
            if white_cross_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_12.frameNStart = frameN  # exact frame index
                white_cross_12.tStart = t  # local t and not account for scr refresh
                white_cross_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_12.started')
                # update status
                white_cross_12.status = STARTED
                white_cross_12.setAutoDraw(True)
            
            # if white_cross_12 is active this frame...
            if white_cross_12.status == STARTED:
                # update params
                pass
            
            # *key_resp_15* updates
            waitOnFlip = False
            
            # if key_resp_15 is starting this frame...
            if key_resp_15.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_15.frameNStart = frameN  # exact frame index
                key_resp_15.tStart = t  # local t and not account for scr refresh
                key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_15.started')
                # update status
                key_resp_15.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_15.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_15.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_15_allKeys.extend(theseKeys)
                if len(_key_resp_15_allKeys):
                    key_resp_15.keys = _key_resp_15_allKeys[-1].name  # just the last key pressed
                    key_resp_15.rt = _key_resp_15_allKeys[-1].rt
                    key_resp_15.duration = _key_resp_15_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_15.keys == str('left')) or (key_resp_15.keys == 'left'):
                        key_resp_15.corr = 1
                    else:
                        key_resp_15.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_4* updates
            
            # if LEFT_4 is starting this frame...
            if LEFT_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_4.frameNStart = frameN  # exact frame index
                LEFT_4.tStart = t  # local t and not account for scr refresh
                LEFT_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_4.started')
                # update status
                LEFT_4.status = STARTED
                LEFT_4.setAutoDraw(True)
            
            # if LEFT_4 is active this frame...
            if LEFT_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_6* updates
            
            # if whitesquare_6 is starting this frame...
            if whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_6.frameNStart = frameN  # exact frame index
                whitesquare_6.tStart = t  # local t and not account for scr refresh
                whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_6.started')
                # update status
                whitesquare_6.status = STARTED
                whitesquare_6.setAutoDraw(True)
            
            # if whitesquare_6 is active this frame...
            if whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if whitesquare_6 is stopping this frame...
            if whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_6.tStop = t  # not accounting for scr refresh
                    whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_6.stopped')
                    # update status
                    whitesquare_6.status = FINISHED
                    whitesquare_6.setAutoDraw(False)
            
            # *whitesquare_13* updates
            
            # if whitesquare_13 is starting this frame...
            if whitesquare_13.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_13.frameNStart = frameN  # exact frame index
                whitesquare_13.tStart = t  # local t and not account for scr refresh
                whitesquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_13.started')
                # update status
                whitesquare_13.status = STARTED
                whitesquare_13.setAutoDraw(True)
            
            # if whitesquare_13 is active this frame...
            if whitesquare_13.status == STARTED:
                # update params
                pass
            
            # if whitesquare_13 is stopping this frame...
            if whitesquare_13.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_13.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_13.tStop = t  # not accounting for scr refresh
                    whitesquare_13.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_13.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_13.stopped')
                    # update status
                    whitesquare_13.status = FINISHED
                    whitesquare_13.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_left" ---
        for thisComponent in LEFT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_left
        LEFT_on_left.tStop = globalClock.getTime(format='float')
        LEFT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_left.stopped', LEFT_on_left.tStop)
        # check responses
        if key_resp_15.keys in ['', [], None]:  # No response was made
            key_resp_15.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_15.corr = 1;  # correct non-response
            else:
               key_resp_15.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_15.keys',key_resp_15.keys)
        trials_b1.addData('key_resp_15.corr', key_resp_15.corr)
        if key_resp_15.keys != None:  # we had a response
            trials_b1.addData('key_resp_15.rt', key_resp_15.rt)
            trials_b1.addData('key_resp_15.duration', key_resp_15.duration)
        # the Routine "LEFT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_left" ---
        # create an object to store info about Routine leftA_on_left
        leftA_on_left = data.Routine(
            name='leftA_on_left',
            components=[blacksquare_19, white_cross_19, key_resp_22, arrow_l_3, whitesquare_7, whitesquare_14],
        )
        leftA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_22
        key_resp_22.keys = []
        key_resp_22.rt = []
        _key_resp_22_allKeys = []
        # Run 'Begin Routine' code from code_9
        
        
        if currentRoutine != "leftA_on_left":
            continueRoutine = False
        
        # store start times for leftA_on_left
        leftA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_left.tStart = globalClock.getTime(format='float')
        leftA_on_left.status = STARTED
        thisExp.addData('leftA_on_left.started', leftA_on_left.tStart)
        leftA_on_left.maxDuration = None
        # keep track of which components have finished
        leftA_on_leftComponents = leftA_on_left.components
        for thisComponent in leftA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        leftA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_19* updates
            
            # if blacksquare_19 is starting this frame...
            if blacksquare_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_19.frameNStart = frameN  # exact frame index
                blacksquare_19.tStart = t  # local t and not account for scr refresh
                blacksquare_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_19.started')
                # update status
                blacksquare_19.status = STARTED
                blacksquare_19.setAutoDraw(True)
            
            # if blacksquare_19 is active this frame...
            if blacksquare_19.status == STARTED:
                # update params
                pass
            
            # *white_cross_19* updates
            
            # if white_cross_19 is starting this frame...
            if white_cross_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_19.frameNStart = frameN  # exact frame index
                white_cross_19.tStart = t  # local t and not account for scr refresh
                white_cross_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_19.started')
                # update status
                white_cross_19.status = STARTED
                white_cross_19.setAutoDraw(True)
            
            # if white_cross_19 is active this frame...
            if white_cross_19.status == STARTED:
                # update params
                pass
            
            # *key_resp_22* updates
            waitOnFlip = False
            
            # if key_resp_22 is starting this frame...
            if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_22.frameNStart = frameN  # exact frame index
                key_resp_22.tStart = t  # local t and not account for scr refresh
                key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_22.started')
                # update status
                key_resp_22.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_22.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_22.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_22_allKeys.extend(theseKeys)
                if len(_key_resp_22_allKeys):
                    key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
                    key_resp_22.rt = _key_resp_22_allKeys[-1].rt
                    key_resp_22.duration = _key_resp_22_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_22.keys == str('left')) or (key_resp_22.keys == 'left'):
                        key_resp_22.corr = 1
                    else:
                        key_resp_22.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_3* updates
            
            # if arrow_l_3 is starting this frame...
            if arrow_l_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_3.frameNStart = frameN  # exact frame index
                arrow_l_3.tStart = t  # local t and not account for scr refresh
                arrow_l_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_3.started')
                # update status
                arrow_l_3.status = STARTED
                arrow_l_3.setAutoDraw(True)
            
            # if arrow_l_3 is active this frame...
            if arrow_l_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_7* updates
            
            # if whitesquare_7 is starting this frame...
            if whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_7.frameNStart = frameN  # exact frame index
                whitesquare_7.tStart = t  # local t and not account for scr refresh
                whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_7.started')
                # update status
                whitesquare_7.status = STARTED
                whitesquare_7.setAutoDraw(True)
            
            # if whitesquare_7 is active this frame...
            if whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if whitesquare_7 is stopping this frame...
            if whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_7.tStop = t  # not accounting for scr refresh
                    whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_7.stopped')
                    # update status
                    whitesquare_7.status = FINISHED
                    whitesquare_7.setAutoDraw(False)
            
            # *whitesquare_14* updates
            
            # if whitesquare_14 is starting this frame...
            if whitesquare_14.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_14.frameNStart = frameN  # exact frame index
                whitesquare_14.tStart = t  # local t and not account for scr refresh
                whitesquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_14.started')
                # update status
                whitesquare_14.status = STARTED
                whitesquare_14.setAutoDraw(True)
            
            # if whitesquare_14 is active this frame...
            if whitesquare_14.status == STARTED:
                # update params
                pass
            
            # if whitesquare_14 is stopping this frame...
            if whitesquare_14.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_14.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_14.tStop = t  # not accounting for scr refresh
                    whitesquare_14.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_14.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_14.stopped')
                    # update status
                    whitesquare_14.status = FINISHED
                    whitesquare_14.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_left" ---
        for thisComponent in leftA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_left
        leftA_on_left.tStop = globalClock.getTime(format='float')
        leftA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_left.stopped', leftA_on_left.tStop)
        # check responses
        if key_resp_22.keys in ['', [], None]:  # No response was made
            key_resp_22.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_22.corr = 1;  # correct non-response
            else:
               key_resp_22.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_22.keys',key_resp_22.keys)
        trials_b1.addData('key_resp_22.corr', key_resp_22.corr)
        if key_resp_22.keys != None:  # we had a response
            trials_b1.addData('key_resp_22.rt', key_resp_22.rt)
            trials_b1.addData('key_resp_22.duration', key_resp_22.duration)
        # the Routine "leftA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_left" ---
        # create an object to store info about Routine RIGHT_on_left
        RIGHT_on_left = data.Routine(
            name='RIGHT_on_left',
            components=[blacksquare_13, white_cross_13, key_resp_16, RIGHT_5, whitesquare_8, whitesquare_15],
        )
        RIGHT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_16
        key_resp_16.keys = []
        key_resp_16.rt = []
        _key_resp_16_allKeys = []
        # Run 'Begin Routine' code from code_10
        
        if currentRoutine != "RIGHT_on_left":
            continueRoutine = False
        
        # store start times for RIGHT_on_left
        RIGHT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_left.tStart = globalClock.getTime(format='float')
        RIGHT_on_left.status = STARTED
        thisExp.addData('RIGHT_on_left.started', RIGHT_on_left.tStart)
        RIGHT_on_left.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_leftComponents = RIGHT_on_left.components
        for thisComponent in RIGHT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_13* updates
            
            # if blacksquare_13 is starting this frame...
            if blacksquare_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_13.frameNStart = frameN  # exact frame index
                blacksquare_13.tStart = t  # local t and not account for scr refresh
                blacksquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_13.started')
                # update status
                blacksquare_13.status = STARTED
                blacksquare_13.setAutoDraw(True)
            
            # if blacksquare_13 is active this frame...
            if blacksquare_13.status == STARTED:
                # update params
                pass
            
            # *white_cross_13* updates
            
            # if white_cross_13 is starting this frame...
            if white_cross_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_13.frameNStart = frameN  # exact frame index
                white_cross_13.tStart = t  # local t and not account for scr refresh
                white_cross_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_13.started')
                # update status
                white_cross_13.status = STARTED
                white_cross_13.setAutoDraw(True)
            
            # if white_cross_13 is active this frame...
            if white_cross_13.status == STARTED:
                # update params
                pass
            
            # *key_resp_16* updates
            waitOnFlip = False
            
            # if key_resp_16 is starting this frame...
            if key_resp_16.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_16.frameNStart = frameN  # exact frame index
                key_resp_16.tStart = t  # local t and not account for scr refresh
                key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_16.started')
                # update status
                key_resp_16.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_16.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_16.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_16_allKeys.extend(theseKeys)
                if len(_key_resp_16_allKeys):
                    key_resp_16.keys = _key_resp_16_allKeys[-1].name  # just the last key pressed
                    key_resp_16.rt = _key_resp_16_allKeys[-1].rt
                    key_resp_16.duration = _key_resp_16_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_16.keys == str('left')) or (key_resp_16.keys == 'left'):
                        key_resp_16.corr = 1
                    else:
                        key_resp_16.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_5* updates
            
            # if RIGHT_5 is starting this frame...
            if RIGHT_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_5.frameNStart = frameN  # exact frame index
                RIGHT_5.tStart = t  # local t and not account for scr refresh
                RIGHT_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_5.started')
                # update status
                RIGHT_5.status = STARTED
                RIGHT_5.setAutoDraw(True)
            
            # if RIGHT_5 is active this frame...
            if RIGHT_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_8* updates
            
            # if whitesquare_8 is starting this frame...
            if whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_8.frameNStart = frameN  # exact frame index
                whitesquare_8.tStart = t  # local t and not account for scr refresh
                whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_8.started')
                # update status
                whitesquare_8.status = STARTED
                whitesquare_8.setAutoDraw(True)
            
            # if whitesquare_8 is active this frame...
            if whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if whitesquare_8 is stopping this frame...
            if whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_8.tStop = t  # not accounting for scr refresh
                    whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_8.stopped')
                    # update status
                    whitesquare_8.status = FINISHED
                    whitesquare_8.setAutoDraw(False)
            
            # *whitesquare_15* updates
            
            # if whitesquare_15 is starting this frame...
            if whitesquare_15.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_15.frameNStart = frameN  # exact frame index
                whitesquare_15.tStart = t  # local t and not account for scr refresh
                whitesquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_15.started')
                # update status
                whitesquare_15.status = STARTED
                whitesquare_15.setAutoDraw(True)
            
            # if whitesquare_15 is active this frame...
            if whitesquare_15.status == STARTED:
                # update params
                pass
            
            # if whitesquare_15 is stopping this frame...
            if whitesquare_15.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_15.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_15.tStop = t  # not accounting for scr refresh
                    whitesquare_15.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_15.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_15.stopped')
                    # update status
                    whitesquare_15.status = FINISHED
                    whitesquare_15.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_left" ---
        for thisComponent in RIGHT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_left
        RIGHT_on_left.tStop = globalClock.getTime(format='float')
        RIGHT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_left.stopped', RIGHT_on_left.tStop)
        # check responses
        if key_resp_16.keys in ['', [], None]:  # No response was made
            key_resp_16.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_16.corr = 1;  # correct non-response
            else:
               key_resp_16.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_16.keys',key_resp_16.keys)
        trials_b1.addData('key_resp_16.corr', key_resp_16.corr)
        if key_resp_16.keys != None:  # we had a response
            trials_b1.addData('key_resp_16.rt', key_resp_16.rt)
            trials_b1.addData('key_resp_16.duration', key_resp_16.duration)
        # the Routine "RIGHT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_left" ---
        # create an object to store info about Routine rightA_on_left
        rightA_on_left = data.Routine(
            name='rightA_on_left',
            components=[blacksquare_21, white_cross_21, key_resp_24, arrow_l_5, whitesquare_9, whitesquare_16],
        )
        rightA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_24
        key_resp_24.keys = []
        key_resp_24.rt = []
        _key_resp_24_allKeys = []
        # Run 'Begin Routine' code from code_11
        
        
        if currentRoutine != "rightA_on_left":
            continueRoutine = False
        
        # store start times for rightA_on_left
        rightA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_left.tStart = globalClock.getTime(format='float')
        rightA_on_left.status = STARTED
        thisExp.addData('rightA_on_left.started', rightA_on_left.tStart)
        rightA_on_left.maxDuration = None
        # keep track of which components have finished
        rightA_on_leftComponents = rightA_on_left.components
        for thisComponent in rightA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        rightA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_21* updates
            
            # if blacksquare_21 is starting this frame...
            if blacksquare_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_21.frameNStart = frameN  # exact frame index
                blacksquare_21.tStart = t  # local t and not account for scr refresh
                blacksquare_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_21.started')
                # update status
                blacksquare_21.status = STARTED
                blacksquare_21.setAutoDraw(True)
            
            # if blacksquare_21 is active this frame...
            if blacksquare_21.status == STARTED:
                # update params
                pass
            
            # *white_cross_21* updates
            
            # if white_cross_21 is starting this frame...
            if white_cross_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_21.frameNStart = frameN  # exact frame index
                white_cross_21.tStart = t  # local t and not account for scr refresh
                white_cross_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_21.started')
                # update status
                white_cross_21.status = STARTED
                white_cross_21.setAutoDraw(True)
            
            # if white_cross_21 is active this frame...
            if white_cross_21.status == STARTED:
                # update params
                pass
            
            # *key_resp_24* updates
            waitOnFlip = False
            
            # if key_resp_24 is starting this frame...
            if key_resp_24.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_24.frameNStart = frameN  # exact frame index
                key_resp_24.tStart = t  # local t and not account for scr refresh
                key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_24.started')
                # update status
                key_resp_24.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_24.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_24.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_24_allKeys.extend(theseKeys)
                if len(_key_resp_24_allKeys):
                    key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
                    key_resp_24.rt = _key_resp_24_allKeys[-1].rt
                    key_resp_24.duration = _key_resp_24_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_24.keys == str('left')) or (key_resp_24.keys == 'left'):
                        key_resp_24.corr = 1
                    else:
                        key_resp_24.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_5* updates
            
            # if arrow_l_5 is starting this frame...
            if arrow_l_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_5.frameNStart = frameN  # exact frame index
                arrow_l_5.tStart = t  # local t and not account for scr refresh
                arrow_l_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_5.started')
                # update status
                arrow_l_5.status = STARTED
                arrow_l_5.setAutoDraw(True)
            
            # if arrow_l_5 is active this frame...
            if arrow_l_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_9* updates
            
            # if whitesquare_9 is starting this frame...
            if whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_9.frameNStart = frameN  # exact frame index
                whitesquare_9.tStart = t  # local t and not account for scr refresh
                whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_9.started')
                # update status
                whitesquare_9.status = STARTED
                whitesquare_9.setAutoDraw(True)
            
            # if whitesquare_9 is active this frame...
            if whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if whitesquare_9 is stopping this frame...
            if whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_9.tStop = t  # not accounting for scr refresh
                    whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_9.stopped')
                    # update status
                    whitesquare_9.status = FINISHED
                    whitesquare_9.setAutoDraw(False)
            
            # *whitesquare_16* updates
            
            # if whitesquare_16 is starting this frame...
            if whitesquare_16.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_16.frameNStart = frameN  # exact frame index
                whitesquare_16.tStart = t  # local t and not account for scr refresh
                whitesquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_16.started')
                # update status
                whitesquare_16.status = STARTED
                whitesquare_16.setAutoDraw(True)
            
            # if whitesquare_16 is active this frame...
            if whitesquare_16.status == STARTED:
                # update params
                pass
            
            # if whitesquare_16 is stopping this frame...
            if whitesquare_16.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_16.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_16.tStop = t  # not accounting for scr refresh
                    whitesquare_16.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_16.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_16.stopped')
                    # update status
                    whitesquare_16.status = FINISHED
                    whitesquare_16.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_left" ---
        for thisComponent in rightA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_left
        rightA_on_left.tStop = globalClock.getTime(format='float')
        rightA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_left.stopped', rightA_on_left.tStop)
        # check responses
        if key_resp_24.keys in ['', [], None]:  # No response was made
            key_resp_24.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_24.corr = 1;  # correct non-response
            else:
               key_resp_24.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_24.keys',key_resp_24.keys)
        trials_b1.addData('key_resp_24.corr', key_resp_24.corr)
        if key_resp_24.keys != None:  # we had a response
            trials_b1.addData('key_resp_24.rt', key_resp_24.rt)
            trials_b1.addData('key_resp_24.duration', key_resp_24.duration)
        # the Routine "rightA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_right" ---
        # create an object to store info about Routine RIGHT_on_right
        RIGHT_on_right = data.Routine(
            name='RIGHT_on_right',
            components=[blacksquare_11, white_cross_11, key_resp_14, RIGHT_3, whitesquare_10, whitesquare_17],
        )
        RIGHT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_14
        key_resp_14.keys = []
        key_resp_14.rt = []
        _key_resp_14_allKeys = []
        # Run 'Begin Routine' code from code_12
        if currentRoutine != "RIGHT_on_right":
            continueRoutine = False
        
        # store start times for RIGHT_on_right
        RIGHT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_right.tStart = globalClock.getTime(format='float')
        RIGHT_on_right.status = STARTED
        thisExp.addData('RIGHT_on_right.started', RIGHT_on_right.tStart)
        RIGHT_on_right.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_rightComponents = RIGHT_on_right.components
        for thisComponent in RIGHT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_11* updates
            
            # if blacksquare_11 is starting this frame...
            if blacksquare_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_11.frameNStart = frameN  # exact frame index
                blacksquare_11.tStart = t  # local t and not account for scr refresh
                blacksquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_11.started')
                # update status
                blacksquare_11.status = STARTED
                blacksquare_11.setAutoDraw(True)
            
            # if blacksquare_11 is active this frame...
            if blacksquare_11.status == STARTED:
                # update params
                pass
            
            # *white_cross_11* updates
            
            # if white_cross_11 is starting this frame...
            if white_cross_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_11.frameNStart = frameN  # exact frame index
                white_cross_11.tStart = t  # local t and not account for scr refresh
                white_cross_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_11.started')
                # update status
                white_cross_11.status = STARTED
                white_cross_11.setAutoDraw(True)
            
            # if white_cross_11 is active this frame...
            if white_cross_11.status == STARTED:
                # update params
                pass
            
            # *key_resp_14* updates
            waitOnFlip = False
            
            # if key_resp_14 is starting this frame...
            if key_resp_14.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_14.frameNStart = frameN  # exact frame index
                key_resp_14.tStart = t  # local t and not account for scr refresh
                key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_14.started')
                # update status
                key_resp_14.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_14.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_14.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_14_allKeys.extend(theseKeys)
                if len(_key_resp_14_allKeys):
                    key_resp_14.keys = _key_resp_14_allKeys[-1].name  # just the last key pressed
                    key_resp_14.rt = _key_resp_14_allKeys[-1].rt
                    key_resp_14.duration = _key_resp_14_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_14.keys == str('left')) or (key_resp_14.keys == 'left'):
                        key_resp_14.corr = 1
                    else:
                        key_resp_14.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_3* updates
            
            # if RIGHT_3 is starting this frame...
            if RIGHT_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_3.frameNStart = frameN  # exact frame index
                RIGHT_3.tStart = t  # local t and not account for scr refresh
                RIGHT_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_3.started')
                # update status
                RIGHT_3.status = STARTED
                RIGHT_3.setAutoDraw(True)
            
            # if RIGHT_3 is active this frame...
            if RIGHT_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_10* updates
            
            # if whitesquare_10 is starting this frame...
            if whitesquare_10.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_10.frameNStart = frameN  # exact frame index
                whitesquare_10.tStart = t  # local t and not account for scr refresh
                whitesquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_10.started')
                # update status
                whitesquare_10.status = STARTED
                whitesquare_10.setAutoDraw(True)
            
            # if whitesquare_10 is active this frame...
            if whitesquare_10.status == STARTED:
                # update params
                pass
            
            # if whitesquare_10 is stopping this frame...
            if whitesquare_10.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_10.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_10.tStop = t  # not accounting for scr refresh
                    whitesquare_10.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_10.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_10.stopped')
                    # update status
                    whitesquare_10.status = FINISHED
                    whitesquare_10.setAutoDraw(False)
            
            # *whitesquare_17* updates
            
            # if whitesquare_17 is starting this frame...
            if whitesquare_17.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_17.frameNStart = frameN  # exact frame index
                whitesquare_17.tStart = t  # local t and not account for scr refresh
                whitesquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_17.started')
                # update status
                whitesquare_17.status = STARTED
                whitesquare_17.setAutoDraw(True)
            
            # if whitesquare_17 is active this frame...
            if whitesquare_17.status == STARTED:
                # update params
                pass
            
            # if whitesquare_17 is stopping this frame...
            if whitesquare_17.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_17.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_17.tStop = t  # not accounting for scr refresh
                    whitesquare_17.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_17.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_17.stopped')
                    # update status
                    whitesquare_17.status = FINISHED
                    whitesquare_17.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_right" ---
        for thisComponent in RIGHT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_right
        RIGHT_on_right.tStop = globalClock.getTime(format='float')
        RIGHT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_right.stopped', RIGHT_on_right.tStop)
        # check responses
        if key_resp_14.keys in ['', [], None]:  # No response was made
            key_resp_14.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_14.corr = 1;  # correct non-response
            else:
               key_resp_14.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_14.keys',key_resp_14.keys)
        trials_b1.addData('key_resp_14.corr', key_resp_14.corr)
        if key_resp_14.keys != None:  # we had a response
            trials_b1.addData('key_resp_14.rt', key_resp_14.rt)
            trials_b1.addData('key_resp_14.duration', key_resp_14.duration)
        # the Routine "RIGHT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_right" ---
        # create an object to store info about Routine rightA_on_right
        rightA_on_right = data.Routine(
            name='rightA_on_right',
            components=[blacksquare_20, white_cross_20, key_resp_23, arrow_l_4, whitesquare_11, whitesquare_18],
        )
        rightA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_23
        key_resp_23.keys = []
        key_resp_23.rt = []
        _key_resp_23_allKeys = []
        # Run 'Begin Routine' code from code_13
        
        
        if currentRoutine != "rightA_on_right":
            continueRoutine = False
        
        # store start times for rightA_on_right
        rightA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_right.tStart = globalClock.getTime(format='float')
        rightA_on_right.status = STARTED
        thisExp.addData('rightA_on_right.started', rightA_on_right.tStart)
        rightA_on_right.maxDuration = None
        # keep track of which components have finished
        rightA_on_rightComponents = rightA_on_right.components
        for thisComponent in rightA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        rightA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_20* updates
            
            # if blacksquare_20 is starting this frame...
            if blacksquare_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_20.frameNStart = frameN  # exact frame index
                blacksquare_20.tStart = t  # local t and not account for scr refresh
                blacksquare_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_20.started')
                # update status
                blacksquare_20.status = STARTED
                blacksquare_20.setAutoDraw(True)
            
            # if blacksquare_20 is active this frame...
            if blacksquare_20.status == STARTED:
                # update params
                pass
            
            # *white_cross_20* updates
            
            # if white_cross_20 is starting this frame...
            if white_cross_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_20.frameNStart = frameN  # exact frame index
                white_cross_20.tStart = t  # local t and not account for scr refresh
                white_cross_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_20.started')
                # update status
                white_cross_20.status = STARTED
                white_cross_20.setAutoDraw(True)
            
            # if white_cross_20 is active this frame...
            if white_cross_20.status == STARTED:
                # update params
                pass
            
            # *key_resp_23* updates
            waitOnFlip = False
            
            # if key_resp_23 is starting this frame...
            if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_23.frameNStart = frameN  # exact frame index
                key_resp_23.tStart = t  # local t and not account for scr refresh
                key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_23.started')
                # update status
                key_resp_23.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_23.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_23.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_23_allKeys.extend(theseKeys)
                if len(_key_resp_23_allKeys):
                    key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
                    key_resp_23.rt = _key_resp_23_allKeys[-1].rt
                    key_resp_23.duration = _key_resp_23_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_23.keys == str('left')) or (key_resp_23.keys == 'left'):
                        key_resp_23.corr = 1
                    else:
                        key_resp_23.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_4* updates
            
            # if arrow_l_4 is starting this frame...
            if arrow_l_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_4.frameNStart = frameN  # exact frame index
                arrow_l_4.tStart = t  # local t and not account for scr refresh
                arrow_l_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_4.started')
                # update status
                arrow_l_4.status = STARTED
                arrow_l_4.setAutoDraw(True)
            
            # if arrow_l_4 is active this frame...
            if arrow_l_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_11* updates
            
            # if whitesquare_11 is starting this frame...
            if whitesquare_11.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_11.frameNStart = frameN  # exact frame index
                whitesquare_11.tStart = t  # local t and not account for scr refresh
                whitesquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_11.started')
                # update status
                whitesquare_11.status = STARTED
                whitesquare_11.setAutoDraw(True)
            
            # if whitesquare_11 is active this frame...
            if whitesquare_11.status == STARTED:
                # update params
                pass
            
            # if whitesquare_11 is stopping this frame...
            if whitesquare_11.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_11.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_11.tStop = t  # not accounting for scr refresh
                    whitesquare_11.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_11.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_11.stopped')
                    # update status
                    whitesquare_11.status = FINISHED
                    whitesquare_11.setAutoDraw(False)
            
            # *whitesquare_18* updates
            
            # if whitesquare_18 is starting this frame...
            if whitesquare_18.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_18.frameNStart = frameN  # exact frame index
                whitesquare_18.tStart = t  # local t and not account for scr refresh
                whitesquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_18.started')
                # update status
                whitesquare_18.status = STARTED
                whitesquare_18.setAutoDraw(True)
            
            # if whitesquare_18 is active this frame...
            if whitesquare_18.status == STARTED:
                # update params
                pass
            
            # if whitesquare_18 is stopping this frame...
            if whitesquare_18.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_18.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_18.tStop = t  # not accounting for scr refresh
                    whitesquare_18.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_18.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_18.stopped')
                    # update status
                    whitesquare_18.status = FINISHED
                    whitesquare_18.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_right" ---
        for thisComponent in rightA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_right
        rightA_on_right.tStop = globalClock.getTime(format='float')
        rightA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_right.stopped', rightA_on_right.tStop)
        # check responses
        if key_resp_23.keys in ['', [], None]:  # No response was made
            key_resp_23.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_23.corr = 1;  # correct non-response
            else:
               key_resp_23.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_23.keys',key_resp_23.keys)
        trials_b1.addData('key_resp_23.corr', key_resp_23.corr)
        if key_resp_23.keys != None:  # we had a response
            trials_b1.addData('key_resp_23.rt', key_resp_23.rt)
            trials_b1.addData('key_resp_23.duration', key_resp_23.duration)
        # the Routine "rightA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_up" ---
        # create an object to store info about Routine UP_on_up
        UP_on_up = data.Routine(
            name='UP_on_up',
            components=[blacksquare_14, white_cross_14, key_resp_17, UP_5, up_whitesquare_2, down_whitesquare_2],
        )
        UP_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_17
        key_resp_17.keys = []
        key_resp_17.rt = []
        _key_resp_17_allKeys = []
        # Run 'Begin Routine' code from code_14
        
        if currentRoutine != "UP_on_up":
            continueRoutine = False
        
        # store start times for UP_on_up
        UP_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_up.tStart = globalClock.getTime(format='float')
        UP_on_up.status = STARTED
        thisExp.addData('UP_on_up.started', UP_on_up.tStart)
        UP_on_up.maxDuration = None
        # keep track of which components have finished
        UP_on_upComponents = UP_on_up.components
        for thisComponent in UP_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        UP_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_14* updates
            
            # if blacksquare_14 is starting this frame...
            if blacksquare_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_14.frameNStart = frameN  # exact frame index
                blacksquare_14.tStart = t  # local t and not account for scr refresh
                blacksquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_14.started')
                # update status
                blacksquare_14.status = STARTED
                blacksquare_14.setAutoDraw(True)
            
            # if blacksquare_14 is active this frame...
            if blacksquare_14.status == STARTED:
                # update params
                pass
            
            # *white_cross_14* updates
            
            # if white_cross_14 is starting this frame...
            if white_cross_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_14.frameNStart = frameN  # exact frame index
                white_cross_14.tStart = t  # local t and not account for scr refresh
                white_cross_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_14.started')
                # update status
                white_cross_14.status = STARTED
                white_cross_14.setAutoDraw(True)
            
            # if white_cross_14 is active this frame...
            if white_cross_14.status == STARTED:
                # update params
                pass
            
            # *key_resp_17* updates
            waitOnFlip = False
            
            # if key_resp_17 is starting this frame...
            if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_17.frameNStart = frameN  # exact frame index
                key_resp_17.tStart = t  # local t and not account for scr refresh
                key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_17.started')
                # update status
                key_resp_17.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_17.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_17.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_17_allKeys.extend(theseKeys)
                if len(_key_resp_17_allKeys):
                    key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
                    key_resp_17.rt = _key_resp_17_allKeys[-1].rt
                    key_resp_17.duration = _key_resp_17_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_17.keys == str('left')) or (key_resp_17.keys == 'left'):
                        key_resp_17.corr = 1
                    else:
                        key_resp_17.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_5* updates
            
            # if UP_5 is starting this frame...
            if UP_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_5.frameNStart = frameN  # exact frame index
                UP_5.tStart = t  # local t and not account for scr refresh
                UP_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_5.started')
                # update status
                UP_5.status = STARTED
                UP_5.setAutoDraw(True)
            
            # if UP_5 is active this frame...
            if UP_5.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_2* updates
            
            # if up_whitesquare_2 is starting this frame...
            if up_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_2.frameNStart = frameN  # exact frame index
                up_whitesquare_2.tStart = t  # local t and not account for scr refresh
                up_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_2.started')
                # update status
                up_whitesquare_2.status = STARTED
                up_whitesquare_2.setAutoDraw(True)
            
            # if up_whitesquare_2 is active this frame...
            if up_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_2 is stopping this frame...
            if up_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_2.tStop = t  # not accounting for scr refresh
                    up_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_2.stopped')
                    # update status
                    up_whitesquare_2.status = FINISHED
                    up_whitesquare_2.setAutoDraw(False)
            
            # *down_whitesquare_2* updates
            
            # if down_whitesquare_2 is starting this frame...
            if down_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_2.frameNStart = frameN  # exact frame index
                down_whitesquare_2.tStart = t  # local t and not account for scr refresh
                down_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_2.started')
                # update status
                down_whitesquare_2.status = STARTED
                down_whitesquare_2.setAutoDraw(True)
            
            # if down_whitesquare_2 is active this frame...
            if down_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_2 is stopping this frame...
            if down_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_2.tStop = t  # not accounting for scr refresh
                    down_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_2.stopped')
                    # update status
                    down_whitesquare_2.status = FINISHED
                    down_whitesquare_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_up" ---
        for thisComponent in UP_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_up
        UP_on_up.tStop = globalClock.getTime(format='float')
        UP_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_up.stopped', UP_on_up.tStop)
        # check responses
        if key_resp_17.keys in ['', [], None]:  # No response was made
            key_resp_17.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_17.corr = 1;  # correct non-response
            else:
               key_resp_17.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_17.keys',key_resp_17.keys)
        trials_b1.addData('key_resp_17.corr', key_resp_17.corr)
        if key_resp_17.keys != None:  # we had a response
            trials_b1.addData('key_resp_17.rt', key_resp_17.rt)
            trials_b1.addData('key_resp_17.duration', key_resp_17.duration)
        # the Routine "UP_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_up" ---
        # create an object to store info about Routine upA_on_up
        upA_on_up = data.Routine(
            name='upA_on_up',
            components=[blacksquare_22, white_cross_22, key_resp_25, arrow_u, up_whitesquare_3, down_whitesquare_3],
        )
        upA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_25
        key_resp_25.keys = []
        key_resp_25.rt = []
        _key_resp_25_allKeys = []
        # Run 'Begin Routine' code from code_15
        
        
        if currentRoutine != "upA_on_up":
            continueRoutine = False
        
        # store start times for upA_on_up
        upA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_up.tStart = globalClock.getTime(format='float')
        upA_on_up.status = STARTED
        thisExp.addData('upA_on_up.started', upA_on_up.tStart)
        upA_on_up.maxDuration = None
        # keep track of which components have finished
        upA_on_upComponents = upA_on_up.components
        for thisComponent in upA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        upA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_22* updates
            
            # if blacksquare_22 is starting this frame...
            if blacksquare_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_22.frameNStart = frameN  # exact frame index
                blacksquare_22.tStart = t  # local t and not account for scr refresh
                blacksquare_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_22.started')
                # update status
                blacksquare_22.status = STARTED
                blacksquare_22.setAutoDraw(True)
            
            # if blacksquare_22 is active this frame...
            if blacksquare_22.status == STARTED:
                # update params
                pass
            
            # *white_cross_22* updates
            
            # if white_cross_22 is starting this frame...
            if white_cross_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_22.frameNStart = frameN  # exact frame index
                white_cross_22.tStart = t  # local t and not account for scr refresh
                white_cross_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_22.started')
                # update status
                white_cross_22.status = STARTED
                white_cross_22.setAutoDraw(True)
            
            # if white_cross_22 is active this frame...
            if white_cross_22.status == STARTED:
                # update params
                pass
            
            # *key_resp_25* updates
            waitOnFlip = False
            
            # if key_resp_25 is starting this frame...
            if key_resp_25.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_25.frameNStart = frameN  # exact frame index
                key_resp_25.tStart = t  # local t and not account for scr refresh
                key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_25.started')
                # update status
                key_resp_25.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_25.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_25.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_25_allKeys.extend(theseKeys)
                if len(_key_resp_25_allKeys):
                    key_resp_25.keys = _key_resp_25_allKeys[-1].name  # just the last key pressed
                    key_resp_25.rt = _key_resp_25_allKeys[-1].rt
                    key_resp_25.duration = _key_resp_25_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_25.keys == str('left')) or (key_resp_25.keys == 'left'):
                        key_resp_25.corr = 1
                    else:
                        key_resp_25.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u* updates
            
            # if arrow_u is starting this frame...
            if arrow_u.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u.frameNStart = frameN  # exact frame index
                arrow_u.tStart = t  # local t and not account for scr refresh
                arrow_u.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u.started')
                # update status
                arrow_u.status = STARTED
                arrow_u.setAutoDraw(True)
            
            # if arrow_u is active this frame...
            if arrow_u.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_3* updates
            
            # if up_whitesquare_3 is starting this frame...
            if up_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_3.frameNStart = frameN  # exact frame index
                up_whitesquare_3.tStart = t  # local t and not account for scr refresh
                up_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_3.started')
                # update status
                up_whitesquare_3.status = STARTED
                up_whitesquare_3.setAutoDraw(True)
            
            # if up_whitesquare_3 is active this frame...
            if up_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_3 is stopping this frame...
            if up_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_3.tStop = t  # not accounting for scr refresh
                    up_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_3.stopped')
                    # update status
                    up_whitesquare_3.status = FINISHED
                    up_whitesquare_3.setAutoDraw(False)
            
            # *down_whitesquare_3* updates
            
            # if down_whitesquare_3 is starting this frame...
            if down_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_3.frameNStart = frameN  # exact frame index
                down_whitesquare_3.tStart = t  # local t and not account for scr refresh
                down_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_3.started')
                # update status
                down_whitesquare_3.status = STARTED
                down_whitesquare_3.setAutoDraw(True)
            
            # if down_whitesquare_3 is active this frame...
            if down_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_3 is stopping this frame...
            if down_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_3.tStop = t  # not accounting for scr refresh
                    down_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_3.stopped')
                    # update status
                    down_whitesquare_3.status = FINISHED
                    down_whitesquare_3.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_up" ---
        for thisComponent in upA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_up
        upA_on_up.tStop = globalClock.getTime(format='float')
        upA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_up.stopped', upA_on_up.tStop)
        # check responses
        if key_resp_25.keys in ['', [], None]:  # No response was made
            key_resp_25.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_25.corr = 1;  # correct non-response
            else:
               key_resp_25.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_25.keys',key_resp_25.keys)
        trials_b1.addData('key_resp_25.corr', key_resp_25.corr)
        if key_resp_25.keys != None:  # we had a response
            trials_b1.addData('key_resp_25.rt', key_resp_25.rt)
            trials_b1.addData('key_resp_25.duration', key_resp_25.duration)
        # the Routine "upA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_up" ---
        # create an object to store info about Routine DOWN_on_up
        DOWN_on_up = data.Routine(
            name='DOWN_on_up',
            components=[blacksquare_15, white_cross_15, key_resp_18, UP, up_whitesquare_4, down_whitesquare_4],
        )
        DOWN_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_18
        key_resp_18.keys = []
        key_resp_18.rt = []
        _key_resp_18_allKeys = []
        # Run 'Begin Routine' code from code_16
        
        
        if currentRoutine != "DOWN_on_up":
            continueRoutine = False
        
        # store start times for DOWN_on_up
        DOWN_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_up.tStart = globalClock.getTime(format='float')
        DOWN_on_up.status = STARTED
        thisExp.addData('DOWN_on_up.started', DOWN_on_up.tStart)
        DOWN_on_up.maxDuration = None
        # keep track of which components have finished
        DOWN_on_upComponents = DOWN_on_up.components
        for thisComponent in DOWN_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_15* updates
            
            # if blacksquare_15 is starting this frame...
            if blacksquare_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_15.frameNStart = frameN  # exact frame index
                blacksquare_15.tStart = t  # local t and not account for scr refresh
                blacksquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_15.started')
                # update status
                blacksquare_15.status = STARTED
                blacksquare_15.setAutoDraw(True)
            
            # if blacksquare_15 is active this frame...
            if blacksquare_15.status == STARTED:
                # update params
                pass
            
            # *white_cross_15* updates
            
            # if white_cross_15 is starting this frame...
            if white_cross_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_15.frameNStart = frameN  # exact frame index
                white_cross_15.tStart = t  # local t and not account for scr refresh
                white_cross_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_15.started')
                # update status
                white_cross_15.status = STARTED
                white_cross_15.setAutoDraw(True)
            
            # if white_cross_15 is active this frame...
            if white_cross_15.status == STARTED:
                # update params
                pass
            
            # *key_resp_18* updates
            waitOnFlip = False
            
            # if key_resp_18 is starting this frame...
            if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_18.frameNStart = frameN  # exact frame index
                key_resp_18.tStart = t  # local t and not account for scr refresh
                key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_18.started')
                # update status
                key_resp_18.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_18.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_18.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_18_allKeys.extend(theseKeys)
                if len(_key_resp_18_allKeys):
                    key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
                    key_resp_18.rt = _key_resp_18_allKeys[-1].rt
                    key_resp_18.duration = _key_resp_18_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_18.keys == str('left')) or (key_resp_18.keys == 'left'):
                        key_resp_18.corr = 1
                    else:
                        key_resp_18.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP* updates
            
            # if UP is starting this frame...
            if UP.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP.frameNStart = frameN  # exact frame index
                UP.tStart = t  # local t and not account for scr refresh
                UP.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP.started')
                # update status
                UP.status = STARTED
                UP.setAutoDraw(True)
            
            # if UP is active this frame...
            if UP.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_4* updates
            
            # if up_whitesquare_4 is starting this frame...
            if up_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_4.frameNStart = frameN  # exact frame index
                up_whitesquare_4.tStart = t  # local t and not account for scr refresh
                up_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_4.started')
                # update status
                up_whitesquare_4.status = STARTED
                up_whitesquare_4.setAutoDraw(True)
            
            # if up_whitesquare_4 is active this frame...
            if up_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_4 is stopping this frame...
            if up_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_4.tStop = t  # not accounting for scr refresh
                    up_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_4.stopped')
                    # update status
                    up_whitesquare_4.status = FINISHED
                    up_whitesquare_4.setAutoDraw(False)
            
            # *down_whitesquare_4* updates
            
            # if down_whitesquare_4 is starting this frame...
            if down_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_4.frameNStart = frameN  # exact frame index
                down_whitesquare_4.tStart = t  # local t and not account for scr refresh
                down_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_4.started')
                # update status
                down_whitesquare_4.status = STARTED
                down_whitesquare_4.setAutoDraw(True)
            
            # if down_whitesquare_4 is active this frame...
            if down_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_4 is stopping this frame...
            if down_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_4.tStop = t  # not accounting for scr refresh
                    down_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_4.stopped')
                    # update status
                    down_whitesquare_4.status = FINISHED
                    down_whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_up" ---
        for thisComponent in DOWN_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_up
        DOWN_on_up.tStop = globalClock.getTime(format='float')
        DOWN_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_up.stopped', DOWN_on_up.tStop)
        # check responses
        if key_resp_18.keys in ['', [], None]:  # No response was made
            key_resp_18.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_18.corr = 1;  # correct non-response
            else:
               key_resp_18.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_18.keys',key_resp_18.keys)
        trials_b1.addData('key_resp_18.corr', key_resp_18.corr)
        if key_resp_18.keys != None:  # we had a response
            trials_b1.addData('key_resp_18.rt', key_resp_18.rt)
            trials_b1.addData('key_resp_18.duration', key_resp_18.duration)
        # the Routine "DOWN_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_up" ---
        # create an object to store info about Routine downA_on_up
        downA_on_up = data.Routine(
            name='downA_on_up',
            components=[blacksquare_25, white_cross_25, key_resp_28, arrow_u_4, up_whitesquare_5, down_whitesquare_5],
        )
        downA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_28
        key_resp_28.keys = []
        key_resp_28.rt = []
        _key_resp_28_allKeys = []
        # Run 'Begin Routine' code from code_17
        
        
        if currentRoutine != "downA_on_up":
            continueRoutine = False
        
        # store start times for downA_on_up
        downA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_up.tStart = globalClock.getTime(format='float')
        downA_on_up.status = STARTED
        thisExp.addData('downA_on_up.started', downA_on_up.tStart)
        downA_on_up.maxDuration = None
        # keep track of which components have finished
        downA_on_upComponents = downA_on_up.components
        for thisComponent in downA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        downA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_25* updates
            
            # if blacksquare_25 is starting this frame...
            if blacksquare_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_25.frameNStart = frameN  # exact frame index
                blacksquare_25.tStart = t  # local t and not account for scr refresh
                blacksquare_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_25.started')
                # update status
                blacksquare_25.status = STARTED
                blacksquare_25.setAutoDraw(True)
            
            # if blacksquare_25 is active this frame...
            if blacksquare_25.status == STARTED:
                # update params
                pass
            
            # *white_cross_25* updates
            
            # if white_cross_25 is starting this frame...
            if white_cross_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_25.frameNStart = frameN  # exact frame index
                white_cross_25.tStart = t  # local t and not account for scr refresh
                white_cross_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_25.started')
                # update status
                white_cross_25.status = STARTED
                white_cross_25.setAutoDraw(True)
            
            # if white_cross_25 is active this frame...
            if white_cross_25.status == STARTED:
                # update params
                pass
            
            # *key_resp_28* updates
            waitOnFlip = False
            
            # if key_resp_28 is starting this frame...
            if key_resp_28.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_28.frameNStart = frameN  # exact frame index
                key_resp_28.tStart = t  # local t and not account for scr refresh
                key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_28.started')
                # update status
                key_resp_28.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_28.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_28.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_28_allKeys.extend(theseKeys)
                if len(_key_resp_28_allKeys):
                    key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
                    key_resp_28.rt = _key_resp_28_allKeys[-1].rt
                    key_resp_28.duration = _key_resp_28_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_28.keys == str('left')) or (key_resp_28.keys == 'left'):
                        key_resp_28.corr = 1
                    else:
                        key_resp_28.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_4* updates
            
            # if arrow_u_4 is starting this frame...
            if arrow_u_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_4.frameNStart = frameN  # exact frame index
                arrow_u_4.tStart = t  # local t and not account for scr refresh
                arrow_u_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_4.started')
                # update status
                arrow_u_4.status = STARTED
                arrow_u_4.setAutoDraw(True)
            
            # if arrow_u_4 is active this frame...
            if arrow_u_4.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_5* updates
            
            # if up_whitesquare_5 is starting this frame...
            if up_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_5.frameNStart = frameN  # exact frame index
                up_whitesquare_5.tStart = t  # local t and not account for scr refresh
                up_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_5.started')
                # update status
                up_whitesquare_5.status = STARTED
                up_whitesquare_5.setAutoDraw(True)
            
            # if up_whitesquare_5 is active this frame...
            if up_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_5 is stopping this frame...
            if up_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_5.tStop = t  # not accounting for scr refresh
                    up_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_5.stopped')
                    # update status
                    up_whitesquare_5.status = FINISHED
                    up_whitesquare_5.setAutoDraw(False)
            
            # *down_whitesquare_5* updates
            
            # if down_whitesquare_5 is starting this frame...
            if down_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_5.frameNStart = frameN  # exact frame index
                down_whitesquare_5.tStart = t  # local t and not account for scr refresh
                down_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_5.started')
                # update status
                down_whitesquare_5.status = STARTED
                down_whitesquare_5.setAutoDraw(True)
            
            # if down_whitesquare_5 is active this frame...
            if down_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_5 is stopping this frame...
            if down_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_5.tStop = t  # not accounting for scr refresh
                    down_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_5.stopped')
                    # update status
                    down_whitesquare_5.status = FINISHED
                    down_whitesquare_5.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_up" ---
        for thisComponent in downA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_up
        downA_on_up.tStop = globalClock.getTime(format='float')
        downA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_up.stopped', downA_on_up.tStop)
        # check responses
        if key_resp_28.keys in ['', [], None]:  # No response was made
            key_resp_28.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_28.corr = 1;  # correct non-response
            else:
               key_resp_28.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_28.keys',key_resp_28.keys)
        trials_b1.addData('key_resp_28.corr', key_resp_28.corr)
        if key_resp_28.keys != None:  # we had a response
            trials_b1.addData('key_resp_28.rt', key_resp_28.rt)
            trials_b1.addData('key_resp_28.duration', key_resp_28.duration)
        # the Routine "downA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_down" ---
        # create an object to store info about Routine UP_on_down
        UP_on_down = data.Routine(
            name='UP_on_down',
            components=[blacksquare_16, white_cross_16, key_resp_19, UP_6, up_whitesquare_6, down_whitesquare_6],
        )
        UP_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_19
        key_resp_19.keys = []
        key_resp_19.rt = []
        _key_resp_19_allKeys = []
        # Run 'Begin Routine' code from code_18
        
        
        if currentRoutine != "UP_on_down":
            continueRoutine = False
        
        # store start times for UP_on_down
        UP_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_down.tStart = globalClock.getTime(format='float')
        UP_on_down.status = STARTED
        thisExp.addData('UP_on_down.started', UP_on_down.tStart)
        UP_on_down.maxDuration = None
        # keep track of which components have finished
        UP_on_downComponents = UP_on_down.components
        for thisComponent in UP_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        UP_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_16* updates
            
            # if blacksquare_16 is starting this frame...
            if blacksquare_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_16.frameNStart = frameN  # exact frame index
                blacksquare_16.tStart = t  # local t and not account for scr refresh
                blacksquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_16.started')
                # update status
                blacksquare_16.status = STARTED
                blacksquare_16.setAutoDraw(True)
            
            # if blacksquare_16 is active this frame...
            if blacksquare_16.status == STARTED:
                # update params
                pass
            
            # *white_cross_16* updates
            
            # if white_cross_16 is starting this frame...
            if white_cross_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_16.frameNStart = frameN  # exact frame index
                white_cross_16.tStart = t  # local t and not account for scr refresh
                white_cross_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_16.started')
                # update status
                white_cross_16.status = STARTED
                white_cross_16.setAutoDraw(True)
            
            # if white_cross_16 is active this frame...
            if white_cross_16.status == STARTED:
                # update params
                pass
            
            # *key_resp_19* updates
            waitOnFlip = False
            
            # if key_resp_19 is starting this frame...
            if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_19.frameNStart = frameN  # exact frame index
                key_resp_19.tStart = t  # local t and not account for scr refresh
                key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_19.started')
                # update status
                key_resp_19.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_19.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_19.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_19_allKeys.extend(theseKeys)
                if len(_key_resp_19_allKeys):
                    key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
                    key_resp_19.rt = _key_resp_19_allKeys[-1].rt
                    key_resp_19.duration = _key_resp_19_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_19.keys == str('left')) or (key_resp_19.keys == 'left'):
                        key_resp_19.corr = 1
                    else:
                        key_resp_19.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_6* updates
            
            # if UP_6 is starting this frame...
            if UP_6.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_6.frameNStart = frameN  # exact frame index
                UP_6.tStart = t  # local t and not account for scr refresh
                UP_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_6.started')
                # update status
                UP_6.status = STARTED
                UP_6.setAutoDraw(True)
            
            # if UP_6 is active this frame...
            if UP_6.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_6* updates
            
            # if up_whitesquare_6 is starting this frame...
            if up_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_6.frameNStart = frameN  # exact frame index
                up_whitesquare_6.tStart = t  # local t and not account for scr refresh
                up_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_6.started')
                # update status
                up_whitesquare_6.status = STARTED
                up_whitesquare_6.setAutoDraw(True)
            
            # if up_whitesquare_6 is active this frame...
            if up_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_6 is stopping this frame...
            if up_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_6.tStop = t  # not accounting for scr refresh
                    up_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_6.stopped')
                    # update status
                    up_whitesquare_6.status = FINISHED
                    up_whitesquare_6.setAutoDraw(False)
            
            # *down_whitesquare_6* updates
            
            # if down_whitesquare_6 is starting this frame...
            if down_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_6.frameNStart = frameN  # exact frame index
                down_whitesquare_6.tStart = t  # local t and not account for scr refresh
                down_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_6.started')
                # update status
                down_whitesquare_6.status = STARTED
                down_whitesquare_6.setAutoDraw(True)
            
            # if down_whitesquare_6 is active this frame...
            if down_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_6 is stopping this frame...
            if down_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_6.tStop = t  # not accounting for scr refresh
                    down_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_6.stopped')
                    # update status
                    down_whitesquare_6.status = FINISHED
                    down_whitesquare_6.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_down" ---
        for thisComponent in UP_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_down
        UP_on_down.tStop = globalClock.getTime(format='float')
        UP_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_down.stopped', UP_on_down.tStop)
        # check responses
        if key_resp_19.keys in ['', [], None]:  # No response was made
            key_resp_19.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_19.corr = 1;  # correct non-response
            else:
               key_resp_19.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_19.keys',key_resp_19.keys)
        trials_b1.addData('key_resp_19.corr', key_resp_19.corr)
        if key_resp_19.keys != None:  # we had a response
            trials_b1.addData('key_resp_19.rt', key_resp_19.rt)
            trials_b1.addData('key_resp_19.duration', key_resp_19.duration)
        # the Routine "UP_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_down" ---
        # create an object to store info about Routine upA_on_down
        upA_on_down = data.Routine(
            name='upA_on_down',
            components=[blacksquare_23, white_cross_23, key_resp_26, arrow_u_2, up_whitesquare_7, down_whitesquare_7],
        )
        upA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_26
        key_resp_26.keys = []
        key_resp_26.rt = []
        _key_resp_26_allKeys = []
        # Run 'Begin Routine' code from code_19
        
        
        if currentRoutine != "upA_on_down":
            continueRoutine = False
        
        # store start times for upA_on_down
        upA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_down.tStart = globalClock.getTime(format='float')
        upA_on_down.status = STARTED
        thisExp.addData('upA_on_down.started', upA_on_down.tStart)
        upA_on_down.maxDuration = None
        # keep track of which components have finished
        upA_on_downComponents = upA_on_down.components
        for thisComponent in upA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        upA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_23* updates
            
            # if blacksquare_23 is starting this frame...
            if blacksquare_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_23.frameNStart = frameN  # exact frame index
                blacksquare_23.tStart = t  # local t and not account for scr refresh
                blacksquare_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_23.started')
                # update status
                blacksquare_23.status = STARTED
                blacksquare_23.setAutoDraw(True)
            
            # if blacksquare_23 is active this frame...
            if blacksquare_23.status == STARTED:
                # update params
                pass
            
            # *white_cross_23* updates
            
            # if white_cross_23 is starting this frame...
            if white_cross_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_23.frameNStart = frameN  # exact frame index
                white_cross_23.tStart = t  # local t and not account for scr refresh
                white_cross_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_23.started')
                # update status
                white_cross_23.status = STARTED
                white_cross_23.setAutoDraw(True)
            
            # if white_cross_23 is active this frame...
            if white_cross_23.status == STARTED:
                # update params
                pass
            
            # *key_resp_26* updates
            waitOnFlip = False
            
            # if key_resp_26 is starting this frame...
            if key_resp_26.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_26.frameNStart = frameN  # exact frame index
                key_resp_26.tStart = t  # local t and not account for scr refresh
                key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_26.started')
                # update status
                key_resp_26.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_26.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_26.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_26_allKeys.extend(theseKeys)
                if len(_key_resp_26_allKeys):
                    key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
                    key_resp_26.rt = _key_resp_26_allKeys[-1].rt
                    key_resp_26.duration = _key_resp_26_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_26.keys == str('left')) or (key_resp_26.keys == 'left'):
                        key_resp_26.corr = 1
                    else:
                        key_resp_26.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_2* updates
            
            # if arrow_u_2 is starting this frame...
            if arrow_u_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_2.frameNStart = frameN  # exact frame index
                arrow_u_2.tStart = t  # local t and not account for scr refresh
                arrow_u_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_2.started')
                # update status
                arrow_u_2.status = STARTED
                arrow_u_2.setAutoDraw(True)
            
            # if arrow_u_2 is active this frame...
            if arrow_u_2.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_7* updates
            
            # if up_whitesquare_7 is starting this frame...
            if up_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_7.frameNStart = frameN  # exact frame index
                up_whitesquare_7.tStart = t  # local t and not account for scr refresh
                up_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_7.started')
                # update status
                up_whitesquare_7.status = STARTED
                up_whitesquare_7.setAutoDraw(True)
            
            # if up_whitesquare_7 is active this frame...
            if up_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_7 is stopping this frame...
            if up_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_7.tStop = t  # not accounting for scr refresh
                    up_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_7.stopped')
                    # update status
                    up_whitesquare_7.status = FINISHED
                    up_whitesquare_7.setAutoDraw(False)
            
            # *down_whitesquare_7* updates
            
            # if down_whitesquare_7 is starting this frame...
            if down_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_7.frameNStart = frameN  # exact frame index
                down_whitesquare_7.tStart = t  # local t and not account for scr refresh
                down_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_7.started')
                # update status
                down_whitesquare_7.status = STARTED
                down_whitesquare_7.setAutoDraw(True)
            
            # if down_whitesquare_7 is active this frame...
            if down_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_7 is stopping this frame...
            if down_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_7.tStop = t  # not accounting for scr refresh
                    down_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_7.stopped')
                    # update status
                    down_whitesquare_7.status = FINISHED
                    down_whitesquare_7.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_down" ---
        for thisComponent in upA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_down
        upA_on_down.tStop = globalClock.getTime(format='float')
        upA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_down.stopped', upA_on_down.tStop)
        # check responses
        if key_resp_26.keys in ['', [], None]:  # No response was made
            key_resp_26.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_26.corr = 1;  # correct non-response
            else:
               key_resp_26.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_26.keys',key_resp_26.keys)
        trials_b1.addData('key_resp_26.corr', key_resp_26.corr)
        if key_resp_26.keys != None:  # we had a response
            trials_b1.addData('key_resp_26.rt', key_resp_26.rt)
            trials_b1.addData('key_resp_26.duration', key_resp_26.duration)
        # the Routine "upA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_down" ---
        # create an object to store info about Routine DOWN_on_down
        DOWN_on_down = data.Routine(
            name='DOWN_on_down',
            components=[blacksquare_17, white_cross_17, key_resp_20, UP_7, up_whitesquare_8, down_whitesquare_8],
        )
        DOWN_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_20
        key_resp_20.keys = []
        key_resp_20.rt = []
        _key_resp_20_allKeys = []
        # Run 'Begin Routine' code from code_20
        
        
        if currentRoutine != "DOWN_on_down":
            continueRoutine = False
        
        # store start times for DOWN_on_down
        DOWN_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_down.tStart = globalClock.getTime(format='float')
        DOWN_on_down.status = STARTED
        thisExp.addData('DOWN_on_down.started', DOWN_on_down.tStart)
        DOWN_on_down.maxDuration = None
        # keep track of which components have finished
        DOWN_on_downComponents = DOWN_on_down.components
        for thisComponent in DOWN_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_17* updates
            
            # if blacksquare_17 is starting this frame...
            if blacksquare_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_17.frameNStart = frameN  # exact frame index
                blacksquare_17.tStart = t  # local t and not account for scr refresh
                blacksquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_17.started')
                # update status
                blacksquare_17.status = STARTED
                blacksquare_17.setAutoDraw(True)
            
            # if blacksquare_17 is active this frame...
            if blacksquare_17.status == STARTED:
                # update params
                pass
            
            # *white_cross_17* updates
            
            # if white_cross_17 is starting this frame...
            if white_cross_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_17.frameNStart = frameN  # exact frame index
                white_cross_17.tStart = t  # local t and not account for scr refresh
                white_cross_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_17.started')
                # update status
                white_cross_17.status = STARTED
                white_cross_17.setAutoDraw(True)
            
            # if white_cross_17 is active this frame...
            if white_cross_17.status == STARTED:
                # update params
                pass
            
            # *key_resp_20* updates
            waitOnFlip = False
            
            # if key_resp_20 is starting this frame...
            if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_20.frameNStart = frameN  # exact frame index
                key_resp_20.tStart = t  # local t and not account for scr refresh
                key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_20.started')
                # update status
                key_resp_20.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_20.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_20.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_20_allKeys.extend(theseKeys)
                if len(_key_resp_20_allKeys):
                    key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
                    key_resp_20.rt = _key_resp_20_allKeys[-1].rt
                    key_resp_20.duration = _key_resp_20_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_20.keys == str('left')) or (key_resp_20.keys == 'left'):
                        key_resp_20.corr = 1
                    else:
                        key_resp_20.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_7* updates
            
            # if UP_7 is starting this frame...
            if UP_7.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_7.frameNStart = frameN  # exact frame index
                UP_7.tStart = t  # local t and not account for scr refresh
                UP_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_7.started')
                # update status
                UP_7.status = STARTED
                UP_7.setAutoDraw(True)
            
            # if UP_7 is active this frame...
            if UP_7.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_8* updates
            
            # if up_whitesquare_8 is starting this frame...
            if up_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_8.frameNStart = frameN  # exact frame index
                up_whitesquare_8.tStart = t  # local t and not account for scr refresh
                up_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_8.started')
                # update status
                up_whitesquare_8.status = STARTED
                up_whitesquare_8.setAutoDraw(True)
            
            # if up_whitesquare_8 is active this frame...
            if up_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_8 is stopping this frame...
            if up_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_8.tStop = t  # not accounting for scr refresh
                    up_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_8.stopped')
                    # update status
                    up_whitesquare_8.status = FINISHED
                    up_whitesquare_8.setAutoDraw(False)
            
            # *down_whitesquare_8* updates
            
            # if down_whitesquare_8 is starting this frame...
            if down_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_8.frameNStart = frameN  # exact frame index
                down_whitesquare_8.tStart = t  # local t and not account for scr refresh
                down_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_8.started')
                # update status
                down_whitesquare_8.status = STARTED
                down_whitesquare_8.setAutoDraw(True)
            
            # if down_whitesquare_8 is active this frame...
            if down_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_8 is stopping this frame...
            if down_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_8.tStop = t  # not accounting for scr refresh
                    down_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_8.stopped')
                    # update status
                    down_whitesquare_8.status = FINISHED
                    down_whitesquare_8.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_down" ---
        for thisComponent in DOWN_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_down
        DOWN_on_down.tStop = globalClock.getTime(format='float')
        DOWN_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_down.stopped', DOWN_on_down.tStop)
        # check responses
        if key_resp_20.keys in ['', [], None]:  # No response was made
            key_resp_20.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_20.corr = 1;  # correct non-response
            else:
               key_resp_20.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_20.keys',key_resp_20.keys)
        trials_b1.addData('key_resp_20.corr', key_resp_20.corr)
        if key_resp_20.keys != None:  # we had a response
            trials_b1.addData('key_resp_20.rt', key_resp_20.rt)
            trials_b1.addData('key_resp_20.duration', key_resp_20.duration)
        # the Routine "DOWN_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_down" ---
        # create an object to store info about Routine downA_on_down
        downA_on_down = data.Routine(
            name='downA_on_down',
            components=[blacksquare_24, white_cross_24, key_resp_27, arrow_u_3, up_whitesquare_9, down_whitesquare_9],
        )
        downA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_27
        key_resp_27.keys = []
        key_resp_27.rt = []
        _key_resp_27_allKeys = []
        # Run 'Begin Routine' code from code_21
        
        
        if currentRoutine != "downA_on_down":
            continueRoutine = False
        
        # store start times for downA_on_down
        downA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_down.tStart = globalClock.getTime(format='float')
        downA_on_down.status = STARTED
        thisExp.addData('downA_on_down.started', downA_on_down.tStart)
        downA_on_down.maxDuration = None
        # keep track of which components have finished
        downA_on_downComponents = downA_on_down.components
        for thisComponent in downA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b1, data.TrialHandler2) and thisTrials_b1.thisN != trials_b1.thisTrial.thisN:
            continueRoutine = False
        downA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_24* updates
            
            # if blacksquare_24 is starting this frame...
            if blacksquare_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_24.frameNStart = frameN  # exact frame index
                blacksquare_24.tStart = t  # local t and not account for scr refresh
                blacksquare_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_24.started')
                # update status
                blacksquare_24.status = STARTED
                blacksquare_24.setAutoDraw(True)
            
            # if blacksquare_24 is active this frame...
            if blacksquare_24.status == STARTED:
                # update params
                pass
            
            # *white_cross_24* updates
            
            # if white_cross_24 is starting this frame...
            if white_cross_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_24.frameNStart = frameN  # exact frame index
                white_cross_24.tStart = t  # local t and not account for scr refresh
                white_cross_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_24.started')
                # update status
                white_cross_24.status = STARTED
                white_cross_24.setAutoDraw(True)
            
            # if white_cross_24 is active this frame...
            if white_cross_24.status == STARTED:
                # update params
                pass
            
            # *key_resp_27* updates
            waitOnFlip = False
            
            # if key_resp_27 is starting this frame...
            if key_resp_27.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_27.frameNStart = frameN  # exact frame index
                key_resp_27.tStart = t  # local t and not account for scr refresh
                key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_27.started')
                # update status
                key_resp_27.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_27.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_27.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_27_allKeys.extend(theseKeys)
                if len(_key_resp_27_allKeys):
                    key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
                    key_resp_27.rt = _key_resp_27_allKeys[-1].rt
                    key_resp_27.duration = _key_resp_27_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_27.keys == str('left')) or (key_resp_27.keys == 'left'):
                        key_resp_27.corr = 1
                    else:
                        key_resp_27.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_3* updates
            
            # if arrow_u_3 is starting this frame...
            if arrow_u_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_3.frameNStart = frameN  # exact frame index
                arrow_u_3.tStart = t  # local t and not account for scr refresh
                arrow_u_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_3.started')
                # update status
                arrow_u_3.status = STARTED
                arrow_u_3.setAutoDraw(True)
            
            # if arrow_u_3 is active this frame...
            if arrow_u_3.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_9* updates
            
            # if up_whitesquare_9 is starting this frame...
            if up_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_9.frameNStart = frameN  # exact frame index
                up_whitesquare_9.tStart = t  # local t and not account for scr refresh
                up_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_9.started')
                # update status
                up_whitesquare_9.status = STARTED
                up_whitesquare_9.setAutoDraw(True)
            
            # if up_whitesquare_9 is active this frame...
            if up_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_9 is stopping this frame...
            if up_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_9.tStop = t  # not accounting for scr refresh
                    up_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_9.stopped')
                    # update status
                    up_whitesquare_9.status = FINISHED
                    up_whitesquare_9.setAutoDraw(False)
            
            # *down_whitesquare_9* updates
            
            # if down_whitesquare_9 is starting this frame...
            if down_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_9.frameNStart = frameN  # exact frame index
                down_whitesquare_9.tStart = t  # local t and not account for scr refresh
                down_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_9.started')
                # update status
                down_whitesquare_9.status = STARTED
                down_whitesquare_9.setAutoDraw(True)
            
            # if down_whitesquare_9 is active this frame...
            if down_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_9 is stopping this frame...
            if down_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_9.tStop = t  # not accounting for scr refresh
                    down_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_9.stopped')
                    # update status
                    down_whitesquare_9.status = FINISHED
                    down_whitesquare_9.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_down" ---
        for thisComponent in downA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_down
        downA_on_down.tStop = globalClock.getTime(format='float')
        downA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_down.stopped', downA_on_down.tStop)
        # check responses
        if key_resp_27.keys in ['', [], None]:  # No response was made
            key_resp_27.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_27.corr = 1;  # correct non-response
            else:
               key_resp_27.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b1 (TrialHandler)
        trials_b1.addData('key_resp_27.keys',key_resp_27.keys)
        trials_b1.addData('key_resp_27.corr', key_resp_27.corr)
        if key_resp_27.keys != None:  # we had a response
            trials_b1.addData('key_resp_27.rt', key_resp_27.rt)
            trials_b1.addData('key_resp_27.duration', key_resp_27.duration)
        # the Routine "downA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 32.0 repeats of 'trials_b1'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "end_block1" ---
    # create an object to store info about Routine end_block1
    end_block1 = data.Routine(
        name='end_block1',
        components=[text_22, text_23, key_resp_29],
    )
    end_block1.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_29
    key_resp_29.keys = []
    key_resp_29.rt = []
    _key_resp_29_allKeys = []
    # store start times for end_block1
    end_block1.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    end_block1.tStart = globalClock.getTime(format='float')
    end_block1.status = STARTED
    thisExp.addData('end_block1.started', end_block1.tStart)
    end_block1.maxDuration = None
    # keep track of which components have finished
    end_block1Components = end_block1.components
    for thisComponent in end_block1.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end_block1" ---
    end_block1.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_22* updates
        
        # if text_22 is starting this frame...
        if text_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_22.frameNStart = frameN  # exact frame index
            text_22.tStart = t  # local t and not account for scr refresh
            text_22.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_22, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_22.started')
            # update status
            text_22.status = STARTED
            text_22.setAutoDraw(True)
        
        # if text_22 is active this frame...
        if text_22.status == STARTED:
            # update params
            pass
        
        # *text_23* updates
        
        # if text_23 is starting this frame...
        if text_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_23.frameNStart = frameN  # exact frame index
            text_23.tStart = t  # local t and not account for scr refresh
            text_23.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_23, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_23.started')
            # update status
            text_23.status = STARTED
            text_23.setAutoDraw(True)
        
        # if text_23 is active this frame...
        if text_23.status == STARTED:
            # update params
            pass
        
        # *key_resp_29* updates
        waitOnFlip = False
        
        # if key_resp_29 is starting this frame...
        if key_resp_29.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_29.frameNStart = frameN  # exact frame index
            key_resp_29.tStart = t  # local t and not account for scr refresh
            key_resp_29.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_29, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_29.started')
            # update status
            key_resp_29.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_29.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_29.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_29.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_29.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_29_allKeys.extend(theseKeys)
            if len(_key_resp_29_allKeys):
                key_resp_29.keys = _key_resp_29_allKeys[-1].name  # just the last key pressed
                key_resp_29.rt = _key_resp_29_allKeys[-1].rt
                key_resp_29.duration = _key_resp_29_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            end_block1.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in end_block1.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end_block1" ---
    for thisComponent in end_block1.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for end_block1
    end_block1.tStop = globalClock.getTime(format='float')
    end_block1.tStopRefresh = tThisFlipGlobal
    thisExp.addData('end_block1.stopped', end_block1.tStop)
    # check responses
    if key_resp_29.keys in ['', [], None]:  # No response was made
        key_resp_29.keys = None
    thisExp.addData('key_resp_29.keys',key_resp_29.keys)
    if key_resp_29.keys != None:  # we had a response
        thisExp.addData('key_resp_29.rt', key_resp_29.rt)
        thisExp.addData('key_resp_29.duration', key_resp_29.duration)
    thisExp.nextEntry()
    # the Routine "end_block1" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "block2" ---
    # create an object to store info about Routine block2
    block2 = data.Routine(
        name='block2',
        components=[text_24],
    )
    block2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for block2
    block2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    block2.tStart = globalClock.getTime(format='float')
    block2.status = STARTED
    thisExp.addData('block2.started', block2.tStart)
    block2.maxDuration = None
    # keep track of which components have finished
    block2Components = block2.components
    for thisComponent in block2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "block2" ---
    block2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 2.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_24* updates
        
        # if text_24 is starting this frame...
        if text_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_24.frameNStart = frameN  # exact frame index
            text_24.tStart = t  # local t and not account for scr refresh
            text_24.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_24, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_24.started')
            # update status
            text_24.status = STARTED
            text_24.setAutoDraw(True)
        
        # if text_24 is active this frame...
        if text_24.status == STARTED:
            # update params
            pass
        
        # if text_24 is stopping this frame...
        if text_24.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_24.tStartRefresh + 2-frameTolerance:
                # keep track of stop time/frame for later
                text_24.tStop = t  # not accounting for scr refresh
                text_24.tStopRefresh = tThisFlipGlobal  # on global time
                text_24.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_24.stopped')
                # update status
                text_24.status = FINISHED
                text_24.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            block2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in block2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "block2" ---
    for thisComponent in block2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for block2
    block2.tStop = globalClock.getTime(format='float')
    block2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('block2.stopped', block2.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if block2.maxDurationReached:
        routineTimer.addTime(-block2.maxDuration)
    elif block2.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-2.000000)
    thisExp.nextEntry()
    
    # set up handler to look after randomisation of conditions etc
    trials_b2 = data.TrialHandler2(
        name='trials_b2',
        nReps=32.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(trials_b2)  # add the loop to the experiment
    thisTrials_b2 = trials_b2.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_b2.rgb)
    if thisTrials_b2 != None:
        for paramName in thisTrials_b2:
            globals()[paramName] = thisTrials_b2[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_b2 in trials_b2:
        currentLoop = trials_b2
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_b2.rgb)
        if thisTrials_b2 != None:
            for paramName in thisTrials_b2:
                globals()[paramName] = thisTrials_b2[paramName]
        
        # --- Prepare to start Routine "block2_router" ---
        # create an object to store info about Routine block2_router
        block2_router = data.Routine(
            name='block2_router',
            components=[],
        )
        block2_router.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_22
        selected_routine = random.choice(all_routines)
        
        
        
        # store start times for block2_router
        block2_router.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        block2_router.tStart = globalClock.getTime(format='float')
        block2_router.status = STARTED
        thisExp.addData('block2_router.started', block2_router.tStart)
        block2_router.maxDuration = None
        # keep track of which components have finished
        block2_routerComponents = block2_router.components
        for thisComponent in block2_router.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "block2_router" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        block2_router.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                block2_router.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in block2_router.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "block2_router" ---
        for thisComponent in block2_router.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for block2_router
        block2_router.tStop = globalClock.getTime(format='float')
        block2_router.tStopRefresh = tThisFlipGlobal
        thisExp.addData('block2_router.stopped', block2_router.tStop)
        # Run 'End Routine' code from code_22
        
        
        # the Routine "block2_router" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_right" ---
        # create an object to store info about Routine LEFT_on_right
        LEFT_on_right = data.Routine(
            name='LEFT_on_right',
            components=[blacksquare_10, white_cross_10, key_resp_13, LEFT_2, whitesquare_3, whitesquare_4],
        )
        LEFT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_13
        key_resp_13.keys = []
        key_resp_13.rt = []
        _key_resp_13_allKeys = []
        # Run 'Begin Routine' code from code_6
        if currentRoutine != "LEFT_on_right":
            continueRoutine = False
        
        # store start times for LEFT_on_right
        LEFT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_right.tStart = globalClock.getTime(format='float')
        LEFT_on_right.status = STARTED
        thisExp.addData('LEFT_on_right.started', LEFT_on_right.tStart)
        LEFT_on_right.maxDuration = None
        # keep track of which components have finished
        LEFT_on_rightComponents = LEFT_on_right.components
        for thisComponent in LEFT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_10* updates
            
            # if blacksquare_10 is starting this frame...
            if blacksquare_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_10.frameNStart = frameN  # exact frame index
                blacksquare_10.tStart = t  # local t and not account for scr refresh
                blacksquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_10.started')
                # update status
                blacksquare_10.status = STARTED
                blacksquare_10.setAutoDraw(True)
            
            # if blacksquare_10 is active this frame...
            if blacksquare_10.status == STARTED:
                # update params
                pass
            
            # *white_cross_10* updates
            
            # if white_cross_10 is starting this frame...
            if white_cross_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                white_cross_10.frameNStart = frameN  # exact frame index
                white_cross_10.tStart = t  # local t and not account for scr refresh
                white_cross_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_10.started')
                # update status
                white_cross_10.status = STARTED
                white_cross_10.setAutoDraw(True)
            
            # if white_cross_10 is active this frame...
            if white_cross_10.status == STARTED:
                # update params
                pass
            
            # *key_resp_13* updates
            waitOnFlip = False
            
            # if key_resp_13 is starting this frame...
            if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_13.frameNStart = frameN  # exact frame index
                key_resp_13.tStart = t  # local t and not account for scr refresh
                key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_13.started')
                # update status
                key_resp_13.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_13.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_13.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_13_allKeys.extend(theseKeys)
                if len(_key_resp_13_allKeys):
                    key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
                    key_resp_13.rt = _key_resp_13_allKeys[-1].rt
                    key_resp_13.duration = _key_resp_13_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_13.keys == str('left')) or (key_resp_13.keys == 'left'):
                        key_resp_13.corr = 1
                    else:
                        key_resp_13.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_2* updates
            
            # if LEFT_2 is starting this frame...
            if LEFT_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_2.frameNStart = frameN  # exact frame index
                LEFT_2.tStart = t  # local t and not account for scr refresh
                LEFT_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_2.started')
                # update status
                LEFT_2.status = STARTED
                LEFT_2.setAutoDraw(True)
            
            # if LEFT_2 is active this frame...
            if LEFT_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_3* updates
            
            # if whitesquare_3 is starting this frame...
            if whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_3.frameNStart = frameN  # exact frame index
                whitesquare_3.tStart = t  # local t and not account for scr refresh
                whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_3.started')
                # update status
                whitesquare_3.status = STARTED
                whitesquare_3.setAutoDraw(True)
            
            # if whitesquare_3 is active this frame...
            if whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if whitesquare_3 is stopping this frame...
            if whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_3.tStop = t  # not accounting for scr refresh
                    whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_3.stopped')
                    # update status
                    whitesquare_3.status = FINISHED
                    whitesquare_3.setAutoDraw(False)
            
            # *whitesquare_4* updates
            
            # if whitesquare_4 is starting this frame...
            if whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_4.frameNStart = frameN  # exact frame index
                whitesquare_4.tStart = t  # local t and not account for scr refresh
                whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_4.started')
                # update status
                whitesquare_4.status = STARTED
                whitesquare_4.setAutoDraw(True)
            
            # if whitesquare_4 is active this frame...
            if whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if whitesquare_4 is stopping this frame...
            if whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_4.tStop = t  # not accounting for scr refresh
                    whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_4.stopped')
                    # update status
                    whitesquare_4.status = FINISHED
                    whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_right" ---
        for thisComponent in LEFT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_right
        LEFT_on_right.tStop = globalClock.getTime(format='float')
        LEFT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_right.stopped', LEFT_on_right.tStop)
        # check responses
        if key_resp_13.keys in ['', [], None]:  # No response was made
            key_resp_13.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_13.corr = 1;  # correct non-response
            else:
               key_resp_13.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_13.keys',key_resp_13.keys)
        trials_b2.addData('key_resp_13.corr', key_resp_13.corr)
        if key_resp_13.keys != None:  # we had a response
            trials_b2.addData('key_resp_13.rt', key_resp_13.rt)
            trials_b2.addData('key_resp_13.duration', key_resp_13.duration)
        # the Routine "LEFT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_right" ---
        # create an object to store info about Routine RIGHT_on_right
        RIGHT_on_right = data.Routine(
            name='RIGHT_on_right',
            components=[blacksquare_11, white_cross_11, key_resp_14, RIGHT_3, whitesquare_10, whitesquare_17],
        )
        RIGHT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_14
        key_resp_14.keys = []
        key_resp_14.rt = []
        _key_resp_14_allKeys = []
        # Run 'Begin Routine' code from code_12
        if currentRoutine != "RIGHT_on_right":
            continueRoutine = False
        
        # store start times for RIGHT_on_right
        RIGHT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_right.tStart = globalClock.getTime(format='float')
        RIGHT_on_right.status = STARTED
        thisExp.addData('RIGHT_on_right.started', RIGHT_on_right.tStart)
        RIGHT_on_right.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_rightComponents = RIGHT_on_right.components
        for thisComponent in RIGHT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_11* updates
            
            # if blacksquare_11 is starting this frame...
            if blacksquare_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_11.frameNStart = frameN  # exact frame index
                blacksquare_11.tStart = t  # local t and not account for scr refresh
                blacksquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_11.started')
                # update status
                blacksquare_11.status = STARTED
                blacksquare_11.setAutoDraw(True)
            
            # if blacksquare_11 is active this frame...
            if blacksquare_11.status == STARTED:
                # update params
                pass
            
            # *white_cross_11* updates
            
            # if white_cross_11 is starting this frame...
            if white_cross_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_11.frameNStart = frameN  # exact frame index
                white_cross_11.tStart = t  # local t and not account for scr refresh
                white_cross_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_11.started')
                # update status
                white_cross_11.status = STARTED
                white_cross_11.setAutoDraw(True)
            
            # if white_cross_11 is active this frame...
            if white_cross_11.status == STARTED:
                # update params
                pass
            
            # *key_resp_14* updates
            waitOnFlip = False
            
            # if key_resp_14 is starting this frame...
            if key_resp_14.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_14.frameNStart = frameN  # exact frame index
                key_resp_14.tStart = t  # local t and not account for scr refresh
                key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_14.started')
                # update status
                key_resp_14.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_14.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_14.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_14_allKeys.extend(theseKeys)
                if len(_key_resp_14_allKeys):
                    key_resp_14.keys = _key_resp_14_allKeys[-1].name  # just the last key pressed
                    key_resp_14.rt = _key_resp_14_allKeys[-1].rt
                    key_resp_14.duration = _key_resp_14_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_14.keys == str('left')) or (key_resp_14.keys == 'left'):
                        key_resp_14.corr = 1
                    else:
                        key_resp_14.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_3* updates
            
            # if RIGHT_3 is starting this frame...
            if RIGHT_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_3.frameNStart = frameN  # exact frame index
                RIGHT_3.tStart = t  # local t and not account for scr refresh
                RIGHT_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_3.started')
                # update status
                RIGHT_3.status = STARTED
                RIGHT_3.setAutoDraw(True)
            
            # if RIGHT_3 is active this frame...
            if RIGHT_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_10* updates
            
            # if whitesquare_10 is starting this frame...
            if whitesquare_10.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_10.frameNStart = frameN  # exact frame index
                whitesquare_10.tStart = t  # local t and not account for scr refresh
                whitesquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_10.started')
                # update status
                whitesquare_10.status = STARTED
                whitesquare_10.setAutoDraw(True)
            
            # if whitesquare_10 is active this frame...
            if whitesquare_10.status == STARTED:
                # update params
                pass
            
            # if whitesquare_10 is stopping this frame...
            if whitesquare_10.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_10.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_10.tStop = t  # not accounting for scr refresh
                    whitesquare_10.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_10.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_10.stopped')
                    # update status
                    whitesquare_10.status = FINISHED
                    whitesquare_10.setAutoDraw(False)
            
            # *whitesquare_17* updates
            
            # if whitesquare_17 is starting this frame...
            if whitesquare_17.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_17.frameNStart = frameN  # exact frame index
                whitesquare_17.tStart = t  # local t and not account for scr refresh
                whitesquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_17.started')
                # update status
                whitesquare_17.status = STARTED
                whitesquare_17.setAutoDraw(True)
            
            # if whitesquare_17 is active this frame...
            if whitesquare_17.status == STARTED:
                # update params
                pass
            
            # if whitesquare_17 is stopping this frame...
            if whitesquare_17.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_17.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_17.tStop = t  # not accounting for scr refresh
                    whitesquare_17.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_17.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_17.stopped')
                    # update status
                    whitesquare_17.status = FINISHED
                    whitesquare_17.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_right" ---
        for thisComponent in RIGHT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_right
        RIGHT_on_right.tStop = globalClock.getTime(format='float')
        RIGHT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_right.stopped', RIGHT_on_right.tStop)
        # check responses
        if key_resp_14.keys in ['', [], None]:  # No response was made
            key_resp_14.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_14.corr = 1;  # correct non-response
            else:
               key_resp_14.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_14.keys',key_resp_14.keys)
        trials_b2.addData('key_resp_14.corr', key_resp_14.corr)
        if key_resp_14.keys != None:  # we had a response
            trials_b2.addData('key_resp_14.rt', key_resp_14.rt)
            trials_b2.addData('key_resp_14.duration', key_resp_14.duration)
        # the Routine "RIGHT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_left" ---
        # create an object to store info about Routine LEFT_on_left
        LEFT_on_left = data.Routine(
            name='LEFT_on_left',
            components=[blacksquare_12, white_cross_12, key_resp_15, LEFT_4, whitesquare_6, whitesquare_13],
        )
        LEFT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_15
        key_resp_15.keys = []
        key_resp_15.rt = []
        _key_resp_15_allKeys = []
        # Run 'Begin Routine' code from code_8
        
        
        if currentRoutine != "LEFT_on_left":
            continueRoutine = False
        
        # store start times for LEFT_on_left
        LEFT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_left.tStart = globalClock.getTime(format='float')
        LEFT_on_left.status = STARTED
        thisExp.addData('LEFT_on_left.started', LEFT_on_left.tStart)
        LEFT_on_left.maxDuration = None
        # keep track of which components have finished
        LEFT_on_leftComponents = LEFT_on_left.components
        for thisComponent in LEFT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_12* updates
            
            # if blacksquare_12 is starting this frame...
            if blacksquare_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_12.frameNStart = frameN  # exact frame index
                blacksquare_12.tStart = t  # local t and not account for scr refresh
                blacksquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_12.started')
                # update status
                blacksquare_12.status = STARTED
                blacksquare_12.setAutoDraw(True)
            
            # if blacksquare_12 is active this frame...
            if blacksquare_12.status == STARTED:
                # update params
                pass
            
            # *white_cross_12* updates
            
            # if white_cross_12 is starting this frame...
            if white_cross_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_12.frameNStart = frameN  # exact frame index
                white_cross_12.tStart = t  # local t and not account for scr refresh
                white_cross_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_12.started')
                # update status
                white_cross_12.status = STARTED
                white_cross_12.setAutoDraw(True)
            
            # if white_cross_12 is active this frame...
            if white_cross_12.status == STARTED:
                # update params
                pass
            
            # *key_resp_15* updates
            waitOnFlip = False
            
            # if key_resp_15 is starting this frame...
            if key_resp_15.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_15.frameNStart = frameN  # exact frame index
                key_resp_15.tStart = t  # local t and not account for scr refresh
                key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_15.started')
                # update status
                key_resp_15.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_15.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_15.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_15_allKeys.extend(theseKeys)
                if len(_key_resp_15_allKeys):
                    key_resp_15.keys = _key_resp_15_allKeys[-1].name  # just the last key pressed
                    key_resp_15.rt = _key_resp_15_allKeys[-1].rt
                    key_resp_15.duration = _key_resp_15_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_15.keys == str('left')) or (key_resp_15.keys == 'left'):
                        key_resp_15.corr = 1
                    else:
                        key_resp_15.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_4* updates
            
            # if LEFT_4 is starting this frame...
            if LEFT_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_4.frameNStart = frameN  # exact frame index
                LEFT_4.tStart = t  # local t and not account for scr refresh
                LEFT_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_4.started')
                # update status
                LEFT_4.status = STARTED
                LEFT_4.setAutoDraw(True)
            
            # if LEFT_4 is active this frame...
            if LEFT_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_6* updates
            
            # if whitesquare_6 is starting this frame...
            if whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_6.frameNStart = frameN  # exact frame index
                whitesquare_6.tStart = t  # local t and not account for scr refresh
                whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_6.started')
                # update status
                whitesquare_6.status = STARTED
                whitesquare_6.setAutoDraw(True)
            
            # if whitesquare_6 is active this frame...
            if whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if whitesquare_6 is stopping this frame...
            if whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_6.tStop = t  # not accounting for scr refresh
                    whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_6.stopped')
                    # update status
                    whitesquare_6.status = FINISHED
                    whitesquare_6.setAutoDraw(False)
            
            # *whitesquare_13* updates
            
            # if whitesquare_13 is starting this frame...
            if whitesquare_13.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_13.frameNStart = frameN  # exact frame index
                whitesquare_13.tStart = t  # local t and not account for scr refresh
                whitesquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_13.started')
                # update status
                whitesquare_13.status = STARTED
                whitesquare_13.setAutoDraw(True)
            
            # if whitesquare_13 is active this frame...
            if whitesquare_13.status == STARTED:
                # update params
                pass
            
            # if whitesquare_13 is stopping this frame...
            if whitesquare_13.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_13.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_13.tStop = t  # not accounting for scr refresh
                    whitesquare_13.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_13.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_13.stopped')
                    # update status
                    whitesquare_13.status = FINISHED
                    whitesquare_13.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_left" ---
        for thisComponent in LEFT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_left
        LEFT_on_left.tStop = globalClock.getTime(format='float')
        LEFT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_left.stopped', LEFT_on_left.tStop)
        # check responses
        if key_resp_15.keys in ['', [], None]:  # No response was made
            key_resp_15.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_15.corr = 1;  # correct non-response
            else:
               key_resp_15.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_15.keys',key_resp_15.keys)
        trials_b2.addData('key_resp_15.corr', key_resp_15.corr)
        if key_resp_15.keys != None:  # we had a response
            trials_b2.addData('key_resp_15.rt', key_resp_15.rt)
            trials_b2.addData('key_resp_15.duration', key_resp_15.duration)
        # the Routine "LEFT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_left" ---
        # create an object to store info about Routine RIGHT_on_left
        RIGHT_on_left = data.Routine(
            name='RIGHT_on_left',
            components=[blacksquare_13, white_cross_13, key_resp_16, RIGHT_5, whitesquare_8, whitesquare_15],
        )
        RIGHT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_16
        key_resp_16.keys = []
        key_resp_16.rt = []
        _key_resp_16_allKeys = []
        # Run 'Begin Routine' code from code_10
        
        if currentRoutine != "RIGHT_on_left":
            continueRoutine = False
        
        # store start times for RIGHT_on_left
        RIGHT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_left.tStart = globalClock.getTime(format='float')
        RIGHT_on_left.status = STARTED
        thisExp.addData('RIGHT_on_left.started', RIGHT_on_left.tStart)
        RIGHT_on_left.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_leftComponents = RIGHT_on_left.components
        for thisComponent in RIGHT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_13* updates
            
            # if blacksquare_13 is starting this frame...
            if blacksquare_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_13.frameNStart = frameN  # exact frame index
                blacksquare_13.tStart = t  # local t and not account for scr refresh
                blacksquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_13.started')
                # update status
                blacksquare_13.status = STARTED
                blacksquare_13.setAutoDraw(True)
            
            # if blacksquare_13 is active this frame...
            if blacksquare_13.status == STARTED:
                # update params
                pass
            
            # *white_cross_13* updates
            
            # if white_cross_13 is starting this frame...
            if white_cross_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_13.frameNStart = frameN  # exact frame index
                white_cross_13.tStart = t  # local t and not account for scr refresh
                white_cross_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_13.started')
                # update status
                white_cross_13.status = STARTED
                white_cross_13.setAutoDraw(True)
            
            # if white_cross_13 is active this frame...
            if white_cross_13.status == STARTED:
                # update params
                pass
            
            # *key_resp_16* updates
            waitOnFlip = False
            
            # if key_resp_16 is starting this frame...
            if key_resp_16.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_16.frameNStart = frameN  # exact frame index
                key_resp_16.tStart = t  # local t and not account for scr refresh
                key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_16.started')
                # update status
                key_resp_16.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_16.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_16.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_16_allKeys.extend(theseKeys)
                if len(_key_resp_16_allKeys):
                    key_resp_16.keys = _key_resp_16_allKeys[-1].name  # just the last key pressed
                    key_resp_16.rt = _key_resp_16_allKeys[-1].rt
                    key_resp_16.duration = _key_resp_16_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_16.keys == str('left')) or (key_resp_16.keys == 'left'):
                        key_resp_16.corr = 1
                    else:
                        key_resp_16.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_5* updates
            
            # if RIGHT_5 is starting this frame...
            if RIGHT_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_5.frameNStart = frameN  # exact frame index
                RIGHT_5.tStart = t  # local t and not account for scr refresh
                RIGHT_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_5.started')
                # update status
                RIGHT_5.status = STARTED
                RIGHT_5.setAutoDraw(True)
            
            # if RIGHT_5 is active this frame...
            if RIGHT_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_8* updates
            
            # if whitesquare_8 is starting this frame...
            if whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_8.frameNStart = frameN  # exact frame index
                whitesquare_8.tStart = t  # local t and not account for scr refresh
                whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_8.started')
                # update status
                whitesquare_8.status = STARTED
                whitesquare_8.setAutoDraw(True)
            
            # if whitesquare_8 is active this frame...
            if whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if whitesquare_8 is stopping this frame...
            if whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_8.tStop = t  # not accounting for scr refresh
                    whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_8.stopped')
                    # update status
                    whitesquare_8.status = FINISHED
                    whitesquare_8.setAutoDraw(False)
            
            # *whitesquare_15* updates
            
            # if whitesquare_15 is starting this frame...
            if whitesquare_15.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_15.frameNStart = frameN  # exact frame index
                whitesquare_15.tStart = t  # local t and not account for scr refresh
                whitesquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_15.started')
                # update status
                whitesquare_15.status = STARTED
                whitesquare_15.setAutoDraw(True)
            
            # if whitesquare_15 is active this frame...
            if whitesquare_15.status == STARTED:
                # update params
                pass
            
            # if whitesquare_15 is stopping this frame...
            if whitesquare_15.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_15.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_15.tStop = t  # not accounting for scr refresh
                    whitesquare_15.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_15.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_15.stopped')
                    # update status
                    whitesquare_15.status = FINISHED
                    whitesquare_15.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_left" ---
        for thisComponent in RIGHT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_left
        RIGHT_on_left.tStop = globalClock.getTime(format='float')
        RIGHT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_left.stopped', RIGHT_on_left.tStop)
        # check responses
        if key_resp_16.keys in ['', [], None]:  # No response was made
            key_resp_16.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_16.corr = 1;  # correct non-response
            else:
               key_resp_16.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_16.keys',key_resp_16.keys)
        trials_b2.addData('key_resp_16.corr', key_resp_16.corr)
        if key_resp_16.keys != None:  # we had a response
            trials_b2.addData('key_resp_16.rt', key_resp_16.rt)
            trials_b2.addData('key_resp_16.duration', key_resp_16.duration)
        # the Routine "RIGHT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_up" ---
        # create an object to store info about Routine UP_on_up
        UP_on_up = data.Routine(
            name='UP_on_up',
            components=[blacksquare_14, white_cross_14, key_resp_17, UP_5, up_whitesquare_2, down_whitesquare_2],
        )
        UP_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_17
        key_resp_17.keys = []
        key_resp_17.rt = []
        _key_resp_17_allKeys = []
        # Run 'Begin Routine' code from code_14
        
        if currentRoutine != "UP_on_up":
            continueRoutine = False
        
        # store start times for UP_on_up
        UP_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_up.tStart = globalClock.getTime(format='float')
        UP_on_up.status = STARTED
        thisExp.addData('UP_on_up.started', UP_on_up.tStart)
        UP_on_up.maxDuration = None
        # keep track of which components have finished
        UP_on_upComponents = UP_on_up.components
        for thisComponent in UP_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        UP_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_14* updates
            
            # if blacksquare_14 is starting this frame...
            if blacksquare_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_14.frameNStart = frameN  # exact frame index
                blacksquare_14.tStart = t  # local t and not account for scr refresh
                blacksquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_14.started')
                # update status
                blacksquare_14.status = STARTED
                blacksquare_14.setAutoDraw(True)
            
            # if blacksquare_14 is active this frame...
            if blacksquare_14.status == STARTED:
                # update params
                pass
            
            # *white_cross_14* updates
            
            # if white_cross_14 is starting this frame...
            if white_cross_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_14.frameNStart = frameN  # exact frame index
                white_cross_14.tStart = t  # local t and not account for scr refresh
                white_cross_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_14.started')
                # update status
                white_cross_14.status = STARTED
                white_cross_14.setAutoDraw(True)
            
            # if white_cross_14 is active this frame...
            if white_cross_14.status == STARTED:
                # update params
                pass
            
            # *key_resp_17* updates
            waitOnFlip = False
            
            # if key_resp_17 is starting this frame...
            if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_17.frameNStart = frameN  # exact frame index
                key_resp_17.tStart = t  # local t and not account for scr refresh
                key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_17.started')
                # update status
                key_resp_17.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_17.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_17.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_17_allKeys.extend(theseKeys)
                if len(_key_resp_17_allKeys):
                    key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
                    key_resp_17.rt = _key_resp_17_allKeys[-1].rt
                    key_resp_17.duration = _key_resp_17_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_17.keys == str('left')) or (key_resp_17.keys == 'left'):
                        key_resp_17.corr = 1
                    else:
                        key_resp_17.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_5* updates
            
            # if UP_5 is starting this frame...
            if UP_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_5.frameNStart = frameN  # exact frame index
                UP_5.tStart = t  # local t and not account for scr refresh
                UP_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_5.started')
                # update status
                UP_5.status = STARTED
                UP_5.setAutoDraw(True)
            
            # if UP_5 is active this frame...
            if UP_5.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_2* updates
            
            # if up_whitesquare_2 is starting this frame...
            if up_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_2.frameNStart = frameN  # exact frame index
                up_whitesquare_2.tStart = t  # local t and not account for scr refresh
                up_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_2.started')
                # update status
                up_whitesquare_2.status = STARTED
                up_whitesquare_2.setAutoDraw(True)
            
            # if up_whitesquare_2 is active this frame...
            if up_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_2 is stopping this frame...
            if up_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_2.tStop = t  # not accounting for scr refresh
                    up_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_2.stopped')
                    # update status
                    up_whitesquare_2.status = FINISHED
                    up_whitesquare_2.setAutoDraw(False)
            
            # *down_whitesquare_2* updates
            
            # if down_whitesquare_2 is starting this frame...
            if down_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_2.frameNStart = frameN  # exact frame index
                down_whitesquare_2.tStart = t  # local t and not account for scr refresh
                down_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_2.started')
                # update status
                down_whitesquare_2.status = STARTED
                down_whitesquare_2.setAutoDraw(True)
            
            # if down_whitesquare_2 is active this frame...
            if down_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_2 is stopping this frame...
            if down_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_2.tStop = t  # not accounting for scr refresh
                    down_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_2.stopped')
                    # update status
                    down_whitesquare_2.status = FINISHED
                    down_whitesquare_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_up" ---
        for thisComponent in UP_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_up
        UP_on_up.tStop = globalClock.getTime(format='float')
        UP_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_up.stopped', UP_on_up.tStop)
        # check responses
        if key_resp_17.keys in ['', [], None]:  # No response was made
            key_resp_17.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_17.corr = 1;  # correct non-response
            else:
               key_resp_17.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_17.keys',key_resp_17.keys)
        trials_b2.addData('key_resp_17.corr', key_resp_17.corr)
        if key_resp_17.keys != None:  # we had a response
            trials_b2.addData('key_resp_17.rt', key_resp_17.rt)
            trials_b2.addData('key_resp_17.duration', key_resp_17.duration)
        # the Routine "UP_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_up" ---
        # create an object to store info about Routine DOWN_on_up
        DOWN_on_up = data.Routine(
            name='DOWN_on_up',
            components=[blacksquare_15, white_cross_15, key_resp_18, UP, up_whitesquare_4, down_whitesquare_4],
        )
        DOWN_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_18
        key_resp_18.keys = []
        key_resp_18.rt = []
        _key_resp_18_allKeys = []
        # Run 'Begin Routine' code from code_16
        
        
        if currentRoutine != "DOWN_on_up":
            continueRoutine = False
        
        # store start times for DOWN_on_up
        DOWN_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_up.tStart = globalClock.getTime(format='float')
        DOWN_on_up.status = STARTED
        thisExp.addData('DOWN_on_up.started', DOWN_on_up.tStart)
        DOWN_on_up.maxDuration = None
        # keep track of which components have finished
        DOWN_on_upComponents = DOWN_on_up.components
        for thisComponent in DOWN_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_15* updates
            
            # if blacksquare_15 is starting this frame...
            if blacksquare_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_15.frameNStart = frameN  # exact frame index
                blacksquare_15.tStart = t  # local t and not account for scr refresh
                blacksquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_15.started')
                # update status
                blacksquare_15.status = STARTED
                blacksquare_15.setAutoDraw(True)
            
            # if blacksquare_15 is active this frame...
            if blacksquare_15.status == STARTED:
                # update params
                pass
            
            # *white_cross_15* updates
            
            # if white_cross_15 is starting this frame...
            if white_cross_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_15.frameNStart = frameN  # exact frame index
                white_cross_15.tStart = t  # local t and not account for scr refresh
                white_cross_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_15.started')
                # update status
                white_cross_15.status = STARTED
                white_cross_15.setAutoDraw(True)
            
            # if white_cross_15 is active this frame...
            if white_cross_15.status == STARTED:
                # update params
                pass
            
            # *key_resp_18* updates
            waitOnFlip = False
            
            # if key_resp_18 is starting this frame...
            if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_18.frameNStart = frameN  # exact frame index
                key_resp_18.tStart = t  # local t and not account for scr refresh
                key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_18.started')
                # update status
                key_resp_18.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_18.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_18.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_18_allKeys.extend(theseKeys)
                if len(_key_resp_18_allKeys):
                    key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
                    key_resp_18.rt = _key_resp_18_allKeys[-1].rt
                    key_resp_18.duration = _key_resp_18_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_18.keys == str('left')) or (key_resp_18.keys == 'left'):
                        key_resp_18.corr = 1
                    else:
                        key_resp_18.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP* updates
            
            # if UP is starting this frame...
            if UP.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP.frameNStart = frameN  # exact frame index
                UP.tStart = t  # local t and not account for scr refresh
                UP.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP.started')
                # update status
                UP.status = STARTED
                UP.setAutoDraw(True)
            
            # if UP is active this frame...
            if UP.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_4* updates
            
            # if up_whitesquare_4 is starting this frame...
            if up_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_4.frameNStart = frameN  # exact frame index
                up_whitesquare_4.tStart = t  # local t and not account for scr refresh
                up_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_4.started')
                # update status
                up_whitesquare_4.status = STARTED
                up_whitesquare_4.setAutoDraw(True)
            
            # if up_whitesquare_4 is active this frame...
            if up_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_4 is stopping this frame...
            if up_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_4.tStop = t  # not accounting for scr refresh
                    up_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_4.stopped')
                    # update status
                    up_whitesquare_4.status = FINISHED
                    up_whitesquare_4.setAutoDraw(False)
            
            # *down_whitesquare_4* updates
            
            # if down_whitesquare_4 is starting this frame...
            if down_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_4.frameNStart = frameN  # exact frame index
                down_whitesquare_4.tStart = t  # local t and not account for scr refresh
                down_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_4.started')
                # update status
                down_whitesquare_4.status = STARTED
                down_whitesquare_4.setAutoDraw(True)
            
            # if down_whitesquare_4 is active this frame...
            if down_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_4 is stopping this frame...
            if down_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_4.tStop = t  # not accounting for scr refresh
                    down_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_4.stopped')
                    # update status
                    down_whitesquare_4.status = FINISHED
                    down_whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_up" ---
        for thisComponent in DOWN_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_up
        DOWN_on_up.tStop = globalClock.getTime(format='float')
        DOWN_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_up.stopped', DOWN_on_up.tStop)
        # check responses
        if key_resp_18.keys in ['', [], None]:  # No response was made
            key_resp_18.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_18.corr = 1;  # correct non-response
            else:
               key_resp_18.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_18.keys',key_resp_18.keys)
        trials_b2.addData('key_resp_18.corr', key_resp_18.corr)
        if key_resp_18.keys != None:  # we had a response
            trials_b2.addData('key_resp_18.rt', key_resp_18.rt)
            trials_b2.addData('key_resp_18.duration', key_resp_18.duration)
        # the Routine "DOWN_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_down" ---
        # create an object to store info about Routine UP_on_down
        UP_on_down = data.Routine(
            name='UP_on_down',
            components=[blacksquare_16, white_cross_16, key_resp_19, UP_6, up_whitesquare_6, down_whitesquare_6],
        )
        UP_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_19
        key_resp_19.keys = []
        key_resp_19.rt = []
        _key_resp_19_allKeys = []
        # Run 'Begin Routine' code from code_18
        
        
        if currentRoutine != "UP_on_down":
            continueRoutine = False
        
        # store start times for UP_on_down
        UP_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_down.tStart = globalClock.getTime(format='float')
        UP_on_down.status = STARTED
        thisExp.addData('UP_on_down.started', UP_on_down.tStart)
        UP_on_down.maxDuration = None
        # keep track of which components have finished
        UP_on_downComponents = UP_on_down.components
        for thisComponent in UP_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        UP_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_16* updates
            
            # if blacksquare_16 is starting this frame...
            if blacksquare_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_16.frameNStart = frameN  # exact frame index
                blacksquare_16.tStart = t  # local t and not account for scr refresh
                blacksquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_16.started')
                # update status
                blacksquare_16.status = STARTED
                blacksquare_16.setAutoDraw(True)
            
            # if blacksquare_16 is active this frame...
            if blacksquare_16.status == STARTED:
                # update params
                pass
            
            # *white_cross_16* updates
            
            # if white_cross_16 is starting this frame...
            if white_cross_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_16.frameNStart = frameN  # exact frame index
                white_cross_16.tStart = t  # local t and not account for scr refresh
                white_cross_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_16.started')
                # update status
                white_cross_16.status = STARTED
                white_cross_16.setAutoDraw(True)
            
            # if white_cross_16 is active this frame...
            if white_cross_16.status == STARTED:
                # update params
                pass
            
            # *key_resp_19* updates
            waitOnFlip = False
            
            # if key_resp_19 is starting this frame...
            if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_19.frameNStart = frameN  # exact frame index
                key_resp_19.tStart = t  # local t and not account for scr refresh
                key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_19.started')
                # update status
                key_resp_19.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_19.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_19.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_19_allKeys.extend(theseKeys)
                if len(_key_resp_19_allKeys):
                    key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
                    key_resp_19.rt = _key_resp_19_allKeys[-1].rt
                    key_resp_19.duration = _key_resp_19_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_19.keys == str('left')) or (key_resp_19.keys == 'left'):
                        key_resp_19.corr = 1
                    else:
                        key_resp_19.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_6* updates
            
            # if UP_6 is starting this frame...
            if UP_6.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_6.frameNStart = frameN  # exact frame index
                UP_6.tStart = t  # local t and not account for scr refresh
                UP_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_6.started')
                # update status
                UP_6.status = STARTED
                UP_6.setAutoDraw(True)
            
            # if UP_6 is active this frame...
            if UP_6.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_6* updates
            
            # if up_whitesquare_6 is starting this frame...
            if up_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_6.frameNStart = frameN  # exact frame index
                up_whitesquare_6.tStart = t  # local t and not account for scr refresh
                up_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_6.started')
                # update status
                up_whitesquare_6.status = STARTED
                up_whitesquare_6.setAutoDraw(True)
            
            # if up_whitesquare_6 is active this frame...
            if up_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_6 is stopping this frame...
            if up_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_6.tStop = t  # not accounting for scr refresh
                    up_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_6.stopped')
                    # update status
                    up_whitesquare_6.status = FINISHED
                    up_whitesquare_6.setAutoDraw(False)
            
            # *down_whitesquare_6* updates
            
            # if down_whitesquare_6 is starting this frame...
            if down_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_6.frameNStart = frameN  # exact frame index
                down_whitesquare_6.tStart = t  # local t and not account for scr refresh
                down_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_6.started')
                # update status
                down_whitesquare_6.status = STARTED
                down_whitesquare_6.setAutoDraw(True)
            
            # if down_whitesquare_6 is active this frame...
            if down_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_6 is stopping this frame...
            if down_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_6.tStop = t  # not accounting for scr refresh
                    down_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_6.stopped')
                    # update status
                    down_whitesquare_6.status = FINISHED
                    down_whitesquare_6.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_down" ---
        for thisComponent in UP_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_down
        UP_on_down.tStop = globalClock.getTime(format='float')
        UP_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_down.stopped', UP_on_down.tStop)
        # check responses
        if key_resp_19.keys in ['', [], None]:  # No response was made
            key_resp_19.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_19.corr = 1;  # correct non-response
            else:
               key_resp_19.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_19.keys',key_resp_19.keys)
        trials_b2.addData('key_resp_19.corr', key_resp_19.corr)
        if key_resp_19.keys != None:  # we had a response
            trials_b2.addData('key_resp_19.rt', key_resp_19.rt)
            trials_b2.addData('key_resp_19.duration', key_resp_19.duration)
        # the Routine "UP_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_down" ---
        # create an object to store info about Routine DOWN_on_down
        DOWN_on_down = data.Routine(
            name='DOWN_on_down',
            components=[blacksquare_17, white_cross_17, key_resp_20, UP_7, up_whitesquare_8, down_whitesquare_8],
        )
        DOWN_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_20
        key_resp_20.keys = []
        key_resp_20.rt = []
        _key_resp_20_allKeys = []
        # Run 'Begin Routine' code from code_20
        
        
        if currentRoutine != "DOWN_on_down":
            continueRoutine = False
        
        # store start times for DOWN_on_down
        DOWN_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_down.tStart = globalClock.getTime(format='float')
        DOWN_on_down.status = STARTED
        thisExp.addData('DOWN_on_down.started', DOWN_on_down.tStart)
        DOWN_on_down.maxDuration = None
        # keep track of which components have finished
        DOWN_on_downComponents = DOWN_on_down.components
        for thisComponent in DOWN_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_17* updates
            
            # if blacksquare_17 is starting this frame...
            if blacksquare_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_17.frameNStart = frameN  # exact frame index
                blacksquare_17.tStart = t  # local t and not account for scr refresh
                blacksquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_17.started')
                # update status
                blacksquare_17.status = STARTED
                blacksquare_17.setAutoDraw(True)
            
            # if blacksquare_17 is active this frame...
            if blacksquare_17.status == STARTED:
                # update params
                pass
            
            # *white_cross_17* updates
            
            # if white_cross_17 is starting this frame...
            if white_cross_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_17.frameNStart = frameN  # exact frame index
                white_cross_17.tStart = t  # local t and not account for scr refresh
                white_cross_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_17.started')
                # update status
                white_cross_17.status = STARTED
                white_cross_17.setAutoDraw(True)
            
            # if white_cross_17 is active this frame...
            if white_cross_17.status == STARTED:
                # update params
                pass
            
            # *key_resp_20* updates
            waitOnFlip = False
            
            # if key_resp_20 is starting this frame...
            if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_20.frameNStart = frameN  # exact frame index
                key_resp_20.tStart = t  # local t and not account for scr refresh
                key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_20.started')
                # update status
                key_resp_20.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_20.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_20.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_20_allKeys.extend(theseKeys)
                if len(_key_resp_20_allKeys):
                    key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
                    key_resp_20.rt = _key_resp_20_allKeys[-1].rt
                    key_resp_20.duration = _key_resp_20_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_20.keys == str('left')) or (key_resp_20.keys == 'left'):
                        key_resp_20.corr = 1
                    else:
                        key_resp_20.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_7* updates
            
            # if UP_7 is starting this frame...
            if UP_7.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_7.frameNStart = frameN  # exact frame index
                UP_7.tStart = t  # local t and not account for scr refresh
                UP_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_7.started')
                # update status
                UP_7.status = STARTED
                UP_7.setAutoDraw(True)
            
            # if UP_7 is active this frame...
            if UP_7.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_8* updates
            
            # if up_whitesquare_8 is starting this frame...
            if up_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_8.frameNStart = frameN  # exact frame index
                up_whitesquare_8.tStart = t  # local t and not account for scr refresh
                up_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_8.started')
                # update status
                up_whitesquare_8.status = STARTED
                up_whitesquare_8.setAutoDraw(True)
            
            # if up_whitesquare_8 is active this frame...
            if up_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_8 is stopping this frame...
            if up_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_8.tStop = t  # not accounting for scr refresh
                    up_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_8.stopped')
                    # update status
                    up_whitesquare_8.status = FINISHED
                    up_whitesquare_8.setAutoDraw(False)
            
            # *down_whitesquare_8* updates
            
            # if down_whitesquare_8 is starting this frame...
            if down_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_8.frameNStart = frameN  # exact frame index
                down_whitesquare_8.tStart = t  # local t and not account for scr refresh
                down_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_8.started')
                # update status
                down_whitesquare_8.status = STARTED
                down_whitesquare_8.setAutoDraw(True)
            
            # if down_whitesquare_8 is active this frame...
            if down_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_8 is stopping this frame...
            if down_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_8.tStop = t  # not accounting for scr refresh
                    down_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_8.stopped')
                    # update status
                    down_whitesquare_8.status = FINISHED
                    down_whitesquare_8.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_down" ---
        for thisComponent in DOWN_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_down
        DOWN_on_down.tStop = globalClock.getTime(format='float')
        DOWN_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_down.stopped', DOWN_on_down.tStop)
        # check responses
        if key_resp_20.keys in ['', [], None]:  # No response was made
            key_resp_20.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_20.corr = 1;  # correct non-response
            else:
               key_resp_20.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_20.keys',key_resp_20.keys)
        trials_b2.addData('key_resp_20.corr', key_resp_20.corr)
        if key_resp_20.keys != None:  # we had a response
            trials_b2.addData('key_resp_20.rt', key_resp_20.rt)
            trials_b2.addData('key_resp_20.duration', key_resp_20.duration)
        # the Routine "DOWN_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_right" ---
        # create an object to store info about Routine leftA_on_right
        leftA_on_right = data.Routine(
            name='leftA_on_right',
            components=[blacksquare_18, white_cross_18, key_resp_21, arrow_l_2, whitesquare_5, whitesquare_12],
        )
        leftA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_21
        key_resp_21.keys = []
        key_resp_21.rt = []
        _key_resp_21_allKeys = []
        # Run 'Begin Routine' code from code_7
        
        
        if currentRoutine != "leftA_on_right":
            continueRoutine = False
        
        # store start times for leftA_on_right
        leftA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_right.tStart = globalClock.getTime(format='float')
        leftA_on_right.status = STARTED
        thisExp.addData('leftA_on_right.started', leftA_on_right.tStart)
        leftA_on_right.maxDuration = None
        # keep track of which components have finished
        leftA_on_rightComponents = leftA_on_right.components
        for thisComponent in leftA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        leftA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_18* updates
            
            # if blacksquare_18 is starting this frame...
            if blacksquare_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_18.frameNStart = frameN  # exact frame index
                blacksquare_18.tStart = t  # local t and not account for scr refresh
                blacksquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_18.started')
                # update status
                blacksquare_18.status = STARTED
                blacksquare_18.setAutoDraw(True)
            
            # if blacksquare_18 is active this frame...
            if blacksquare_18.status == STARTED:
                # update params
                pass
            
            # *white_cross_18* updates
            
            # if white_cross_18 is starting this frame...
            if white_cross_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_18.frameNStart = frameN  # exact frame index
                white_cross_18.tStart = t  # local t and not account for scr refresh
                white_cross_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_18.started')
                # update status
                white_cross_18.status = STARTED
                white_cross_18.setAutoDraw(True)
            
            # if white_cross_18 is active this frame...
            if white_cross_18.status == STARTED:
                # update params
                pass
            
            # *key_resp_21* updates
            waitOnFlip = False
            
            # if key_resp_21 is starting this frame...
            if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_21.frameNStart = frameN  # exact frame index
                key_resp_21.tStart = t  # local t and not account for scr refresh
                key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_21.started')
                # update status
                key_resp_21.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_21.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_21.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_21_allKeys.extend(theseKeys)
                if len(_key_resp_21_allKeys):
                    key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
                    key_resp_21.rt = _key_resp_21_allKeys[-1].rt
                    key_resp_21.duration = _key_resp_21_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_21.keys == str('left')) or (key_resp_21.keys == 'left'):
                        key_resp_21.corr = 1
                    else:
                        key_resp_21.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_2* updates
            
            # if arrow_l_2 is starting this frame...
            if arrow_l_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_2.frameNStart = frameN  # exact frame index
                arrow_l_2.tStart = t  # local t and not account for scr refresh
                arrow_l_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_2.started')
                # update status
                arrow_l_2.status = STARTED
                arrow_l_2.setAutoDraw(True)
            
            # if arrow_l_2 is active this frame...
            if arrow_l_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_5* updates
            
            # if whitesquare_5 is starting this frame...
            if whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_5.frameNStart = frameN  # exact frame index
                whitesquare_5.tStart = t  # local t and not account for scr refresh
                whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_5.started')
                # update status
                whitesquare_5.status = STARTED
                whitesquare_5.setAutoDraw(True)
            
            # if whitesquare_5 is active this frame...
            if whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if whitesquare_5 is stopping this frame...
            if whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_5.tStop = t  # not accounting for scr refresh
                    whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_5.stopped')
                    # update status
                    whitesquare_5.status = FINISHED
                    whitesquare_5.setAutoDraw(False)
            
            # *whitesquare_12* updates
            
            # if whitesquare_12 is starting this frame...
            if whitesquare_12.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_12.frameNStart = frameN  # exact frame index
                whitesquare_12.tStart = t  # local t and not account for scr refresh
                whitesquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_12.started')
                # update status
                whitesquare_12.status = STARTED
                whitesquare_12.setAutoDraw(True)
            
            # if whitesquare_12 is active this frame...
            if whitesquare_12.status == STARTED:
                # update params
                pass
            
            # if whitesquare_12 is stopping this frame...
            if whitesquare_12.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_12.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_12.tStop = t  # not accounting for scr refresh
                    whitesquare_12.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_12.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_12.stopped')
                    # update status
                    whitesquare_12.status = FINISHED
                    whitesquare_12.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_right" ---
        for thisComponent in leftA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_right
        leftA_on_right.tStop = globalClock.getTime(format='float')
        leftA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_right.stopped', leftA_on_right.tStop)
        # check responses
        if key_resp_21.keys in ['', [], None]:  # No response was made
            key_resp_21.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_21.corr = 1;  # correct non-response
            else:
               key_resp_21.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_21.keys',key_resp_21.keys)
        trials_b2.addData('key_resp_21.corr', key_resp_21.corr)
        if key_resp_21.keys != None:  # we had a response
            trials_b2.addData('key_resp_21.rt', key_resp_21.rt)
            trials_b2.addData('key_resp_21.duration', key_resp_21.duration)
        # the Routine "leftA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_left" ---
        # create an object to store info about Routine leftA_on_left
        leftA_on_left = data.Routine(
            name='leftA_on_left',
            components=[blacksquare_19, white_cross_19, key_resp_22, arrow_l_3, whitesquare_7, whitesquare_14],
        )
        leftA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_22
        key_resp_22.keys = []
        key_resp_22.rt = []
        _key_resp_22_allKeys = []
        # Run 'Begin Routine' code from code_9
        
        
        if currentRoutine != "leftA_on_left":
            continueRoutine = False
        
        # store start times for leftA_on_left
        leftA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_left.tStart = globalClock.getTime(format='float')
        leftA_on_left.status = STARTED
        thisExp.addData('leftA_on_left.started', leftA_on_left.tStart)
        leftA_on_left.maxDuration = None
        # keep track of which components have finished
        leftA_on_leftComponents = leftA_on_left.components
        for thisComponent in leftA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        leftA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_19* updates
            
            # if blacksquare_19 is starting this frame...
            if blacksquare_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_19.frameNStart = frameN  # exact frame index
                blacksquare_19.tStart = t  # local t and not account for scr refresh
                blacksquare_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_19.started')
                # update status
                blacksquare_19.status = STARTED
                blacksquare_19.setAutoDraw(True)
            
            # if blacksquare_19 is active this frame...
            if blacksquare_19.status == STARTED:
                # update params
                pass
            
            # *white_cross_19* updates
            
            # if white_cross_19 is starting this frame...
            if white_cross_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_19.frameNStart = frameN  # exact frame index
                white_cross_19.tStart = t  # local t and not account for scr refresh
                white_cross_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_19.started')
                # update status
                white_cross_19.status = STARTED
                white_cross_19.setAutoDraw(True)
            
            # if white_cross_19 is active this frame...
            if white_cross_19.status == STARTED:
                # update params
                pass
            
            # *key_resp_22* updates
            waitOnFlip = False
            
            # if key_resp_22 is starting this frame...
            if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_22.frameNStart = frameN  # exact frame index
                key_resp_22.tStart = t  # local t and not account for scr refresh
                key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_22.started')
                # update status
                key_resp_22.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_22.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_22.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_22_allKeys.extend(theseKeys)
                if len(_key_resp_22_allKeys):
                    key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
                    key_resp_22.rt = _key_resp_22_allKeys[-1].rt
                    key_resp_22.duration = _key_resp_22_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_22.keys == str('left')) or (key_resp_22.keys == 'left'):
                        key_resp_22.corr = 1
                    else:
                        key_resp_22.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_3* updates
            
            # if arrow_l_3 is starting this frame...
            if arrow_l_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_3.frameNStart = frameN  # exact frame index
                arrow_l_3.tStart = t  # local t and not account for scr refresh
                arrow_l_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_3.started')
                # update status
                arrow_l_3.status = STARTED
                arrow_l_3.setAutoDraw(True)
            
            # if arrow_l_3 is active this frame...
            if arrow_l_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_7* updates
            
            # if whitesquare_7 is starting this frame...
            if whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_7.frameNStart = frameN  # exact frame index
                whitesquare_7.tStart = t  # local t and not account for scr refresh
                whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_7.started')
                # update status
                whitesquare_7.status = STARTED
                whitesquare_7.setAutoDraw(True)
            
            # if whitesquare_7 is active this frame...
            if whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if whitesquare_7 is stopping this frame...
            if whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_7.tStop = t  # not accounting for scr refresh
                    whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_7.stopped')
                    # update status
                    whitesquare_7.status = FINISHED
                    whitesquare_7.setAutoDraw(False)
            
            # *whitesquare_14* updates
            
            # if whitesquare_14 is starting this frame...
            if whitesquare_14.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_14.frameNStart = frameN  # exact frame index
                whitesquare_14.tStart = t  # local t and not account for scr refresh
                whitesquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_14.started')
                # update status
                whitesquare_14.status = STARTED
                whitesquare_14.setAutoDraw(True)
            
            # if whitesquare_14 is active this frame...
            if whitesquare_14.status == STARTED:
                # update params
                pass
            
            # if whitesquare_14 is stopping this frame...
            if whitesquare_14.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_14.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_14.tStop = t  # not accounting for scr refresh
                    whitesquare_14.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_14.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_14.stopped')
                    # update status
                    whitesquare_14.status = FINISHED
                    whitesquare_14.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_left" ---
        for thisComponent in leftA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_left
        leftA_on_left.tStop = globalClock.getTime(format='float')
        leftA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_left.stopped', leftA_on_left.tStop)
        # check responses
        if key_resp_22.keys in ['', [], None]:  # No response was made
            key_resp_22.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_22.corr = 1;  # correct non-response
            else:
               key_resp_22.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_22.keys',key_resp_22.keys)
        trials_b2.addData('key_resp_22.corr', key_resp_22.corr)
        if key_resp_22.keys != None:  # we had a response
            trials_b2.addData('key_resp_22.rt', key_resp_22.rt)
            trials_b2.addData('key_resp_22.duration', key_resp_22.duration)
        # the Routine "leftA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_right" ---
        # create an object to store info about Routine rightA_on_right
        rightA_on_right = data.Routine(
            name='rightA_on_right',
            components=[blacksquare_20, white_cross_20, key_resp_23, arrow_l_4, whitesquare_11, whitesquare_18],
        )
        rightA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_23
        key_resp_23.keys = []
        key_resp_23.rt = []
        _key_resp_23_allKeys = []
        # Run 'Begin Routine' code from code_13
        
        
        if currentRoutine != "rightA_on_right":
            continueRoutine = False
        
        # store start times for rightA_on_right
        rightA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_right.tStart = globalClock.getTime(format='float')
        rightA_on_right.status = STARTED
        thisExp.addData('rightA_on_right.started', rightA_on_right.tStart)
        rightA_on_right.maxDuration = None
        # keep track of which components have finished
        rightA_on_rightComponents = rightA_on_right.components
        for thisComponent in rightA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        rightA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_20* updates
            
            # if blacksquare_20 is starting this frame...
            if blacksquare_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_20.frameNStart = frameN  # exact frame index
                blacksquare_20.tStart = t  # local t and not account for scr refresh
                blacksquare_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_20.started')
                # update status
                blacksquare_20.status = STARTED
                blacksquare_20.setAutoDraw(True)
            
            # if blacksquare_20 is active this frame...
            if blacksquare_20.status == STARTED:
                # update params
                pass
            
            # *white_cross_20* updates
            
            # if white_cross_20 is starting this frame...
            if white_cross_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_20.frameNStart = frameN  # exact frame index
                white_cross_20.tStart = t  # local t and not account for scr refresh
                white_cross_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_20.started')
                # update status
                white_cross_20.status = STARTED
                white_cross_20.setAutoDraw(True)
            
            # if white_cross_20 is active this frame...
            if white_cross_20.status == STARTED:
                # update params
                pass
            
            # *key_resp_23* updates
            waitOnFlip = False
            
            # if key_resp_23 is starting this frame...
            if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_23.frameNStart = frameN  # exact frame index
                key_resp_23.tStart = t  # local t and not account for scr refresh
                key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_23.started')
                # update status
                key_resp_23.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_23.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_23.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_23_allKeys.extend(theseKeys)
                if len(_key_resp_23_allKeys):
                    key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
                    key_resp_23.rt = _key_resp_23_allKeys[-1].rt
                    key_resp_23.duration = _key_resp_23_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_23.keys == str('left')) or (key_resp_23.keys == 'left'):
                        key_resp_23.corr = 1
                    else:
                        key_resp_23.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_4* updates
            
            # if arrow_l_4 is starting this frame...
            if arrow_l_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_4.frameNStart = frameN  # exact frame index
                arrow_l_4.tStart = t  # local t and not account for scr refresh
                arrow_l_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_4.started')
                # update status
                arrow_l_4.status = STARTED
                arrow_l_4.setAutoDraw(True)
            
            # if arrow_l_4 is active this frame...
            if arrow_l_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_11* updates
            
            # if whitesquare_11 is starting this frame...
            if whitesquare_11.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_11.frameNStart = frameN  # exact frame index
                whitesquare_11.tStart = t  # local t and not account for scr refresh
                whitesquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_11.started')
                # update status
                whitesquare_11.status = STARTED
                whitesquare_11.setAutoDraw(True)
            
            # if whitesquare_11 is active this frame...
            if whitesquare_11.status == STARTED:
                # update params
                pass
            
            # if whitesquare_11 is stopping this frame...
            if whitesquare_11.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_11.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_11.tStop = t  # not accounting for scr refresh
                    whitesquare_11.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_11.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_11.stopped')
                    # update status
                    whitesquare_11.status = FINISHED
                    whitesquare_11.setAutoDraw(False)
            
            # *whitesquare_18* updates
            
            # if whitesquare_18 is starting this frame...
            if whitesquare_18.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_18.frameNStart = frameN  # exact frame index
                whitesquare_18.tStart = t  # local t and not account for scr refresh
                whitesquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_18.started')
                # update status
                whitesquare_18.status = STARTED
                whitesquare_18.setAutoDraw(True)
            
            # if whitesquare_18 is active this frame...
            if whitesquare_18.status == STARTED:
                # update params
                pass
            
            # if whitesquare_18 is stopping this frame...
            if whitesquare_18.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_18.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_18.tStop = t  # not accounting for scr refresh
                    whitesquare_18.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_18.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_18.stopped')
                    # update status
                    whitesquare_18.status = FINISHED
                    whitesquare_18.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_right" ---
        for thisComponent in rightA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_right
        rightA_on_right.tStop = globalClock.getTime(format='float')
        rightA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_right.stopped', rightA_on_right.tStop)
        # check responses
        if key_resp_23.keys in ['', [], None]:  # No response was made
            key_resp_23.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_23.corr = 1;  # correct non-response
            else:
               key_resp_23.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_23.keys',key_resp_23.keys)
        trials_b2.addData('key_resp_23.corr', key_resp_23.corr)
        if key_resp_23.keys != None:  # we had a response
            trials_b2.addData('key_resp_23.rt', key_resp_23.rt)
            trials_b2.addData('key_resp_23.duration', key_resp_23.duration)
        # the Routine "rightA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_left" ---
        # create an object to store info about Routine rightA_on_left
        rightA_on_left = data.Routine(
            name='rightA_on_left',
            components=[blacksquare_21, white_cross_21, key_resp_24, arrow_l_5, whitesquare_9, whitesquare_16],
        )
        rightA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_24
        key_resp_24.keys = []
        key_resp_24.rt = []
        _key_resp_24_allKeys = []
        # Run 'Begin Routine' code from code_11
        
        
        if currentRoutine != "rightA_on_left":
            continueRoutine = False
        
        # store start times for rightA_on_left
        rightA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_left.tStart = globalClock.getTime(format='float')
        rightA_on_left.status = STARTED
        thisExp.addData('rightA_on_left.started', rightA_on_left.tStart)
        rightA_on_left.maxDuration = None
        # keep track of which components have finished
        rightA_on_leftComponents = rightA_on_left.components
        for thisComponent in rightA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        rightA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_21* updates
            
            # if blacksquare_21 is starting this frame...
            if blacksquare_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_21.frameNStart = frameN  # exact frame index
                blacksquare_21.tStart = t  # local t and not account for scr refresh
                blacksquare_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_21.started')
                # update status
                blacksquare_21.status = STARTED
                blacksquare_21.setAutoDraw(True)
            
            # if blacksquare_21 is active this frame...
            if blacksquare_21.status == STARTED:
                # update params
                pass
            
            # *white_cross_21* updates
            
            # if white_cross_21 is starting this frame...
            if white_cross_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_21.frameNStart = frameN  # exact frame index
                white_cross_21.tStart = t  # local t and not account for scr refresh
                white_cross_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_21.started')
                # update status
                white_cross_21.status = STARTED
                white_cross_21.setAutoDraw(True)
            
            # if white_cross_21 is active this frame...
            if white_cross_21.status == STARTED:
                # update params
                pass
            
            # *key_resp_24* updates
            waitOnFlip = False
            
            # if key_resp_24 is starting this frame...
            if key_resp_24.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_24.frameNStart = frameN  # exact frame index
                key_resp_24.tStart = t  # local t and not account for scr refresh
                key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_24.started')
                # update status
                key_resp_24.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_24.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_24.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_24_allKeys.extend(theseKeys)
                if len(_key_resp_24_allKeys):
                    key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
                    key_resp_24.rt = _key_resp_24_allKeys[-1].rt
                    key_resp_24.duration = _key_resp_24_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_24.keys == str('left')) or (key_resp_24.keys == 'left'):
                        key_resp_24.corr = 1
                    else:
                        key_resp_24.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_5* updates
            
            # if arrow_l_5 is starting this frame...
            if arrow_l_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_5.frameNStart = frameN  # exact frame index
                arrow_l_5.tStart = t  # local t and not account for scr refresh
                arrow_l_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_5.started')
                # update status
                arrow_l_5.status = STARTED
                arrow_l_5.setAutoDraw(True)
            
            # if arrow_l_5 is active this frame...
            if arrow_l_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_9* updates
            
            # if whitesquare_9 is starting this frame...
            if whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_9.frameNStart = frameN  # exact frame index
                whitesquare_9.tStart = t  # local t and not account for scr refresh
                whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_9.started')
                # update status
                whitesquare_9.status = STARTED
                whitesquare_9.setAutoDraw(True)
            
            # if whitesquare_9 is active this frame...
            if whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if whitesquare_9 is stopping this frame...
            if whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_9.tStop = t  # not accounting for scr refresh
                    whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_9.stopped')
                    # update status
                    whitesquare_9.status = FINISHED
                    whitesquare_9.setAutoDraw(False)
            
            # *whitesquare_16* updates
            
            # if whitesquare_16 is starting this frame...
            if whitesquare_16.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_16.frameNStart = frameN  # exact frame index
                whitesquare_16.tStart = t  # local t and not account for scr refresh
                whitesquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_16.started')
                # update status
                whitesquare_16.status = STARTED
                whitesquare_16.setAutoDraw(True)
            
            # if whitesquare_16 is active this frame...
            if whitesquare_16.status == STARTED:
                # update params
                pass
            
            # if whitesquare_16 is stopping this frame...
            if whitesquare_16.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_16.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_16.tStop = t  # not accounting for scr refresh
                    whitesquare_16.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_16.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_16.stopped')
                    # update status
                    whitesquare_16.status = FINISHED
                    whitesquare_16.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_left" ---
        for thisComponent in rightA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_left
        rightA_on_left.tStop = globalClock.getTime(format='float')
        rightA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_left.stopped', rightA_on_left.tStop)
        # check responses
        if key_resp_24.keys in ['', [], None]:  # No response was made
            key_resp_24.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_24.corr = 1;  # correct non-response
            else:
               key_resp_24.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_24.keys',key_resp_24.keys)
        trials_b2.addData('key_resp_24.corr', key_resp_24.corr)
        if key_resp_24.keys != None:  # we had a response
            trials_b2.addData('key_resp_24.rt', key_resp_24.rt)
            trials_b2.addData('key_resp_24.duration', key_resp_24.duration)
        # the Routine "rightA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_up" ---
        # create an object to store info about Routine upA_on_up
        upA_on_up = data.Routine(
            name='upA_on_up',
            components=[blacksquare_22, white_cross_22, key_resp_25, arrow_u, up_whitesquare_3, down_whitesquare_3],
        )
        upA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_25
        key_resp_25.keys = []
        key_resp_25.rt = []
        _key_resp_25_allKeys = []
        # Run 'Begin Routine' code from code_15
        
        
        if currentRoutine != "upA_on_up":
            continueRoutine = False
        
        # store start times for upA_on_up
        upA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_up.tStart = globalClock.getTime(format='float')
        upA_on_up.status = STARTED
        thisExp.addData('upA_on_up.started', upA_on_up.tStart)
        upA_on_up.maxDuration = None
        # keep track of which components have finished
        upA_on_upComponents = upA_on_up.components
        for thisComponent in upA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        upA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_22* updates
            
            # if blacksquare_22 is starting this frame...
            if blacksquare_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_22.frameNStart = frameN  # exact frame index
                blacksquare_22.tStart = t  # local t and not account for scr refresh
                blacksquare_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_22.started')
                # update status
                blacksquare_22.status = STARTED
                blacksquare_22.setAutoDraw(True)
            
            # if blacksquare_22 is active this frame...
            if blacksquare_22.status == STARTED:
                # update params
                pass
            
            # *white_cross_22* updates
            
            # if white_cross_22 is starting this frame...
            if white_cross_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_22.frameNStart = frameN  # exact frame index
                white_cross_22.tStart = t  # local t and not account for scr refresh
                white_cross_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_22.started')
                # update status
                white_cross_22.status = STARTED
                white_cross_22.setAutoDraw(True)
            
            # if white_cross_22 is active this frame...
            if white_cross_22.status == STARTED:
                # update params
                pass
            
            # *key_resp_25* updates
            waitOnFlip = False
            
            # if key_resp_25 is starting this frame...
            if key_resp_25.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_25.frameNStart = frameN  # exact frame index
                key_resp_25.tStart = t  # local t and not account for scr refresh
                key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_25.started')
                # update status
                key_resp_25.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_25.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_25.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_25_allKeys.extend(theseKeys)
                if len(_key_resp_25_allKeys):
                    key_resp_25.keys = _key_resp_25_allKeys[-1].name  # just the last key pressed
                    key_resp_25.rt = _key_resp_25_allKeys[-1].rt
                    key_resp_25.duration = _key_resp_25_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_25.keys == str('left')) or (key_resp_25.keys == 'left'):
                        key_resp_25.corr = 1
                    else:
                        key_resp_25.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u* updates
            
            # if arrow_u is starting this frame...
            if arrow_u.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u.frameNStart = frameN  # exact frame index
                arrow_u.tStart = t  # local t and not account for scr refresh
                arrow_u.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u.started')
                # update status
                arrow_u.status = STARTED
                arrow_u.setAutoDraw(True)
            
            # if arrow_u is active this frame...
            if arrow_u.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_3* updates
            
            # if up_whitesquare_3 is starting this frame...
            if up_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_3.frameNStart = frameN  # exact frame index
                up_whitesquare_3.tStart = t  # local t and not account for scr refresh
                up_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_3.started')
                # update status
                up_whitesquare_3.status = STARTED
                up_whitesquare_3.setAutoDraw(True)
            
            # if up_whitesquare_3 is active this frame...
            if up_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_3 is stopping this frame...
            if up_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_3.tStop = t  # not accounting for scr refresh
                    up_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_3.stopped')
                    # update status
                    up_whitesquare_3.status = FINISHED
                    up_whitesquare_3.setAutoDraw(False)
            
            # *down_whitesquare_3* updates
            
            # if down_whitesquare_3 is starting this frame...
            if down_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_3.frameNStart = frameN  # exact frame index
                down_whitesquare_3.tStart = t  # local t and not account for scr refresh
                down_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_3.started')
                # update status
                down_whitesquare_3.status = STARTED
                down_whitesquare_3.setAutoDraw(True)
            
            # if down_whitesquare_3 is active this frame...
            if down_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_3 is stopping this frame...
            if down_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_3.tStop = t  # not accounting for scr refresh
                    down_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_3.stopped')
                    # update status
                    down_whitesquare_3.status = FINISHED
                    down_whitesquare_3.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_up" ---
        for thisComponent in upA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_up
        upA_on_up.tStop = globalClock.getTime(format='float')
        upA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_up.stopped', upA_on_up.tStop)
        # check responses
        if key_resp_25.keys in ['', [], None]:  # No response was made
            key_resp_25.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_25.corr = 1;  # correct non-response
            else:
               key_resp_25.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_25.keys',key_resp_25.keys)
        trials_b2.addData('key_resp_25.corr', key_resp_25.corr)
        if key_resp_25.keys != None:  # we had a response
            trials_b2.addData('key_resp_25.rt', key_resp_25.rt)
            trials_b2.addData('key_resp_25.duration', key_resp_25.duration)
        # the Routine "upA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_down" ---
        # create an object to store info about Routine upA_on_down
        upA_on_down = data.Routine(
            name='upA_on_down',
            components=[blacksquare_23, white_cross_23, key_resp_26, arrow_u_2, up_whitesquare_7, down_whitesquare_7],
        )
        upA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_26
        key_resp_26.keys = []
        key_resp_26.rt = []
        _key_resp_26_allKeys = []
        # Run 'Begin Routine' code from code_19
        
        
        if currentRoutine != "upA_on_down":
            continueRoutine = False
        
        # store start times for upA_on_down
        upA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_down.tStart = globalClock.getTime(format='float')
        upA_on_down.status = STARTED
        thisExp.addData('upA_on_down.started', upA_on_down.tStart)
        upA_on_down.maxDuration = None
        # keep track of which components have finished
        upA_on_downComponents = upA_on_down.components
        for thisComponent in upA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        upA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_23* updates
            
            # if blacksquare_23 is starting this frame...
            if blacksquare_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_23.frameNStart = frameN  # exact frame index
                blacksquare_23.tStart = t  # local t and not account for scr refresh
                blacksquare_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_23.started')
                # update status
                blacksquare_23.status = STARTED
                blacksquare_23.setAutoDraw(True)
            
            # if blacksquare_23 is active this frame...
            if blacksquare_23.status == STARTED:
                # update params
                pass
            
            # *white_cross_23* updates
            
            # if white_cross_23 is starting this frame...
            if white_cross_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_23.frameNStart = frameN  # exact frame index
                white_cross_23.tStart = t  # local t and not account for scr refresh
                white_cross_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_23.started')
                # update status
                white_cross_23.status = STARTED
                white_cross_23.setAutoDraw(True)
            
            # if white_cross_23 is active this frame...
            if white_cross_23.status == STARTED:
                # update params
                pass
            
            # *key_resp_26* updates
            waitOnFlip = False
            
            # if key_resp_26 is starting this frame...
            if key_resp_26.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_26.frameNStart = frameN  # exact frame index
                key_resp_26.tStart = t  # local t and not account for scr refresh
                key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_26.started')
                # update status
                key_resp_26.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_26.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_26.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_26_allKeys.extend(theseKeys)
                if len(_key_resp_26_allKeys):
                    key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
                    key_resp_26.rt = _key_resp_26_allKeys[-1].rt
                    key_resp_26.duration = _key_resp_26_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_26.keys == str('left')) or (key_resp_26.keys == 'left'):
                        key_resp_26.corr = 1
                    else:
                        key_resp_26.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_2* updates
            
            # if arrow_u_2 is starting this frame...
            if arrow_u_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_2.frameNStart = frameN  # exact frame index
                arrow_u_2.tStart = t  # local t and not account for scr refresh
                arrow_u_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_2.started')
                # update status
                arrow_u_2.status = STARTED
                arrow_u_2.setAutoDraw(True)
            
            # if arrow_u_2 is active this frame...
            if arrow_u_2.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_7* updates
            
            # if up_whitesquare_7 is starting this frame...
            if up_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_7.frameNStart = frameN  # exact frame index
                up_whitesquare_7.tStart = t  # local t and not account for scr refresh
                up_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_7.started')
                # update status
                up_whitesquare_7.status = STARTED
                up_whitesquare_7.setAutoDraw(True)
            
            # if up_whitesquare_7 is active this frame...
            if up_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_7 is stopping this frame...
            if up_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_7.tStop = t  # not accounting for scr refresh
                    up_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_7.stopped')
                    # update status
                    up_whitesquare_7.status = FINISHED
                    up_whitesquare_7.setAutoDraw(False)
            
            # *down_whitesquare_7* updates
            
            # if down_whitesquare_7 is starting this frame...
            if down_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_7.frameNStart = frameN  # exact frame index
                down_whitesquare_7.tStart = t  # local t and not account for scr refresh
                down_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_7.started')
                # update status
                down_whitesquare_7.status = STARTED
                down_whitesquare_7.setAutoDraw(True)
            
            # if down_whitesquare_7 is active this frame...
            if down_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_7 is stopping this frame...
            if down_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_7.tStop = t  # not accounting for scr refresh
                    down_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_7.stopped')
                    # update status
                    down_whitesquare_7.status = FINISHED
                    down_whitesquare_7.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_down" ---
        for thisComponent in upA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_down
        upA_on_down.tStop = globalClock.getTime(format='float')
        upA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_down.stopped', upA_on_down.tStop)
        # check responses
        if key_resp_26.keys in ['', [], None]:  # No response was made
            key_resp_26.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_26.corr = 1;  # correct non-response
            else:
               key_resp_26.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_26.keys',key_resp_26.keys)
        trials_b2.addData('key_resp_26.corr', key_resp_26.corr)
        if key_resp_26.keys != None:  # we had a response
            trials_b2.addData('key_resp_26.rt', key_resp_26.rt)
            trials_b2.addData('key_resp_26.duration', key_resp_26.duration)
        # the Routine "upA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_down" ---
        # create an object to store info about Routine downA_on_down
        downA_on_down = data.Routine(
            name='downA_on_down',
            components=[blacksquare_24, white_cross_24, key_resp_27, arrow_u_3, up_whitesquare_9, down_whitesquare_9],
        )
        downA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_27
        key_resp_27.keys = []
        key_resp_27.rt = []
        _key_resp_27_allKeys = []
        # Run 'Begin Routine' code from code_21
        
        
        if currentRoutine != "downA_on_down":
            continueRoutine = False
        
        # store start times for downA_on_down
        downA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_down.tStart = globalClock.getTime(format='float')
        downA_on_down.status = STARTED
        thisExp.addData('downA_on_down.started', downA_on_down.tStart)
        downA_on_down.maxDuration = None
        # keep track of which components have finished
        downA_on_downComponents = downA_on_down.components
        for thisComponent in downA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        downA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_24* updates
            
            # if blacksquare_24 is starting this frame...
            if blacksquare_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_24.frameNStart = frameN  # exact frame index
                blacksquare_24.tStart = t  # local t and not account for scr refresh
                blacksquare_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_24.started')
                # update status
                blacksquare_24.status = STARTED
                blacksquare_24.setAutoDraw(True)
            
            # if blacksquare_24 is active this frame...
            if blacksquare_24.status == STARTED:
                # update params
                pass
            
            # *white_cross_24* updates
            
            # if white_cross_24 is starting this frame...
            if white_cross_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_24.frameNStart = frameN  # exact frame index
                white_cross_24.tStart = t  # local t and not account for scr refresh
                white_cross_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_24.started')
                # update status
                white_cross_24.status = STARTED
                white_cross_24.setAutoDraw(True)
            
            # if white_cross_24 is active this frame...
            if white_cross_24.status == STARTED:
                # update params
                pass
            
            # *key_resp_27* updates
            waitOnFlip = False
            
            # if key_resp_27 is starting this frame...
            if key_resp_27.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_27.frameNStart = frameN  # exact frame index
                key_resp_27.tStart = t  # local t and not account for scr refresh
                key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_27.started')
                # update status
                key_resp_27.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_27.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_27.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_27_allKeys.extend(theseKeys)
                if len(_key_resp_27_allKeys):
                    key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
                    key_resp_27.rt = _key_resp_27_allKeys[-1].rt
                    key_resp_27.duration = _key_resp_27_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_27.keys == str('left')) or (key_resp_27.keys == 'left'):
                        key_resp_27.corr = 1
                    else:
                        key_resp_27.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_3* updates
            
            # if arrow_u_3 is starting this frame...
            if arrow_u_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_3.frameNStart = frameN  # exact frame index
                arrow_u_3.tStart = t  # local t and not account for scr refresh
                arrow_u_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_3.started')
                # update status
                arrow_u_3.status = STARTED
                arrow_u_3.setAutoDraw(True)
            
            # if arrow_u_3 is active this frame...
            if arrow_u_3.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_9* updates
            
            # if up_whitesquare_9 is starting this frame...
            if up_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_9.frameNStart = frameN  # exact frame index
                up_whitesquare_9.tStart = t  # local t and not account for scr refresh
                up_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_9.started')
                # update status
                up_whitesquare_9.status = STARTED
                up_whitesquare_9.setAutoDraw(True)
            
            # if up_whitesquare_9 is active this frame...
            if up_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_9 is stopping this frame...
            if up_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_9.tStop = t  # not accounting for scr refresh
                    up_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_9.stopped')
                    # update status
                    up_whitesquare_9.status = FINISHED
                    up_whitesquare_9.setAutoDraw(False)
            
            # *down_whitesquare_9* updates
            
            # if down_whitesquare_9 is starting this frame...
            if down_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_9.frameNStart = frameN  # exact frame index
                down_whitesquare_9.tStart = t  # local t and not account for scr refresh
                down_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_9.started')
                # update status
                down_whitesquare_9.status = STARTED
                down_whitesquare_9.setAutoDraw(True)
            
            # if down_whitesquare_9 is active this frame...
            if down_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_9 is stopping this frame...
            if down_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_9.tStop = t  # not accounting for scr refresh
                    down_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_9.stopped')
                    # update status
                    down_whitesquare_9.status = FINISHED
                    down_whitesquare_9.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_down" ---
        for thisComponent in downA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_down
        downA_on_down.tStop = globalClock.getTime(format='float')
        downA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_down.stopped', downA_on_down.tStop)
        # check responses
        if key_resp_27.keys in ['', [], None]:  # No response was made
            key_resp_27.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_27.corr = 1;  # correct non-response
            else:
               key_resp_27.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_27.keys',key_resp_27.keys)
        trials_b2.addData('key_resp_27.corr', key_resp_27.corr)
        if key_resp_27.keys != None:  # we had a response
            trials_b2.addData('key_resp_27.rt', key_resp_27.rt)
            trials_b2.addData('key_resp_27.duration', key_resp_27.duration)
        # the Routine "downA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_up" ---
        # create an object to store info about Routine downA_on_up
        downA_on_up = data.Routine(
            name='downA_on_up',
            components=[blacksquare_25, white_cross_25, key_resp_28, arrow_u_4, up_whitesquare_5, down_whitesquare_5],
        )
        downA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_28
        key_resp_28.keys = []
        key_resp_28.rt = []
        _key_resp_28_allKeys = []
        # Run 'Begin Routine' code from code_17
        
        
        if currentRoutine != "downA_on_up":
            continueRoutine = False
        
        # store start times for downA_on_up
        downA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_up.tStart = globalClock.getTime(format='float')
        downA_on_up.status = STARTED
        thisExp.addData('downA_on_up.started', downA_on_up.tStart)
        downA_on_up.maxDuration = None
        # keep track of which components have finished
        downA_on_upComponents = downA_on_up.components
        for thisComponent in downA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b2, data.TrialHandler2) and thisTrials_b2.thisN != trials_b2.thisTrial.thisN:
            continueRoutine = False
        downA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_25* updates
            
            # if blacksquare_25 is starting this frame...
            if blacksquare_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_25.frameNStart = frameN  # exact frame index
                blacksquare_25.tStart = t  # local t and not account for scr refresh
                blacksquare_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_25.started')
                # update status
                blacksquare_25.status = STARTED
                blacksquare_25.setAutoDraw(True)
            
            # if blacksquare_25 is active this frame...
            if blacksquare_25.status == STARTED:
                # update params
                pass
            
            # *white_cross_25* updates
            
            # if white_cross_25 is starting this frame...
            if white_cross_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_25.frameNStart = frameN  # exact frame index
                white_cross_25.tStart = t  # local t and not account for scr refresh
                white_cross_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_25.started')
                # update status
                white_cross_25.status = STARTED
                white_cross_25.setAutoDraw(True)
            
            # if white_cross_25 is active this frame...
            if white_cross_25.status == STARTED:
                # update params
                pass
            
            # *key_resp_28* updates
            waitOnFlip = False
            
            # if key_resp_28 is starting this frame...
            if key_resp_28.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_28.frameNStart = frameN  # exact frame index
                key_resp_28.tStart = t  # local t and not account for scr refresh
                key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_28.started')
                # update status
                key_resp_28.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_28.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_28.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_28_allKeys.extend(theseKeys)
                if len(_key_resp_28_allKeys):
                    key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
                    key_resp_28.rt = _key_resp_28_allKeys[-1].rt
                    key_resp_28.duration = _key_resp_28_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_28.keys == str('left')) or (key_resp_28.keys == 'left'):
                        key_resp_28.corr = 1
                    else:
                        key_resp_28.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_4* updates
            
            # if arrow_u_4 is starting this frame...
            if arrow_u_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_4.frameNStart = frameN  # exact frame index
                arrow_u_4.tStart = t  # local t and not account for scr refresh
                arrow_u_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_4.started')
                # update status
                arrow_u_4.status = STARTED
                arrow_u_4.setAutoDraw(True)
            
            # if arrow_u_4 is active this frame...
            if arrow_u_4.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_5* updates
            
            # if up_whitesquare_5 is starting this frame...
            if up_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_5.frameNStart = frameN  # exact frame index
                up_whitesquare_5.tStart = t  # local t and not account for scr refresh
                up_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_5.started')
                # update status
                up_whitesquare_5.status = STARTED
                up_whitesquare_5.setAutoDraw(True)
            
            # if up_whitesquare_5 is active this frame...
            if up_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_5 is stopping this frame...
            if up_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_5.tStop = t  # not accounting for scr refresh
                    up_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_5.stopped')
                    # update status
                    up_whitesquare_5.status = FINISHED
                    up_whitesquare_5.setAutoDraw(False)
            
            # *down_whitesquare_5* updates
            
            # if down_whitesquare_5 is starting this frame...
            if down_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_5.frameNStart = frameN  # exact frame index
                down_whitesquare_5.tStart = t  # local t and not account for scr refresh
                down_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_5.started')
                # update status
                down_whitesquare_5.status = STARTED
                down_whitesquare_5.setAutoDraw(True)
            
            # if down_whitesquare_5 is active this frame...
            if down_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_5 is stopping this frame...
            if down_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_5.tStop = t  # not accounting for scr refresh
                    down_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_5.stopped')
                    # update status
                    down_whitesquare_5.status = FINISHED
                    down_whitesquare_5.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_up" ---
        for thisComponent in downA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_up
        downA_on_up.tStop = globalClock.getTime(format='float')
        downA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_up.stopped', downA_on_up.tStop)
        # check responses
        if key_resp_28.keys in ['', [], None]:  # No response was made
            key_resp_28.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_28.corr = 1;  # correct non-response
            else:
               key_resp_28.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b2 (TrialHandler)
        trials_b2.addData('key_resp_28.keys',key_resp_28.keys)
        trials_b2.addData('key_resp_28.corr', key_resp_28.corr)
        if key_resp_28.keys != None:  # we had a response
            trials_b2.addData('key_resp_28.rt', key_resp_28.rt)
            trials_b2.addData('key_resp_28.duration', key_resp_28.duration)
        # the Routine "downA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 32.0 repeats of 'trials_b2'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "end_block2" ---
    # create an object to store info about Routine end_block2
    end_block2 = data.Routine(
        name='end_block2',
        components=[text_29, text_30, key_resp_30],
    )
    end_block2.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_30
    key_resp_30.keys = []
    key_resp_30.rt = []
    _key_resp_30_allKeys = []
    # store start times for end_block2
    end_block2.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    end_block2.tStart = globalClock.getTime(format='float')
    end_block2.status = STARTED
    thisExp.addData('end_block2.started', end_block2.tStart)
    end_block2.maxDuration = None
    # keep track of which components have finished
    end_block2Components = end_block2.components
    for thisComponent in end_block2.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end_block2" ---
    end_block2.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_29* updates
        
        # if text_29 is starting this frame...
        if text_29.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_29.frameNStart = frameN  # exact frame index
            text_29.tStart = t  # local t and not account for scr refresh
            text_29.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_29, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_29.started')
            # update status
            text_29.status = STARTED
            text_29.setAutoDraw(True)
        
        # if text_29 is active this frame...
        if text_29.status == STARTED:
            # update params
            pass
        
        # *text_30* updates
        
        # if text_30 is starting this frame...
        if text_30.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_30.frameNStart = frameN  # exact frame index
            text_30.tStart = t  # local t and not account for scr refresh
            text_30.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_30, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_30.started')
            # update status
            text_30.status = STARTED
            text_30.setAutoDraw(True)
        
        # if text_30 is active this frame...
        if text_30.status == STARTED:
            # update params
            pass
        
        # *key_resp_30* updates
        waitOnFlip = False
        
        # if key_resp_30 is starting this frame...
        if key_resp_30.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_30.frameNStart = frameN  # exact frame index
            key_resp_30.tStart = t  # local t and not account for scr refresh
            key_resp_30.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_30, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_30.started')
            # update status
            key_resp_30.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_30.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_30.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_30.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_30.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_30_allKeys.extend(theseKeys)
            if len(_key_resp_30_allKeys):
                key_resp_30.keys = _key_resp_30_allKeys[-1].name  # just the last key pressed
                key_resp_30.rt = _key_resp_30_allKeys[-1].rt
                key_resp_30.duration = _key_resp_30_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            end_block2.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in end_block2.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end_block2" ---
    for thisComponent in end_block2.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for end_block2
    end_block2.tStop = globalClock.getTime(format='float')
    end_block2.tStopRefresh = tThisFlipGlobal
    thisExp.addData('end_block2.stopped', end_block2.tStop)
    # check responses
    if key_resp_30.keys in ['', [], None]:  # No response was made
        key_resp_30.keys = None
    thisExp.addData('key_resp_30.keys',key_resp_30.keys)
    if key_resp_30.keys != None:  # we had a response
        thisExp.addData('key_resp_30.rt', key_resp_30.rt)
        thisExp.addData('key_resp_30.duration', key_resp_30.duration)
    thisExp.nextEntry()
    # the Routine "end_block2" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "block3" ---
    # create an object to store info about Routine block3
    block3 = data.Routine(
        name='block3',
        components=[text_25],
    )
    block3.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for block3
    block3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    block3.tStart = globalClock.getTime(format='float')
    block3.status = STARTED
    thisExp.addData('block3.started', block3.tStart)
    block3.maxDuration = None
    # keep track of which components have finished
    block3Components = block3.components
    for thisComponent in block3.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "block3" ---
    block3.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 2.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_25* updates
        
        # if text_25 is starting this frame...
        if text_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_25.frameNStart = frameN  # exact frame index
            text_25.tStart = t  # local t and not account for scr refresh
            text_25.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_25, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_25.started')
            # update status
            text_25.status = STARTED
            text_25.setAutoDraw(True)
        
        # if text_25 is active this frame...
        if text_25.status == STARTED:
            # update params
            pass
        
        # if text_25 is stopping this frame...
        if text_25.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_25.tStartRefresh + 2-frameTolerance:
                # keep track of stop time/frame for later
                text_25.tStop = t  # not accounting for scr refresh
                text_25.tStopRefresh = tThisFlipGlobal  # on global time
                text_25.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_25.stopped')
                # update status
                text_25.status = FINISHED
                text_25.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            block3.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in block3.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "block3" ---
    for thisComponent in block3.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for block3
    block3.tStop = globalClock.getTime(format='float')
    block3.tStopRefresh = tThisFlipGlobal
    thisExp.addData('block3.stopped', block3.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if block3.maxDurationReached:
        routineTimer.addTime(-block3.maxDuration)
    elif block3.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-2.000000)
    thisExp.nextEntry()
    
    # set up handler to look after randomisation of conditions etc
    trials_b3 = data.TrialHandler2(
        name='trials_b3',
        nReps=5.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(trials_b3)  # add the loop to the experiment
    thisTrials_b3 = trials_b3.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_b3.rgb)
    if thisTrials_b3 != None:
        for paramName in thisTrials_b3:
            globals()[paramName] = thisTrials_b3[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_b3 in trials_b3:
        currentLoop = trials_b3
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_b3.rgb)
        if thisTrials_b3 != None:
            for paramName in thisTrials_b3:
                globals()[paramName] = thisTrials_b3[paramName]
        
        # --- Prepare to start Routine "block3_router" ---
        # create an object to store info about Routine block3_router
        block3_router = data.Routine(
            name='block3_router',
            components=[],
        )
        block3_router.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_23
        currentRoutine = schedule[trial_index]
        
        
        # store start times for block3_router
        block3_router.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        block3_router.tStart = globalClock.getTime(format='float')
        block3_router.status = STARTED
        thisExp.addData('block3_router.started', block3_router.tStart)
        block3_router.maxDuration = None
        # keep track of which components have finished
        block3_routerComponents = block3_router.components
        for thisComponent in block3_router.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "block3_router" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        block3_router.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                block3_router.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in block3_router.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "block3_router" ---
        for thisComponent in block3_router.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for block3_router
        block3_router.tStop = globalClock.getTime(format='float')
        block3_router.tStopRefresh = tThisFlipGlobal
        thisExp.addData('block3_router.stopped', block3_router.tStop)
        # Run 'End Routine' code from code_23
        trial_index += 1
        
        # the Routine "block3_router" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_right" ---
        # create an object to store info about Routine LEFT_on_right
        LEFT_on_right = data.Routine(
            name='LEFT_on_right',
            components=[blacksquare_10, white_cross_10, key_resp_13, LEFT_2, whitesquare_3, whitesquare_4],
        )
        LEFT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_13
        key_resp_13.keys = []
        key_resp_13.rt = []
        _key_resp_13_allKeys = []
        # Run 'Begin Routine' code from code_6
        if currentRoutine != "LEFT_on_right":
            continueRoutine = False
        
        # store start times for LEFT_on_right
        LEFT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_right.tStart = globalClock.getTime(format='float')
        LEFT_on_right.status = STARTED
        thisExp.addData('LEFT_on_right.started', LEFT_on_right.tStart)
        LEFT_on_right.maxDuration = None
        # keep track of which components have finished
        LEFT_on_rightComponents = LEFT_on_right.components
        for thisComponent in LEFT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_10* updates
            
            # if blacksquare_10 is starting this frame...
            if blacksquare_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_10.frameNStart = frameN  # exact frame index
                blacksquare_10.tStart = t  # local t and not account for scr refresh
                blacksquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_10.started')
                # update status
                blacksquare_10.status = STARTED
                blacksquare_10.setAutoDraw(True)
            
            # if blacksquare_10 is active this frame...
            if blacksquare_10.status == STARTED:
                # update params
                pass
            
            # *white_cross_10* updates
            
            # if white_cross_10 is starting this frame...
            if white_cross_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                white_cross_10.frameNStart = frameN  # exact frame index
                white_cross_10.tStart = t  # local t and not account for scr refresh
                white_cross_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_10.started')
                # update status
                white_cross_10.status = STARTED
                white_cross_10.setAutoDraw(True)
            
            # if white_cross_10 is active this frame...
            if white_cross_10.status == STARTED:
                # update params
                pass
            
            # *key_resp_13* updates
            waitOnFlip = False
            
            # if key_resp_13 is starting this frame...
            if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_13.frameNStart = frameN  # exact frame index
                key_resp_13.tStart = t  # local t and not account for scr refresh
                key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_13.started')
                # update status
                key_resp_13.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_13.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_13.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_13_allKeys.extend(theseKeys)
                if len(_key_resp_13_allKeys):
                    key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
                    key_resp_13.rt = _key_resp_13_allKeys[-1].rt
                    key_resp_13.duration = _key_resp_13_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_13.keys == str('left')) or (key_resp_13.keys == 'left'):
                        key_resp_13.corr = 1
                    else:
                        key_resp_13.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_2* updates
            
            # if LEFT_2 is starting this frame...
            if LEFT_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_2.frameNStart = frameN  # exact frame index
                LEFT_2.tStart = t  # local t and not account for scr refresh
                LEFT_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_2.started')
                # update status
                LEFT_2.status = STARTED
                LEFT_2.setAutoDraw(True)
            
            # if LEFT_2 is active this frame...
            if LEFT_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_3* updates
            
            # if whitesquare_3 is starting this frame...
            if whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_3.frameNStart = frameN  # exact frame index
                whitesquare_3.tStart = t  # local t and not account for scr refresh
                whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_3.started')
                # update status
                whitesquare_3.status = STARTED
                whitesquare_3.setAutoDraw(True)
            
            # if whitesquare_3 is active this frame...
            if whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if whitesquare_3 is stopping this frame...
            if whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_3.tStop = t  # not accounting for scr refresh
                    whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_3.stopped')
                    # update status
                    whitesquare_3.status = FINISHED
                    whitesquare_3.setAutoDraw(False)
            
            # *whitesquare_4* updates
            
            # if whitesquare_4 is starting this frame...
            if whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_4.frameNStart = frameN  # exact frame index
                whitesquare_4.tStart = t  # local t and not account for scr refresh
                whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_4.started')
                # update status
                whitesquare_4.status = STARTED
                whitesquare_4.setAutoDraw(True)
            
            # if whitesquare_4 is active this frame...
            if whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if whitesquare_4 is stopping this frame...
            if whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_4.tStop = t  # not accounting for scr refresh
                    whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_4.stopped')
                    # update status
                    whitesquare_4.status = FINISHED
                    whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_right" ---
        for thisComponent in LEFT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_right
        LEFT_on_right.tStop = globalClock.getTime(format='float')
        LEFT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_right.stopped', LEFT_on_right.tStop)
        # check responses
        if key_resp_13.keys in ['', [], None]:  # No response was made
            key_resp_13.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_13.corr = 1;  # correct non-response
            else:
               key_resp_13.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_13.keys',key_resp_13.keys)
        trials_b3.addData('key_resp_13.corr', key_resp_13.corr)
        if key_resp_13.keys != None:  # we had a response
            trials_b3.addData('key_resp_13.rt', key_resp_13.rt)
            trials_b3.addData('key_resp_13.duration', key_resp_13.duration)
        # the Routine "LEFT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_right" ---
        # create an object to store info about Routine RIGHT_on_right
        RIGHT_on_right = data.Routine(
            name='RIGHT_on_right',
            components=[blacksquare_11, white_cross_11, key_resp_14, RIGHT_3, whitesquare_10, whitesquare_17],
        )
        RIGHT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_14
        key_resp_14.keys = []
        key_resp_14.rt = []
        _key_resp_14_allKeys = []
        # Run 'Begin Routine' code from code_12
        if currentRoutine != "RIGHT_on_right":
            continueRoutine = False
        
        # store start times for RIGHT_on_right
        RIGHT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_right.tStart = globalClock.getTime(format='float')
        RIGHT_on_right.status = STARTED
        thisExp.addData('RIGHT_on_right.started', RIGHT_on_right.tStart)
        RIGHT_on_right.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_rightComponents = RIGHT_on_right.components
        for thisComponent in RIGHT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_11* updates
            
            # if blacksquare_11 is starting this frame...
            if blacksquare_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_11.frameNStart = frameN  # exact frame index
                blacksquare_11.tStart = t  # local t and not account for scr refresh
                blacksquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_11.started')
                # update status
                blacksquare_11.status = STARTED
                blacksquare_11.setAutoDraw(True)
            
            # if blacksquare_11 is active this frame...
            if blacksquare_11.status == STARTED:
                # update params
                pass
            
            # *white_cross_11* updates
            
            # if white_cross_11 is starting this frame...
            if white_cross_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_11.frameNStart = frameN  # exact frame index
                white_cross_11.tStart = t  # local t and not account for scr refresh
                white_cross_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_11.started')
                # update status
                white_cross_11.status = STARTED
                white_cross_11.setAutoDraw(True)
            
            # if white_cross_11 is active this frame...
            if white_cross_11.status == STARTED:
                # update params
                pass
            
            # *key_resp_14* updates
            waitOnFlip = False
            
            # if key_resp_14 is starting this frame...
            if key_resp_14.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_14.frameNStart = frameN  # exact frame index
                key_resp_14.tStart = t  # local t and not account for scr refresh
                key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_14.started')
                # update status
                key_resp_14.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_14.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_14.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_14_allKeys.extend(theseKeys)
                if len(_key_resp_14_allKeys):
                    key_resp_14.keys = _key_resp_14_allKeys[-1].name  # just the last key pressed
                    key_resp_14.rt = _key_resp_14_allKeys[-1].rt
                    key_resp_14.duration = _key_resp_14_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_14.keys == str('left')) or (key_resp_14.keys == 'left'):
                        key_resp_14.corr = 1
                    else:
                        key_resp_14.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_3* updates
            
            # if RIGHT_3 is starting this frame...
            if RIGHT_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_3.frameNStart = frameN  # exact frame index
                RIGHT_3.tStart = t  # local t and not account for scr refresh
                RIGHT_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_3.started')
                # update status
                RIGHT_3.status = STARTED
                RIGHT_3.setAutoDraw(True)
            
            # if RIGHT_3 is active this frame...
            if RIGHT_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_10* updates
            
            # if whitesquare_10 is starting this frame...
            if whitesquare_10.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_10.frameNStart = frameN  # exact frame index
                whitesquare_10.tStart = t  # local t and not account for scr refresh
                whitesquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_10.started')
                # update status
                whitesquare_10.status = STARTED
                whitesquare_10.setAutoDraw(True)
            
            # if whitesquare_10 is active this frame...
            if whitesquare_10.status == STARTED:
                # update params
                pass
            
            # if whitesquare_10 is stopping this frame...
            if whitesquare_10.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_10.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_10.tStop = t  # not accounting for scr refresh
                    whitesquare_10.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_10.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_10.stopped')
                    # update status
                    whitesquare_10.status = FINISHED
                    whitesquare_10.setAutoDraw(False)
            
            # *whitesquare_17* updates
            
            # if whitesquare_17 is starting this frame...
            if whitesquare_17.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_17.frameNStart = frameN  # exact frame index
                whitesquare_17.tStart = t  # local t and not account for scr refresh
                whitesquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_17.started')
                # update status
                whitesquare_17.status = STARTED
                whitesquare_17.setAutoDraw(True)
            
            # if whitesquare_17 is active this frame...
            if whitesquare_17.status == STARTED:
                # update params
                pass
            
            # if whitesquare_17 is stopping this frame...
            if whitesquare_17.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_17.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_17.tStop = t  # not accounting for scr refresh
                    whitesquare_17.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_17.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_17.stopped')
                    # update status
                    whitesquare_17.status = FINISHED
                    whitesquare_17.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_right" ---
        for thisComponent in RIGHT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_right
        RIGHT_on_right.tStop = globalClock.getTime(format='float')
        RIGHT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_right.stopped', RIGHT_on_right.tStop)
        # check responses
        if key_resp_14.keys in ['', [], None]:  # No response was made
            key_resp_14.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_14.corr = 1;  # correct non-response
            else:
               key_resp_14.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_14.keys',key_resp_14.keys)
        trials_b3.addData('key_resp_14.corr', key_resp_14.corr)
        if key_resp_14.keys != None:  # we had a response
            trials_b3.addData('key_resp_14.rt', key_resp_14.rt)
            trials_b3.addData('key_resp_14.duration', key_resp_14.duration)
        # the Routine "RIGHT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_left" ---
        # create an object to store info about Routine LEFT_on_left
        LEFT_on_left = data.Routine(
            name='LEFT_on_left',
            components=[blacksquare_12, white_cross_12, key_resp_15, LEFT_4, whitesquare_6, whitesquare_13],
        )
        LEFT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_15
        key_resp_15.keys = []
        key_resp_15.rt = []
        _key_resp_15_allKeys = []
        # Run 'Begin Routine' code from code_8
        
        
        if currentRoutine != "LEFT_on_left":
            continueRoutine = False
        
        # store start times for LEFT_on_left
        LEFT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_left.tStart = globalClock.getTime(format='float')
        LEFT_on_left.status = STARTED
        thisExp.addData('LEFT_on_left.started', LEFT_on_left.tStart)
        LEFT_on_left.maxDuration = None
        # keep track of which components have finished
        LEFT_on_leftComponents = LEFT_on_left.components
        for thisComponent in LEFT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_12* updates
            
            # if blacksquare_12 is starting this frame...
            if blacksquare_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_12.frameNStart = frameN  # exact frame index
                blacksquare_12.tStart = t  # local t and not account for scr refresh
                blacksquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_12.started')
                # update status
                blacksquare_12.status = STARTED
                blacksquare_12.setAutoDraw(True)
            
            # if blacksquare_12 is active this frame...
            if blacksquare_12.status == STARTED:
                # update params
                pass
            
            # *white_cross_12* updates
            
            # if white_cross_12 is starting this frame...
            if white_cross_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_12.frameNStart = frameN  # exact frame index
                white_cross_12.tStart = t  # local t and not account for scr refresh
                white_cross_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_12.started')
                # update status
                white_cross_12.status = STARTED
                white_cross_12.setAutoDraw(True)
            
            # if white_cross_12 is active this frame...
            if white_cross_12.status == STARTED:
                # update params
                pass
            
            # *key_resp_15* updates
            waitOnFlip = False
            
            # if key_resp_15 is starting this frame...
            if key_resp_15.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_15.frameNStart = frameN  # exact frame index
                key_resp_15.tStart = t  # local t and not account for scr refresh
                key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_15.started')
                # update status
                key_resp_15.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_15.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_15.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_15_allKeys.extend(theseKeys)
                if len(_key_resp_15_allKeys):
                    key_resp_15.keys = _key_resp_15_allKeys[-1].name  # just the last key pressed
                    key_resp_15.rt = _key_resp_15_allKeys[-1].rt
                    key_resp_15.duration = _key_resp_15_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_15.keys == str('left')) or (key_resp_15.keys == 'left'):
                        key_resp_15.corr = 1
                    else:
                        key_resp_15.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_4* updates
            
            # if LEFT_4 is starting this frame...
            if LEFT_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_4.frameNStart = frameN  # exact frame index
                LEFT_4.tStart = t  # local t and not account for scr refresh
                LEFT_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_4.started')
                # update status
                LEFT_4.status = STARTED
                LEFT_4.setAutoDraw(True)
            
            # if LEFT_4 is active this frame...
            if LEFT_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_6* updates
            
            # if whitesquare_6 is starting this frame...
            if whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_6.frameNStart = frameN  # exact frame index
                whitesquare_6.tStart = t  # local t and not account for scr refresh
                whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_6.started')
                # update status
                whitesquare_6.status = STARTED
                whitesquare_6.setAutoDraw(True)
            
            # if whitesquare_6 is active this frame...
            if whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if whitesquare_6 is stopping this frame...
            if whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_6.tStop = t  # not accounting for scr refresh
                    whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_6.stopped')
                    # update status
                    whitesquare_6.status = FINISHED
                    whitesquare_6.setAutoDraw(False)
            
            # *whitesquare_13* updates
            
            # if whitesquare_13 is starting this frame...
            if whitesquare_13.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_13.frameNStart = frameN  # exact frame index
                whitesquare_13.tStart = t  # local t and not account for scr refresh
                whitesquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_13.started')
                # update status
                whitesquare_13.status = STARTED
                whitesquare_13.setAutoDraw(True)
            
            # if whitesquare_13 is active this frame...
            if whitesquare_13.status == STARTED:
                # update params
                pass
            
            # if whitesquare_13 is stopping this frame...
            if whitesquare_13.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_13.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_13.tStop = t  # not accounting for scr refresh
                    whitesquare_13.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_13.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_13.stopped')
                    # update status
                    whitesquare_13.status = FINISHED
                    whitesquare_13.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_left" ---
        for thisComponent in LEFT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_left
        LEFT_on_left.tStop = globalClock.getTime(format='float')
        LEFT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_left.stopped', LEFT_on_left.tStop)
        # check responses
        if key_resp_15.keys in ['', [], None]:  # No response was made
            key_resp_15.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_15.corr = 1;  # correct non-response
            else:
               key_resp_15.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_15.keys',key_resp_15.keys)
        trials_b3.addData('key_resp_15.corr', key_resp_15.corr)
        if key_resp_15.keys != None:  # we had a response
            trials_b3.addData('key_resp_15.rt', key_resp_15.rt)
            trials_b3.addData('key_resp_15.duration', key_resp_15.duration)
        # the Routine "LEFT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_left" ---
        # create an object to store info about Routine RIGHT_on_left
        RIGHT_on_left = data.Routine(
            name='RIGHT_on_left',
            components=[blacksquare_13, white_cross_13, key_resp_16, RIGHT_5, whitesquare_8, whitesquare_15],
        )
        RIGHT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_16
        key_resp_16.keys = []
        key_resp_16.rt = []
        _key_resp_16_allKeys = []
        # Run 'Begin Routine' code from code_10
        
        if currentRoutine != "RIGHT_on_left":
            continueRoutine = False
        
        # store start times for RIGHT_on_left
        RIGHT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_left.tStart = globalClock.getTime(format='float')
        RIGHT_on_left.status = STARTED
        thisExp.addData('RIGHT_on_left.started', RIGHT_on_left.tStart)
        RIGHT_on_left.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_leftComponents = RIGHT_on_left.components
        for thisComponent in RIGHT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_13* updates
            
            # if blacksquare_13 is starting this frame...
            if blacksquare_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_13.frameNStart = frameN  # exact frame index
                blacksquare_13.tStart = t  # local t and not account for scr refresh
                blacksquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_13.started')
                # update status
                blacksquare_13.status = STARTED
                blacksquare_13.setAutoDraw(True)
            
            # if blacksquare_13 is active this frame...
            if blacksquare_13.status == STARTED:
                # update params
                pass
            
            # *white_cross_13* updates
            
            # if white_cross_13 is starting this frame...
            if white_cross_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_13.frameNStart = frameN  # exact frame index
                white_cross_13.tStart = t  # local t and not account for scr refresh
                white_cross_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_13.started')
                # update status
                white_cross_13.status = STARTED
                white_cross_13.setAutoDraw(True)
            
            # if white_cross_13 is active this frame...
            if white_cross_13.status == STARTED:
                # update params
                pass
            
            # *key_resp_16* updates
            waitOnFlip = False
            
            # if key_resp_16 is starting this frame...
            if key_resp_16.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_16.frameNStart = frameN  # exact frame index
                key_resp_16.tStart = t  # local t and not account for scr refresh
                key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_16.started')
                # update status
                key_resp_16.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_16.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_16.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_16_allKeys.extend(theseKeys)
                if len(_key_resp_16_allKeys):
                    key_resp_16.keys = _key_resp_16_allKeys[-1].name  # just the last key pressed
                    key_resp_16.rt = _key_resp_16_allKeys[-1].rt
                    key_resp_16.duration = _key_resp_16_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_16.keys == str('left')) or (key_resp_16.keys == 'left'):
                        key_resp_16.corr = 1
                    else:
                        key_resp_16.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_5* updates
            
            # if RIGHT_5 is starting this frame...
            if RIGHT_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_5.frameNStart = frameN  # exact frame index
                RIGHT_5.tStart = t  # local t and not account for scr refresh
                RIGHT_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_5.started')
                # update status
                RIGHT_5.status = STARTED
                RIGHT_5.setAutoDraw(True)
            
            # if RIGHT_5 is active this frame...
            if RIGHT_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_8* updates
            
            # if whitesquare_8 is starting this frame...
            if whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_8.frameNStart = frameN  # exact frame index
                whitesquare_8.tStart = t  # local t and not account for scr refresh
                whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_8.started')
                # update status
                whitesquare_8.status = STARTED
                whitesquare_8.setAutoDraw(True)
            
            # if whitesquare_8 is active this frame...
            if whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if whitesquare_8 is stopping this frame...
            if whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_8.tStop = t  # not accounting for scr refresh
                    whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_8.stopped')
                    # update status
                    whitesquare_8.status = FINISHED
                    whitesquare_8.setAutoDraw(False)
            
            # *whitesquare_15* updates
            
            # if whitesquare_15 is starting this frame...
            if whitesquare_15.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_15.frameNStart = frameN  # exact frame index
                whitesquare_15.tStart = t  # local t and not account for scr refresh
                whitesquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_15.started')
                # update status
                whitesquare_15.status = STARTED
                whitesquare_15.setAutoDraw(True)
            
            # if whitesquare_15 is active this frame...
            if whitesquare_15.status == STARTED:
                # update params
                pass
            
            # if whitesquare_15 is stopping this frame...
            if whitesquare_15.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_15.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_15.tStop = t  # not accounting for scr refresh
                    whitesquare_15.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_15.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_15.stopped')
                    # update status
                    whitesquare_15.status = FINISHED
                    whitesquare_15.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_left" ---
        for thisComponent in RIGHT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_left
        RIGHT_on_left.tStop = globalClock.getTime(format='float')
        RIGHT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_left.stopped', RIGHT_on_left.tStop)
        # check responses
        if key_resp_16.keys in ['', [], None]:  # No response was made
            key_resp_16.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_16.corr = 1;  # correct non-response
            else:
               key_resp_16.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_16.keys',key_resp_16.keys)
        trials_b3.addData('key_resp_16.corr', key_resp_16.corr)
        if key_resp_16.keys != None:  # we had a response
            trials_b3.addData('key_resp_16.rt', key_resp_16.rt)
            trials_b3.addData('key_resp_16.duration', key_resp_16.duration)
        # the Routine "RIGHT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_up" ---
        # create an object to store info about Routine UP_on_up
        UP_on_up = data.Routine(
            name='UP_on_up',
            components=[blacksquare_14, white_cross_14, key_resp_17, UP_5, up_whitesquare_2, down_whitesquare_2],
        )
        UP_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_17
        key_resp_17.keys = []
        key_resp_17.rt = []
        _key_resp_17_allKeys = []
        # Run 'Begin Routine' code from code_14
        
        if currentRoutine != "UP_on_up":
            continueRoutine = False
        
        # store start times for UP_on_up
        UP_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_up.tStart = globalClock.getTime(format='float')
        UP_on_up.status = STARTED
        thisExp.addData('UP_on_up.started', UP_on_up.tStart)
        UP_on_up.maxDuration = None
        # keep track of which components have finished
        UP_on_upComponents = UP_on_up.components
        for thisComponent in UP_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        UP_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_14* updates
            
            # if blacksquare_14 is starting this frame...
            if blacksquare_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_14.frameNStart = frameN  # exact frame index
                blacksquare_14.tStart = t  # local t and not account for scr refresh
                blacksquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_14.started')
                # update status
                blacksquare_14.status = STARTED
                blacksquare_14.setAutoDraw(True)
            
            # if blacksquare_14 is active this frame...
            if blacksquare_14.status == STARTED:
                # update params
                pass
            
            # *white_cross_14* updates
            
            # if white_cross_14 is starting this frame...
            if white_cross_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_14.frameNStart = frameN  # exact frame index
                white_cross_14.tStart = t  # local t and not account for scr refresh
                white_cross_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_14.started')
                # update status
                white_cross_14.status = STARTED
                white_cross_14.setAutoDraw(True)
            
            # if white_cross_14 is active this frame...
            if white_cross_14.status == STARTED:
                # update params
                pass
            
            # *key_resp_17* updates
            waitOnFlip = False
            
            # if key_resp_17 is starting this frame...
            if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_17.frameNStart = frameN  # exact frame index
                key_resp_17.tStart = t  # local t and not account for scr refresh
                key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_17.started')
                # update status
                key_resp_17.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_17.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_17.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_17_allKeys.extend(theseKeys)
                if len(_key_resp_17_allKeys):
                    key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
                    key_resp_17.rt = _key_resp_17_allKeys[-1].rt
                    key_resp_17.duration = _key_resp_17_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_17.keys == str('left')) or (key_resp_17.keys == 'left'):
                        key_resp_17.corr = 1
                    else:
                        key_resp_17.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_5* updates
            
            # if UP_5 is starting this frame...
            if UP_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_5.frameNStart = frameN  # exact frame index
                UP_5.tStart = t  # local t and not account for scr refresh
                UP_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_5.started')
                # update status
                UP_5.status = STARTED
                UP_5.setAutoDraw(True)
            
            # if UP_5 is active this frame...
            if UP_5.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_2* updates
            
            # if up_whitesquare_2 is starting this frame...
            if up_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_2.frameNStart = frameN  # exact frame index
                up_whitesquare_2.tStart = t  # local t and not account for scr refresh
                up_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_2.started')
                # update status
                up_whitesquare_2.status = STARTED
                up_whitesquare_2.setAutoDraw(True)
            
            # if up_whitesquare_2 is active this frame...
            if up_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_2 is stopping this frame...
            if up_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_2.tStop = t  # not accounting for scr refresh
                    up_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_2.stopped')
                    # update status
                    up_whitesquare_2.status = FINISHED
                    up_whitesquare_2.setAutoDraw(False)
            
            # *down_whitesquare_2* updates
            
            # if down_whitesquare_2 is starting this frame...
            if down_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_2.frameNStart = frameN  # exact frame index
                down_whitesquare_2.tStart = t  # local t and not account for scr refresh
                down_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_2.started')
                # update status
                down_whitesquare_2.status = STARTED
                down_whitesquare_2.setAutoDraw(True)
            
            # if down_whitesquare_2 is active this frame...
            if down_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_2 is stopping this frame...
            if down_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_2.tStop = t  # not accounting for scr refresh
                    down_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_2.stopped')
                    # update status
                    down_whitesquare_2.status = FINISHED
                    down_whitesquare_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_up" ---
        for thisComponent in UP_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_up
        UP_on_up.tStop = globalClock.getTime(format='float')
        UP_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_up.stopped', UP_on_up.tStop)
        # check responses
        if key_resp_17.keys in ['', [], None]:  # No response was made
            key_resp_17.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_17.corr = 1;  # correct non-response
            else:
               key_resp_17.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_17.keys',key_resp_17.keys)
        trials_b3.addData('key_resp_17.corr', key_resp_17.corr)
        if key_resp_17.keys != None:  # we had a response
            trials_b3.addData('key_resp_17.rt', key_resp_17.rt)
            trials_b3.addData('key_resp_17.duration', key_resp_17.duration)
        # the Routine "UP_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_up" ---
        # create an object to store info about Routine DOWN_on_up
        DOWN_on_up = data.Routine(
            name='DOWN_on_up',
            components=[blacksquare_15, white_cross_15, key_resp_18, UP, up_whitesquare_4, down_whitesquare_4],
        )
        DOWN_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_18
        key_resp_18.keys = []
        key_resp_18.rt = []
        _key_resp_18_allKeys = []
        # Run 'Begin Routine' code from code_16
        
        
        if currentRoutine != "DOWN_on_up":
            continueRoutine = False
        
        # store start times for DOWN_on_up
        DOWN_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_up.tStart = globalClock.getTime(format='float')
        DOWN_on_up.status = STARTED
        thisExp.addData('DOWN_on_up.started', DOWN_on_up.tStart)
        DOWN_on_up.maxDuration = None
        # keep track of which components have finished
        DOWN_on_upComponents = DOWN_on_up.components
        for thisComponent in DOWN_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_15* updates
            
            # if blacksquare_15 is starting this frame...
            if blacksquare_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_15.frameNStart = frameN  # exact frame index
                blacksquare_15.tStart = t  # local t and not account for scr refresh
                blacksquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_15.started')
                # update status
                blacksquare_15.status = STARTED
                blacksquare_15.setAutoDraw(True)
            
            # if blacksquare_15 is active this frame...
            if blacksquare_15.status == STARTED:
                # update params
                pass
            
            # *white_cross_15* updates
            
            # if white_cross_15 is starting this frame...
            if white_cross_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_15.frameNStart = frameN  # exact frame index
                white_cross_15.tStart = t  # local t and not account for scr refresh
                white_cross_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_15.started')
                # update status
                white_cross_15.status = STARTED
                white_cross_15.setAutoDraw(True)
            
            # if white_cross_15 is active this frame...
            if white_cross_15.status == STARTED:
                # update params
                pass
            
            # *key_resp_18* updates
            waitOnFlip = False
            
            # if key_resp_18 is starting this frame...
            if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_18.frameNStart = frameN  # exact frame index
                key_resp_18.tStart = t  # local t and not account for scr refresh
                key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_18.started')
                # update status
                key_resp_18.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_18.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_18.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_18_allKeys.extend(theseKeys)
                if len(_key_resp_18_allKeys):
                    key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
                    key_resp_18.rt = _key_resp_18_allKeys[-1].rt
                    key_resp_18.duration = _key_resp_18_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_18.keys == str('left')) or (key_resp_18.keys == 'left'):
                        key_resp_18.corr = 1
                    else:
                        key_resp_18.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP* updates
            
            # if UP is starting this frame...
            if UP.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP.frameNStart = frameN  # exact frame index
                UP.tStart = t  # local t and not account for scr refresh
                UP.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP.started')
                # update status
                UP.status = STARTED
                UP.setAutoDraw(True)
            
            # if UP is active this frame...
            if UP.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_4* updates
            
            # if up_whitesquare_4 is starting this frame...
            if up_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_4.frameNStart = frameN  # exact frame index
                up_whitesquare_4.tStart = t  # local t and not account for scr refresh
                up_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_4.started')
                # update status
                up_whitesquare_4.status = STARTED
                up_whitesquare_4.setAutoDraw(True)
            
            # if up_whitesquare_4 is active this frame...
            if up_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_4 is stopping this frame...
            if up_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_4.tStop = t  # not accounting for scr refresh
                    up_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_4.stopped')
                    # update status
                    up_whitesquare_4.status = FINISHED
                    up_whitesquare_4.setAutoDraw(False)
            
            # *down_whitesquare_4* updates
            
            # if down_whitesquare_4 is starting this frame...
            if down_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_4.frameNStart = frameN  # exact frame index
                down_whitesquare_4.tStart = t  # local t and not account for scr refresh
                down_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_4.started')
                # update status
                down_whitesquare_4.status = STARTED
                down_whitesquare_4.setAutoDraw(True)
            
            # if down_whitesquare_4 is active this frame...
            if down_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_4 is stopping this frame...
            if down_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_4.tStop = t  # not accounting for scr refresh
                    down_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_4.stopped')
                    # update status
                    down_whitesquare_4.status = FINISHED
                    down_whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_up" ---
        for thisComponent in DOWN_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_up
        DOWN_on_up.tStop = globalClock.getTime(format='float')
        DOWN_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_up.stopped', DOWN_on_up.tStop)
        # check responses
        if key_resp_18.keys in ['', [], None]:  # No response was made
            key_resp_18.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_18.corr = 1;  # correct non-response
            else:
               key_resp_18.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_18.keys',key_resp_18.keys)
        trials_b3.addData('key_resp_18.corr', key_resp_18.corr)
        if key_resp_18.keys != None:  # we had a response
            trials_b3.addData('key_resp_18.rt', key_resp_18.rt)
            trials_b3.addData('key_resp_18.duration', key_resp_18.duration)
        # the Routine "DOWN_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_down" ---
        # create an object to store info about Routine UP_on_down
        UP_on_down = data.Routine(
            name='UP_on_down',
            components=[blacksquare_16, white_cross_16, key_resp_19, UP_6, up_whitesquare_6, down_whitesquare_6],
        )
        UP_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_19
        key_resp_19.keys = []
        key_resp_19.rt = []
        _key_resp_19_allKeys = []
        # Run 'Begin Routine' code from code_18
        
        
        if currentRoutine != "UP_on_down":
            continueRoutine = False
        
        # store start times for UP_on_down
        UP_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_down.tStart = globalClock.getTime(format='float')
        UP_on_down.status = STARTED
        thisExp.addData('UP_on_down.started', UP_on_down.tStart)
        UP_on_down.maxDuration = None
        # keep track of which components have finished
        UP_on_downComponents = UP_on_down.components
        for thisComponent in UP_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        UP_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_16* updates
            
            # if blacksquare_16 is starting this frame...
            if blacksquare_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_16.frameNStart = frameN  # exact frame index
                blacksquare_16.tStart = t  # local t and not account for scr refresh
                blacksquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_16.started')
                # update status
                blacksquare_16.status = STARTED
                blacksquare_16.setAutoDraw(True)
            
            # if blacksquare_16 is active this frame...
            if blacksquare_16.status == STARTED:
                # update params
                pass
            
            # *white_cross_16* updates
            
            # if white_cross_16 is starting this frame...
            if white_cross_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_16.frameNStart = frameN  # exact frame index
                white_cross_16.tStart = t  # local t and not account for scr refresh
                white_cross_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_16.started')
                # update status
                white_cross_16.status = STARTED
                white_cross_16.setAutoDraw(True)
            
            # if white_cross_16 is active this frame...
            if white_cross_16.status == STARTED:
                # update params
                pass
            
            # *key_resp_19* updates
            waitOnFlip = False
            
            # if key_resp_19 is starting this frame...
            if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_19.frameNStart = frameN  # exact frame index
                key_resp_19.tStart = t  # local t and not account for scr refresh
                key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_19.started')
                # update status
                key_resp_19.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_19.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_19.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_19_allKeys.extend(theseKeys)
                if len(_key_resp_19_allKeys):
                    key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
                    key_resp_19.rt = _key_resp_19_allKeys[-1].rt
                    key_resp_19.duration = _key_resp_19_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_19.keys == str('left')) or (key_resp_19.keys == 'left'):
                        key_resp_19.corr = 1
                    else:
                        key_resp_19.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_6* updates
            
            # if UP_6 is starting this frame...
            if UP_6.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_6.frameNStart = frameN  # exact frame index
                UP_6.tStart = t  # local t and not account for scr refresh
                UP_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_6.started')
                # update status
                UP_6.status = STARTED
                UP_6.setAutoDraw(True)
            
            # if UP_6 is active this frame...
            if UP_6.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_6* updates
            
            # if up_whitesquare_6 is starting this frame...
            if up_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_6.frameNStart = frameN  # exact frame index
                up_whitesquare_6.tStart = t  # local t and not account for scr refresh
                up_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_6.started')
                # update status
                up_whitesquare_6.status = STARTED
                up_whitesquare_6.setAutoDraw(True)
            
            # if up_whitesquare_6 is active this frame...
            if up_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_6 is stopping this frame...
            if up_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_6.tStop = t  # not accounting for scr refresh
                    up_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_6.stopped')
                    # update status
                    up_whitesquare_6.status = FINISHED
                    up_whitesquare_6.setAutoDraw(False)
            
            # *down_whitesquare_6* updates
            
            # if down_whitesquare_6 is starting this frame...
            if down_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_6.frameNStart = frameN  # exact frame index
                down_whitesquare_6.tStart = t  # local t and not account for scr refresh
                down_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_6.started')
                # update status
                down_whitesquare_6.status = STARTED
                down_whitesquare_6.setAutoDraw(True)
            
            # if down_whitesquare_6 is active this frame...
            if down_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_6 is stopping this frame...
            if down_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_6.tStop = t  # not accounting for scr refresh
                    down_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_6.stopped')
                    # update status
                    down_whitesquare_6.status = FINISHED
                    down_whitesquare_6.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_down" ---
        for thisComponent in UP_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_down
        UP_on_down.tStop = globalClock.getTime(format='float')
        UP_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_down.stopped', UP_on_down.tStop)
        # check responses
        if key_resp_19.keys in ['', [], None]:  # No response was made
            key_resp_19.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_19.corr = 1;  # correct non-response
            else:
               key_resp_19.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_19.keys',key_resp_19.keys)
        trials_b3.addData('key_resp_19.corr', key_resp_19.corr)
        if key_resp_19.keys != None:  # we had a response
            trials_b3.addData('key_resp_19.rt', key_resp_19.rt)
            trials_b3.addData('key_resp_19.duration', key_resp_19.duration)
        # the Routine "UP_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_down" ---
        # create an object to store info about Routine DOWN_on_down
        DOWN_on_down = data.Routine(
            name='DOWN_on_down',
            components=[blacksquare_17, white_cross_17, key_resp_20, UP_7, up_whitesquare_8, down_whitesquare_8],
        )
        DOWN_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_20
        key_resp_20.keys = []
        key_resp_20.rt = []
        _key_resp_20_allKeys = []
        # Run 'Begin Routine' code from code_20
        
        
        if currentRoutine != "DOWN_on_down":
            continueRoutine = False
        
        # store start times for DOWN_on_down
        DOWN_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_down.tStart = globalClock.getTime(format='float')
        DOWN_on_down.status = STARTED
        thisExp.addData('DOWN_on_down.started', DOWN_on_down.tStart)
        DOWN_on_down.maxDuration = None
        # keep track of which components have finished
        DOWN_on_downComponents = DOWN_on_down.components
        for thisComponent in DOWN_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_17* updates
            
            # if blacksquare_17 is starting this frame...
            if blacksquare_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_17.frameNStart = frameN  # exact frame index
                blacksquare_17.tStart = t  # local t and not account for scr refresh
                blacksquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_17.started')
                # update status
                blacksquare_17.status = STARTED
                blacksquare_17.setAutoDraw(True)
            
            # if blacksquare_17 is active this frame...
            if blacksquare_17.status == STARTED:
                # update params
                pass
            
            # *white_cross_17* updates
            
            # if white_cross_17 is starting this frame...
            if white_cross_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_17.frameNStart = frameN  # exact frame index
                white_cross_17.tStart = t  # local t and not account for scr refresh
                white_cross_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_17.started')
                # update status
                white_cross_17.status = STARTED
                white_cross_17.setAutoDraw(True)
            
            # if white_cross_17 is active this frame...
            if white_cross_17.status == STARTED:
                # update params
                pass
            
            # *key_resp_20* updates
            waitOnFlip = False
            
            # if key_resp_20 is starting this frame...
            if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_20.frameNStart = frameN  # exact frame index
                key_resp_20.tStart = t  # local t and not account for scr refresh
                key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_20.started')
                # update status
                key_resp_20.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_20.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_20.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_20_allKeys.extend(theseKeys)
                if len(_key_resp_20_allKeys):
                    key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
                    key_resp_20.rt = _key_resp_20_allKeys[-1].rt
                    key_resp_20.duration = _key_resp_20_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_20.keys == str('left')) or (key_resp_20.keys == 'left'):
                        key_resp_20.corr = 1
                    else:
                        key_resp_20.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_7* updates
            
            # if UP_7 is starting this frame...
            if UP_7.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_7.frameNStart = frameN  # exact frame index
                UP_7.tStart = t  # local t and not account for scr refresh
                UP_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_7.started')
                # update status
                UP_7.status = STARTED
                UP_7.setAutoDraw(True)
            
            # if UP_7 is active this frame...
            if UP_7.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_8* updates
            
            # if up_whitesquare_8 is starting this frame...
            if up_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_8.frameNStart = frameN  # exact frame index
                up_whitesquare_8.tStart = t  # local t and not account for scr refresh
                up_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_8.started')
                # update status
                up_whitesquare_8.status = STARTED
                up_whitesquare_8.setAutoDraw(True)
            
            # if up_whitesquare_8 is active this frame...
            if up_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_8 is stopping this frame...
            if up_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_8.tStop = t  # not accounting for scr refresh
                    up_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_8.stopped')
                    # update status
                    up_whitesquare_8.status = FINISHED
                    up_whitesquare_8.setAutoDraw(False)
            
            # *down_whitesquare_8* updates
            
            # if down_whitesquare_8 is starting this frame...
            if down_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_8.frameNStart = frameN  # exact frame index
                down_whitesquare_8.tStart = t  # local t and not account for scr refresh
                down_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_8.started')
                # update status
                down_whitesquare_8.status = STARTED
                down_whitesquare_8.setAutoDraw(True)
            
            # if down_whitesquare_8 is active this frame...
            if down_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_8 is stopping this frame...
            if down_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_8.tStop = t  # not accounting for scr refresh
                    down_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_8.stopped')
                    # update status
                    down_whitesquare_8.status = FINISHED
                    down_whitesquare_8.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_down" ---
        for thisComponent in DOWN_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_down
        DOWN_on_down.tStop = globalClock.getTime(format='float')
        DOWN_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_down.stopped', DOWN_on_down.tStop)
        # check responses
        if key_resp_20.keys in ['', [], None]:  # No response was made
            key_resp_20.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_20.corr = 1;  # correct non-response
            else:
               key_resp_20.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_20.keys',key_resp_20.keys)
        trials_b3.addData('key_resp_20.corr', key_resp_20.corr)
        if key_resp_20.keys != None:  # we had a response
            trials_b3.addData('key_resp_20.rt', key_resp_20.rt)
            trials_b3.addData('key_resp_20.duration', key_resp_20.duration)
        # the Routine "DOWN_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_right" ---
        # create an object to store info about Routine leftA_on_right
        leftA_on_right = data.Routine(
            name='leftA_on_right',
            components=[blacksquare_18, white_cross_18, key_resp_21, arrow_l_2, whitesquare_5, whitesquare_12],
        )
        leftA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_21
        key_resp_21.keys = []
        key_resp_21.rt = []
        _key_resp_21_allKeys = []
        # Run 'Begin Routine' code from code_7
        
        
        if currentRoutine != "leftA_on_right":
            continueRoutine = False
        
        # store start times for leftA_on_right
        leftA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_right.tStart = globalClock.getTime(format='float')
        leftA_on_right.status = STARTED
        thisExp.addData('leftA_on_right.started', leftA_on_right.tStart)
        leftA_on_right.maxDuration = None
        # keep track of which components have finished
        leftA_on_rightComponents = leftA_on_right.components
        for thisComponent in leftA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        leftA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_18* updates
            
            # if blacksquare_18 is starting this frame...
            if blacksquare_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_18.frameNStart = frameN  # exact frame index
                blacksquare_18.tStart = t  # local t and not account for scr refresh
                blacksquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_18.started')
                # update status
                blacksquare_18.status = STARTED
                blacksquare_18.setAutoDraw(True)
            
            # if blacksquare_18 is active this frame...
            if blacksquare_18.status == STARTED:
                # update params
                pass
            
            # *white_cross_18* updates
            
            # if white_cross_18 is starting this frame...
            if white_cross_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_18.frameNStart = frameN  # exact frame index
                white_cross_18.tStart = t  # local t and not account for scr refresh
                white_cross_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_18.started')
                # update status
                white_cross_18.status = STARTED
                white_cross_18.setAutoDraw(True)
            
            # if white_cross_18 is active this frame...
            if white_cross_18.status == STARTED:
                # update params
                pass
            
            # *key_resp_21* updates
            waitOnFlip = False
            
            # if key_resp_21 is starting this frame...
            if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_21.frameNStart = frameN  # exact frame index
                key_resp_21.tStart = t  # local t and not account for scr refresh
                key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_21.started')
                # update status
                key_resp_21.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_21.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_21.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_21_allKeys.extend(theseKeys)
                if len(_key_resp_21_allKeys):
                    key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
                    key_resp_21.rt = _key_resp_21_allKeys[-1].rt
                    key_resp_21.duration = _key_resp_21_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_21.keys == str('left')) or (key_resp_21.keys == 'left'):
                        key_resp_21.corr = 1
                    else:
                        key_resp_21.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_2* updates
            
            # if arrow_l_2 is starting this frame...
            if arrow_l_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_2.frameNStart = frameN  # exact frame index
                arrow_l_2.tStart = t  # local t and not account for scr refresh
                arrow_l_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_2.started')
                # update status
                arrow_l_2.status = STARTED
                arrow_l_2.setAutoDraw(True)
            
            # if arrow_l_2 is active this frame...
            if arrow_l_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_5* updates
            
            # if whitesquare_5 is starting this frame...
            if whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_5.frameNStart = frameN  # exact frame index
                whitesquare_5.tStart = t  # local t and not account for scr refresh
                whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_5.started')
                # update status
                whitesquare_5.status = STARTED
                whitesquare_5.setAutoDraw(True)
            
            # if whitesquare_5 is active this frame...
            if whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if whitesquare_5 is stopping this frame...
            if whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_5.tStop = t  # not accounting for scr refresh
                    whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_5.stopped')
                    # update status
                    whitesquare_5.status = FINISHED
                    whitesquare_5.setAutoDraw(False)
            
            # *whitesquare_12* updates
            
            # if whitesquare_12 is starting this frame...
            if whitesquare_12.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_12.frameNStart = frameN  # exact frame index
                whitesquare_12.tStart = t  # local t and not account for scr refresh
                whitesquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_12.started')
                # update status
                whitesquare_12.status = STARTED
                whitesquare_12.setAutoDraw(True)
            
            # if whitesquare_12 is active this frame...
            if whitesquare_12.status == STARTED:
                # update params
                pass
            
            # if whitesquare_12 is stopping this frame...
            if whitesquare_12.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_12.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_12.tStop = t  # not accounting for scr refresh
                    whitesquare_12.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_12.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_12.stopped')
                    # update status
                    whitesquare_12.status = FINISHED
                    whitesquare_12.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_right" ---
        for thisComponent in leftA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_right
        leftA_on_right.tStop = globalClock.getTime(format='float')
        leftA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_right.stopped', leftA_on_right.tStop)
        # check responses
        if key_resp_21.keys in ['', [], None]:  # No response was made
            key_resp_21.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_21.corr = 1;  # correct non-response
            else:
               key_resp_21.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_21.keys',key_resp_21.keys)
        trials_b3.addData('key_resp_21.corr', key_resp_21.corr)
        if key_resp_21.keys != None:  # we had a response
            trials_b3.addData('key_resp_21.rt', key_resp_21.rt)
            trials_b3.addData('key_resp_21.duration', key_resp_21.duration)
        # the Routine "leftA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_left" ---
        # create an object to store info about Routine leftA_on_left
        leftA_on_left = data.Routine(
            name='leftA_on_left',
            components=[blacksquare_19, white_cross_19, key_resp_22, arrow_l_3, whitesquare_7, whitesquare_14],
        )
        leftA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_22
        key_resp_22.keys = []
        key_resp_22.rt = []
        _key_resp_22_allKeys = []
        # Run 'Begin Routine' code from code_9
        
        
        if currentRoutine != "leftA_on_left":
            continueRoutine = False
        
        # store start times for leftA_on_left
        leftA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_left.tStart = globalClock.getTime(format='float')
        leftA_on_left.status = STARTED
        thisExp.addData('leftA_on_left.started', leftA_on_left.tStart)
        leftA_on_left.maxDuration = None
        # keep track of which components have finished
        leftA_on_leftComponents = leftA_on_left.components
        for thisComponent in leftA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        leftA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_19* updates
            
            # if blacksquare_19 is starting this frame...
            if blacksquare_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_19.frameNStart = frameN  # exact frame index
                blacksquare_19.tStart = t  # local t and not account for scr refresh
                blacksquare_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_19.started')
                # update status
                blacksquare_19.status = STARTED
                blacksquare_19.setAutoDraw(True)
            
            # if blacksquare_19 is active this frame...
            if blacksquare_19.status == STARTED:
                # update params
                pass
            
            # *white_cross_19* updates
            
            # if white_cross_19 is starting this frame...
            if white_cross_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_19.frameNStart = frameN  # exact frame index
                white_cross_19.tStart = t  # local t and not account for scr refresh
                white_cross_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_19.started')
                # update status
                white_cross_19.status = STARTED
                white_cross_19.setAutoDraw(True)
            
            # if white_cross_19 is active this frame...
            if white_cross_19.status == STARTED:
                # update params
                pass
            
            # *key_resp_22* updates
            waitOnFlip = False
            
            # if key_resp_22 is starting this frame...
            if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_22.frameNStart = frameN  # exact frame index
                key_resp_22.tStart = t  # local t and not account for scr refresh
                key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_22.started')
                # update status
                key_resp_22.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_22.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_22.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_22_allKeys.extend(theseKeys)
                if len(_key_resp_22_allKeys):
                    key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
                    key_resp_22.rt = _key_resp_22_allKeys[-1].rt
                    key_resp_22.duration = _key_resp_22_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_22.keys == str('left')) or (key_resp_22.keys == 'left'):
                        key_resp_22.corr = 1
                    else:
                        key_resp_22.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_3* updates
            
            # if arrow_l_3 is starting this frame...
            if arrow_l_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_3.frameNStart = frameN  # exact frame index
                arrow_l_3.tStart = t  # local t and not account for scr refresh
                arrow_l_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_3.started')
                # update status
                arrow_l_3.status = STARTED
                arrow_l_3.setAutoDraw(True)
            
            # if arrow_l_3 is active this frame...
            if arrow_l_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_7* updates
            
            # if whitesquare_7 is starting this frame...
            if whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_7.frameNStart = frameN  # exact frame index
                whitesquare_7.tStart = t  # local t and not account for scr refresh
                whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_7.started')
                # update status
                whitesquare_7.status = STARTED
                whitesquare_7.setAutoDraw(True)
            
            # if whitesquare_7 is active this frame...
            if whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if whitesquare_7 is stopping this frame...
            if whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_7.tStop = t  # not accounting for scr refresh
                    whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_7.stopped')
                    # update status
                    whitesquare_7.status = FINISHED
                    whitesquare_7.setAutoDraw(False)
            
            # *whitesquare_14* updates
            
            # if whitesquare_14 is starting this frame...
            if whitesquare_14.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_14.frameNStart = frameN  # exact frame index
                whitesquare_14.tStart = t  # local t and not account for scr refresh
                whitesquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_14.started')
                # update status
                whitesquare_14.status = STARTED
                whitesquare_14.setAutoDraw(True)
            
            # if whitesquare_14 is active this frame...
            if whitesquare_14.status == STARTED:
                # update params
                pass
            
            # if whitesquare_14 is stopping this frame...
            if whitesquare_14.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_14.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_14.tStop = t  # not accounting for scr refresh
                    whitesquare_14.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_14.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_14.stopped')
                    # update status
                    whitesquare_14.status = FINISHED
                    whitesquare_14.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_left" ---
        for thisComponent in leftA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_left
        leftA_on_left.tStop = globalClock.getTime(format='float')
        leftA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_left.stopped', leftA_on_left.tStop)
        # check responses
        if key_resp_22.keys in ['', [], None]:  # No response was made
            key_resp_22.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_22.corr = 1;  # correct non-response
            else:
               key_resp_22.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_22.keys',key_resp_22.keys)
        trials_b3.addData('key_resp_22.corr', key_resp_22.corr)
        if key_resp_22.keys != None:  # we had a response
            trials_b3.addData('key_resp_22.rt', key_resp_22.rt)
            trials_b3.addData('key_resp_22.duration', key_resp_22.duration)
        # the Routine "leftA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_right" ---
        # create an object to store info about Routine rightA_on_right
        rightA_on_right = data.Routine(
            name='rightA_on_right',
            components=[blacksquare_20, white_cross_20, key_resp_23, arrow_l_4, whitesquare_11, whitesquare_18],
        )
        rightA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_23
        key_resp_23.keys = []
        key_resp_23.rt = []
        _key_resp_23_allKeys = []
        # Run 'Begin Routine' code from code_13
        
        
        if currentRoutine != "rightA_on_right":
            continueRoutine = False
        
        # store start times for rightA_on_right
        rightA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_right.tStart = globalClock.getTime(format='float')
        rightA_on_right.status = STARTED
        thisExp.addData('rightA_on_right.started', rightA_on_right.tStart)
        rightA_on_right.maxDuration = None
        # keep track of which components have finished
        rightA_on_rightComponents = rightA_on_right.components
        for thisComponent in rightA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        rightA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_20* updates
            
            # if blacksquare_20 is starting this frame...
            if blacksquare_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_20.frameNStart = frameN  # exact frame index
                blacksquare_20.tStart = t  # local t and not account for scr refresh
                blacksquare_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_20.started')
                # update status
                blacksquare_20.status = STARTED
                blacksquare_20.setAutoDraw(True)
            
            # if blacksquare_20 is active this frame...
            if blacksquare_20.status == STARTED:
                # update params
                pass
            
            # *white_cross_20* updates
            
            # if white_cross_20 is starting this frame...
            if white_cross_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_20.frameNStart = frameN  # exact frame index
                white_cross_20.tStart = t  # local t and not account for scr refresh
                white_cross_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_20.started')
                # update status
                white_cross_20.status = STARTED
                white_cross_20.setAutoDraw(True)
            
            # if white_cross_20 is active this frame...
            if white_cross_20.status == STARTED:
                # update params
                pass
            
            # *key_resp_23* updates
            waitOnFlip = False
            
            # if key_resp_23 is starting this frame...
            if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_23.frameNStart = frameN  # exact frame index
                key_resp_23.tStart = t  # local t and not account for scr refresh
                key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_23.started')
                # update status
                key_resp_23.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_23.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_23.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_23_allKeys.extend(theseKeys)
                if len(_key_resp_23_allKeys):
                    key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
                    key_resp_23.rt = _key_resp_23_allKeys[-1].rt
                    key_resp_23.duration = _key_resp_23_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_23.keys == str('left')) or (key_resp_23.keys == 'left'):
                        key_resp_23.corr = 1
                    else:
                        key_resp_23.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_4* updates
            
            # if arrow_l_4 is starting this frame...
            if arrow_l_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_4.frameNStart = frameN  # exact frame index
                arrow_l_4.tStart = t  # local t and not account for scr refresh
                arrow_l_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_4.started')
                # update status
                arrow_l_4.status = STARTED
                arrow_l_4.setAutoDraw(True)
            
            # if arrow_l_4 is active this frame...
            if arrow_l_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_11* updates
            
            # if whitesquare_11 is starting this frame...
            if whitesquare_11.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_11.frameNStart = frameN  # exact frame index
                whitesquare_11.tStart = t  # local t and not account for scr refresh
                whitesquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_11.started')
                # update status
                whitesquare_11.status = STARTED
                whitesquare_11.setAutoDraw(True)
            
            # if whitesquare_11 is active this frame...
            if whitesquare_11.status == STARTED:
                # update params
                pass
            
            # if whitesquare_11 is stopping this frame...
            if whitesquare_11.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_11.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_11.tStop = t  # not accounting for scr refresh
                    whitesquare_11.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_11.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_11.stopped')
                    # update status
                    whitesquare_11.status = FINISHED
                    whitesquare_11.setAutoDraw(False)
            
            # *whitesquare_18* updates
            
            # if whitesquare_18 is starting this frame...
            if whitesquare_18.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_18.frameNStart = frameN  # exact frame index
                whitesquare_18.tStart = t  # local t and not account for scr refresh
                whitesquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_18.started')
                # update status
                whitesquare_18.status = STARTED
                whitesquare_18.setAutoDraw(True)
            
            # if whitesquare_18 is active this frame...
            if whitesquare_18.status == STARTED:
                # update params
                pass
            
            # if whitesquare_18 is stopping this frame...
            if whitesquare_18.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_18.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_18.tStop = t  # not accounting for scr refresh
                    whitesquare_18.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_18.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_18.stopped')
                    # update status
                    whitesquare_18.status = FINISHED
                    whitesquare_18.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_right" ---
        for thisComponent in rightA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_right
        rightA_on_right.tStop = globalClock.getTime(format='float')
        rightA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_right.stopped', rightA_on_right.tStop)
        # check responses
        if key_resp_23.keys in ['', [], None]:  # No response was made
            key_resp_23.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_23.corr = 1;  # correct non-response
            else:
               key_resp_23.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_23.keys',key_resp_23.keys)
        trials_b3.addData('key_resp_23.corr', key_resp_23.corr)
        if key_resp_23.keys != None:  # we had a response
            trials_b3.addData('key_resp_23.rt', key_resp_23.rt)
            trials_b3.addData('key_resp_23.duration', key_resp_23.duration)
        # the Routine "rightA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_left" ---
        # create an object to store info about Routine rightA_on_left
        rightA_on_left = data.Routine(
            name='rightA_on_left',
            components=[blacksquare_21, white_cross_21, key_resp_24, arrow_l_5, whitesquare_9, whitesquare_16],
        )
        rightA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_24
        key_resp_24.keys = []
        key_resp_24.rt = []
        _key_resp_24_allKeys = []
        # Run 'Begin Routine' code from code_11
        
        
        if currentRoutine != "rightA_on_left":
            continueRoutine = False
        
        # store start times for rightA_on_left
        rightA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_left.tStart = globalClock.getTime(format='float')
        rightA_on_left.status = STARTED
        thisExp.addData('rightA_on_left.started', rightA_on_left.tStart)
        rightA_on_left.maxDuration = None
        # keep track of which components have finished
        rightA_on_leftComponents = rightA_on_left.components
        for thisComponent in rightA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        rightA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_21* updates
            
            # if blacksquare_21 is starting this frame...
            if blacksquare_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_21.frameNStart = frameN  # exact frame index
                blacksquare_21.tStart = t  # local t and not account for scr refresh
                blacksquare_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_21.started')
                # update status
                blacksquare_21.status = STARTED
                blacksquare_21.setAutoDraw(True)
            
            # if blacksquare_21 is active this frame...
            if blacksquare_21.status == STARTED:
                # update params
                pass
            
            # *white_cross_21* updates
            
            # if white_cross_21 is starting this frame...
            if white_cross_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_21.frameNStart = frameN  # exact frame index
                white_cross_21.tStart = t  # local t and not account for scr refresh
                white_cross_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_21.started')
                # update status
                white_cross_21.status = STARTED
                white_cross_21.setAutoDraw(True)
            
            # if white_cross_21 is active this frame...
            if white_cross_21.status == STARTED:
                # update params
                pass
            
            # *key_resp_24* updates
            waitOnFlip = False
            
            # if key_resp_24 is starting this frame...
            if key_resp_24.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_24.frameNStart = frameN  # exact frame index
                key_resp_24.tStart = t  # local t and not account for scr refresh
                key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_24.started')
                # update status
                key_resp_24.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_24.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_24.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_24_allKeys.extend(theseKeys)
                if len(_key_resp_24_allKeys):
                    key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
                    key_resp_24.rt = _key_resp_24_allKeys[-1].rt
                    key_resp_24.duration = _key_resp_24_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_24.keys == str('left')) or (key_resp_24.keys == 'left'):
                        key_resp_24.corr = 1
                    else:
                        key_resp_24.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_5* updates
            
            # if arrow_l_5 is starting this frame...
            if arrow_l_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_5.frameNStart = frameN  # exact frame index
                arrow_l_5.tStart = t  # local t and not account for scr refresh
                arrow_l_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_5.started')
                # update status
                arrow_l_5.status = STARTED
                arrow_l_5.setAutoDraw(True)
            
            # if arrow_l_5 is active this frame...
            if arrow_l_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_9* updates
            
            # if whitesquare_9 is starting this frame...
            if whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_9.frameNStart = frameN  # exact frame index
                whitesquare_9.tStart = t  # local t and not account for scr refresh
                whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_9.started')
                # update status
                whitesquare_9.status = STARTED
                whitesquare_9.setAutoDraw(True)
            
            # if whitesquare_9 is active this frame...
            if whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if whitesquare_9 is stopping this frame...
            if whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_9.tStop = t  # not accounting for scr refresh
                    whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_9.stopped')
                    # update status
                    whitesquare_9.status = FINISHED
                    whitesquare_9.setAutoDraw(False)
            
            # *whitesquare_16* updates
            
            # if whitesquare_16 is starting this frame...
            if whitesquare_16.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_16.frameNStart = frameN  # exact frame index
                whitesquare_16.tStart = t  # local t and not account for scr refresh
                whitesquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_16.started')
                # update status
                whitesquare_16.status = STARTED
                whitesquare_16.setAutoDraw(True)
            
            # if whitesquare_16 is active this frame...
            if whitesquare_16.status == STARTED:
                # update params
                pass
            
            # if whitesquare_16 is stopping this frame...
            if whitesquare_16.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_16.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_16.tStop = t  # not accounting for scr refresh
                    whitesquare_16.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_16.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_16.stopped')
                    # update status
                    whitesquare_16.status = FINISHED
                    whitesquare_16.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_left" ---
        for thisComponent in rightA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_left
        rightA_on_left.tStop = globalClock.getTime(format='float')
        rightA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_left.stopped', rightA_on_left.tStop)
        # check responses
        if key_resp_24.keys in ['', [], None]:  # No response was made
            key_resp_24.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_24.corr = 1;  # correct non-response
            else:
               key_resp_24.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_24.keys',key_resp_24.keys)
        trials_b3.addData('key_resp_24.corr', key_resp_24.corr)
        if key_resp_24.keys != None:  # we had a response
            trials_b3.addData('key_resp_24.rt', key_resp_24.rt)
            trials_b3.addData('key_resp_24.duration', key_resp_24.duration)
        # the Routine "rightA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_up" ---
        # create an object to store info about Routine upA_on_up
        upA_on_up = data.Routine(
            name='upA_on_up',
            components=[blacksquare_22, white_cross_22, key_resp_25, arrow_u, up_whitesquare_3, down_whitesquare_3],
        )
        upA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_25
        key_resp_25.keys = []
        key_resp_25.rt = []
        _key_resp_25_allKeys = []
        # Run 'Begin Routine' code from code_15
        
        
        if currentRoutine != "upA_on_up":
            continueRoutine = False
        
        # store start times for upA_on_up
        upA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_up.tStart = globalClock.getTime(format='float')
        upA_on_up.status = STARTED
        thisExp.addData('upA_on_up.started', upA_on_up.tStart)
        upA_on_up.maxDuration = None
        # keep track of which components have finished
        upA_on_upComponents = upA_on_up.components
        for thisComponent in upA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        upA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_22* updates
            
            # if blacksquare_22 is starting this frame...
            if blacksquare_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_22.frameNStart = frameN  # exact frame index
                blacksquare_22.tStart = t  # local t and not account for scr refresh
                blacksquare_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_22.started')
                # update status
                blacksquare_22.status = STARTED
                blacksquare_22.setAutoDraw(True)
            
            # if blacksquare_22 is active this frame...
            if blacksquare_22.status == STARTED:
                # update params
                pass
            
            # *white_cross_22* updates
            
            # if white_cross_22 is starting this frame...
            if white_cross_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_22.frameNStart = frameN  # exact frame index
                white_cross_22.tStart = t  # local t and not account for scr refresh
                white_cross_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_22.started')
                # update status
                white_cross_22.status = STARTED
                white_cross_22.setAutoDraw(True)
            
            # if white_cross_22 is active this frame...
            if white_cross_22.status == STARTED:
                # update params
                pass
            
            # *key_resp_25* updates
            waitOnFlip = False
            
            # if key_resp_25 is starting this frame...
            if key_resp_25.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_25.frameNStart = frameN  # exact frame index
                key_resp_25.tStart = t  # local t and not account for scr refresh
                key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_25.started')
                # update status
                key_resp_25.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_25.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_25.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_25_allKeys.extend(theseKeys)
                if len(_key_resp_25_allKeys):
                    key_resp_25.keys = _key_resp_25_allKeys[-1].name  # just the last key pressed
                    key_resp_25.rt = _key_resp_25_allKeys[-1].rt
                    key_resp_25.duration = _key_resp_25_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_25.keys == str('left')) or (key_resp_25.keys == 'left'):
                        key_resp_25.corr = 1
                    else:
                        key_resp_25.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u* updates
            
            # if arrow_u is starting this frame...
            if arrow_u.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u.frameNStart = frameN  # exact frame index
                arrow_u.tStart = t  # local t and not account for scr refresh
                arrow_u.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u.started')
                # update status
                arrow_u.status = STARTED
                arrow_u.setAutoDraw(True)
            
            # if arrow_u is active this frame...
            if arrow_u.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_3* updates
            
            # if up_whitesquare_3 is starting this frame...
            if up_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_3.frameNStart = frameN  # exact frame index
                up_whitesquare_3.tStart = t  # local t and not account for scr refresh
                up_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_3.started')
                # update status
                up_whitesquare_3.status = STARTED
                up_whitesquare_3.setAutoDraw(True)
            
            # if up_whitesquare_3 is active this frame...
            if up_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_3 is stopping this frame...
            if up_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_3.tStop = t  # not accounting for scr refresh
                    up_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_3.stopped')
                    # update status
                    up_whitesquare_3.status = FINISHED
                    up_whitesquare_3.setAutoDraw(False)
            
            # *down_whitesquare_3* updates
            
            # if down_whitesquare_3 is starting this frame...
            if down_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_3.frameNStart = frameN  # exact frame index
                down_whitesquare_3.tStart = t  # local t and not account for scr refresh
                down_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_3.started')
                # update status
                down_whitesquare_3.status = STARTED
                down_whitesquare_3.setAutoDraw(True)
            
            # if down_whitesquare_3 is active this frame...
            if down_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_3 is stopping this frame...
            if down_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_3.tStop = t  # not accounting for scr refresh
                    down_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_3.stopped')
                    # update status
                    down_whitesquare_3.status = FINISHED
                    down_whitesquare_3.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_up" ---
        for thisComponent in upA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_up
        upA_on_up.tStop = globalClock.getTime(format='float')
        upA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_up.stopped', upA_on_up.tStop)
        # check responses
        if key_resp_25.keys in ['', [], None]:  # No response was made
            key_resp_25.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_25.corr = 1;  # correct non-response
            else:
               key_resp_25.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_25.keys',key_resp_25.keys)
        trials_b3.addData('key_resp_25.corr', key_resp_25.corr)
        if key_resp_25.keys != None:  # we had a response
            trials_b3.addData('key_resp_25.rt', key_resp_25.rt)
            trials_b3.addData('key_resp_25.duration', key_resp_25.duration)
        # the Routine "upA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_down" ---
        # create an object to store info about Routine upA_on_down
        upA_on_down = data.Routine(
            name='upA_on_down',
            components=[blacksquare_23, white_cross_23, key_resp_26, arrow_u_2, up_whitesquare_7, down_whitesquare_7],
        )
        upA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_26
        key_resp_26.keys = []
        key_resp_26.rt = []
        _key_resp_26_allKeys = []
        # Run 'Begin Routine' code from code_19
        
        
        if currentRoutine != "upA_on_down":
            continueRoutine = False
        
        # store start times for upA_on_down
        upA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_down.tStart = globalClock.getTime(format='float')
        upA_on_down.status = STARTED
        thisExp.addData('upA_on_down.started', upA_on_down.tStart)
        upA_on_down.maxDuration = None
        # keep track of which components have finished
        upA_on_downComponents = upA_on_down.components
        for thisComponent in upA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        upA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_23* updates
            
            # if blacksquare_23 is starting this frame...
            if blacksquare_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_23.frameNStart = frameN  # exact frame index
                blacksquare_23.tStart = t  # local t and not account for scr refresh
                blacksquare_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_23.started')
                # update status
                blacksquare_23.status = STARTED
                blacksquare_23.setAutoDraw(True)
            
            # if blacksquare_23 is active this frame...
            if blacksquare_23.status == STARTED:
                # update params
                pass
            
            # *white_cross_23* updates
            
            # if white_cross_23 is starting this frame...
            if white_cross_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_23.frameNStart = frameN  # exact frame index
                white_cross_23.tStart = t  # local t and not account for scr refresh
                white_cross_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_23.started')
                # update status
                white_cross_23.status = STARTED
                white_cross_23.setAutoDraw(True)
            
            # if white_cross_23 is active this frame...
            if white_cross_23.status == STARTED:
                # update params
                pass
            
            # *key_resp_26* updates
            waitOnFlip = False
            
            # if key_resp_26 is starting this frame...
            if key_resp_26.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_26.frameNStart = frameN  # exact frame index
                key_resp_26.tStart = t  # local t and not account for scr refresh
                key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_26.started')
                # update status
                key_resp_26.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_26.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_26.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_26_allKeys.extend(theseKeys)
                if len(_key_resp_26_allKeys):
                    key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
                    key_resp_26.rt = _key_resp_26_allKeys[-1].rt
                    key_resp_26.duration = _key_resp_26_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_26.keys == str('left')) or (key_resp_26.keys == 'left'):
                        key_resp_26.corr = 1
                    else:
                        key_resp_26.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_2* updates
            
            # if arrow_u_2 is starting this frame...
            if arrow_u_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_2.frameNStart = frameN  # exact frame index
                arrow_u_2.tStart = t  # local t and not account for scr refresh
                arrow_u_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_2.started')
                # update status
                arrow_u_2.status = STARTED
                arrow_u_2.setAutoDraw(True)
            
            # if arrow_u_2 is active this frame...
            if arrow_u_2.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_7* updates
            
            # if up_whitesquare_7 is starting this frame...
            if up_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_7.frameNStart = frameN  # exact frame index
                up_whitesquare_7.tStart = t  # local t and not account for scr refresh
                up_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_7.started')
                # update status
                up_whitesquare_7.status = STARTED
                up_whitesquare_7.setAutoDraw(True)
            
            # if up_whitesquare_7 is active this frame...
            if up_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_7 is stopping this frame...
            if up_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_7.tStop = t  # not accounting for scr refresh
                    up_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_7.stopped')
                    # update status
                    up_whitesquare_7.status = FINISHED
                    up_whitesquare_7.setAutoDraw(False)
            
            # *down_whitesquare_7* updates
            
            # if down_whitesquare_7 is starting this frame...
            if down_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_7.frameNStart = frameN  # exact frame index
                down_whitesquare_7.tStart = t  # local t and not account for scr refresh
                down_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_7.started')
                # update status
                down_whitesquare_7.status = STARTED
                down_whitesquare_7.setAutoDraw(True)
            
            # if down_whitesquare_7 is active this frame...
            if down_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_7 is stopping this frame...
            if down_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_7.tStop = t  # not accounting for scr refresh
                    down_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_7.stopped')
                    # update status
                    down_whitesquare_7.status = FINISHED
                    down_whitesquare_7.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_down" ---
        for thisComponent in upA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_down
        upA_on_down.tStop = globalClock.getTime(format='float')
        upA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_down.stopped', upA_on_down.tStop)
        # check responses
        if key_resp_26.keys in ['', [], None]:  # No response was made
            key_resp_26.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_26.corr = 1;  # correct non-response
            else:
               key_resp_26.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_26.keys',key_resp_26.keys)
        trials_b3.addData('key_resp_26.corr', key_resp_26.corr)
        if key_resp_26.keys != None:  # we had a response
            trials_b3.addData('key_resp_26.rt', key_resp_26.rt)
            trials_b3.addData('key_resp_26.duration', key_resp_26.duration)
        # the Routine "upA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_down" ---
        # create an object to store info about Routine downA_on_down
        downA_on_down = data.Routine(
            name='downA_on_down',
            components=[blacksquare_24, white_cross_24, key_resp_27, arrow_u_3, up_whitesquare_9, down_whitesquare_9],
        )
        downA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_27
        key_resp_27.keys = []
        key_resp_27.rt = []
        _key_resp_27_allKeys = []
        # Run 'Begin Routine' code from code_21
        
        
        if currentRoutine != "downA_on_down":
            continueRoutine = False
        
        # store start times for downA_on_down
        downA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_down.tStart = globalClock.getTime(format='float')
        downA_on_down.status = STARTED
        thisExp.addData('downA_on_down.started', downA_on_down.tStart)
        downA_on_down.maxDuration = None
        # keep track of which components have finished
        downA_on_downComponents = downA_on_down.components
        for thisComponent in downA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        downA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_24* updates
            
            # if blacksquare_24 is starting this frame...
            if blacksquare_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_24.frameNStart = frameN  # exact frame index
                blacksquare_24.tStart = t  # local t and not account for scr refresh
                blacksquare_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_24.started')
                # update status
                blacksquare_24.status = STARTED
                blacksquare_24.setAutoDraw(True)
            
            # if blacksquare_24 is active this frame...
            if blacksquare_24.status == STARTED:
                # update params
                pass
            
            # *white_cross_24* updates
            
            # if white_cross_24 is starting this frame...
            if white_cross_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_24.frameNStart = frameN  # exact frame index
                white_cross_24.tStart = t  # local t and not account for scr refresh
                white_cross_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_24.started')
                # update status
                white_cross_24.status = STARTED
                white_cross_24.setAutoDraw(True)
            
            # if white_cross_24 is active this frame...
            if white_cross_24.status == STARTED:
                # update params
                pass
            
            # *key_resp_27* updates
            waitOnFlip = False
            
            # if key_resp_27 is starting this frame...
            if key_resp_27.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_27.frameNStart = frameN  # exact frame index
                key_resp_27.tStart = t  # local t and not account for scr refresh
                key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_27.started')
                # update status
                key_resp_27.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_27.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_27.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_27_allKeys.extend(theseKeys)
                if len(_key_resp_27_allKeys):
                    key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
                    key_resp_27.rt = _key_resp_27_allKeys[-1].rt
                    key_resp_27.duration = _key_resp_27_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_27.keys == str('left')) or (key_resp_27.keys == 'left'):
                        key_resp_27.corr = 1
                    else:
                        key_resp_27.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_3* updates
            
            # if arrow_u_3 is starting this frame...
            if arrow_u_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_3.frameNStart = frameN  # exact frame index
                arrow_u_3.tStart = t  # local t and not account for scr refresh
                arrow_u_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_3.started')
                # update status
                arrow_u_3.status = STARTED
                arrow_u_3.setAutoDraw(True)
            
            # if arrow_u_3 is active this frame...
            if arrow_u_3.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_9* updates
            
            # if up_whitesquare_9 is starting this frame...
            if up_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_9.frameNStart = frameN  # exact frame index
                up_whitesquare_9.tStart = t  # local t and not account for scr refresh
                up_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_9.started')
                # update status
                up_whitesquare_9.status = STARTED
                up_whitesquare_9.setAutoDraw(True)
            
            # if up_whitesquare_9 is active this frame...
            if up_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_9 is stopping this frame...
            if up_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_9.tStop = t  # not accounting for scr refresh
                    up_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_9.stopped')
                    # update status
                    up_whitesquare_9.status = FINISHED
                    up_whitesquare_9.setAutoDraw(False)
            
            # *down_whitesquare_9* updates
            
            # if down_whitesquare_9 is starting this frame...
            if down_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_9.frameNStart = frameN  # exact frame index
                down_whitesquare_9.tStart = t  # local t and not account for scr refresh
                down_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_9.started')
                # update status
                down_whitesquare_9.status = STARTED
                down_whitesquare_9.setAutoDraw(True)
            
            # if down_whitesquare_9 is active this frame...
            if down_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_9 is stopping this frame...
            if down_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_9.tStop = t  # not accounting for scr refresh
                    down_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_9.stopped')
                    # update status
                    down_whitesquare_9.status = FINISHED
                    down_whitesquare_9.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_down" ---
        for thisComponent in downA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_down
        downA_on_down.tStop = globalClock.getTime(format='float')
        downA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_down.stopped', downA_on_down.tStop)
        # check responses
        if key_resp_27.keys in ['', [], None]:  # No response was made
            key_resp_27.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_27.corr = 1;  # correct non-response
            else:
               key_resp_27.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_27.keys',key_resp_27.keys)
        trials_b3.addData('key_resp_27.corr', key_resp_27.corr)
        if key_resp_27.keys != None:  # we had a response
            trials_b3.addData('key_resp_27.rt', key_resp_27.rt)
            trials_b3.addData('key_resp_27.duration', key_resp_27.duration)
        # the Routine "downA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_up" ---
        # create an object to store info about Routine downA_on_up
        downA_on_up = data.Routine(
            name='downA_on_up',
            components=[blacksquare_25, white_cross_25, key_resp_28, arrow_u_4, up_whitesquare_5, down_whitesquare_5],
        )
        downA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_28
        key_resp_28.keys = []
        key_resp_28.rt = []
        _key_resp_28_allKeys = []
        # Run 'Begin Routine' code from code_17
        
        
        if currentRoutine != "downA_on_up":
            continueRoutine = False
        
        # store start times for downA_on_up
        downA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_up.tStart = globalClock.getTime(format='float')
        downA_on_up.status = STARTED
        thisExp.addData('downA_on_up.started', downA_on_up.tStart)
        downA_on_up.maxDuration = None
        # keep track of which components have finished
        downA_on_upComponents = downA_on_up.components
        for thisComponent in downA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b3, data.TrialHandler2) and thisTrials_b3.thisN != trials_b3.thisTrial.thisN:
            continueRoutine = False
        downA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_25* updates
            
            # if blacksquare_25 is starting this frame...
            if blacksquare_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_25.frameNStart = frameN  # exact frame index
                blacksquare_25.tStart = t  # local t and not account for scr refresh
                blacksquare_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_25.started')
                # update status
                blacksquare_25.status = STARTED
                blacksquare_25.setAutoDraw(True)
            
            # if blacksquare_25 is active this frame...
            if blacksquare_25.status == STARTED:
                # update params
                pass
            
            # *white_cross_25* updates
            
            # if white_cross_25 is starting this frame...
            if white_cross_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_25.frameNStart = frameN  # exact frame index
                white_cross_25.tStart = t  # local t and not account for scr refresh
                white_cross_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_25.started')
                # update status
                white_cross_25.status = STARTED
                white_cross_25.setAutoDraw(True)
            
            # if white_cross_25 is active this frame...
            if white_cross_25.status == STARTED:
                # update params
                pass
            
            # *key_resp_28* updates
            waitOnFlip = False
            
            # if key_resp_28 is starting this frame...
            if key_resp_28.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_28.frameNStart = frameN  # exact frame index
                key_resp_28.tStart = t  # local t and not account for scr refresh
                key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_28.started')
                # update status
                key_resp_28.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_28.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_28.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_28_allKeys.extend(theseKeys)
                if len(_key_resp_28_allKeys):
                    key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
                    key_resp_28.rt = _key_resp_28_allKeys[-1].rt
                    key_resp_28.duration = _key_resp_28_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_28.keys == str('left')) or (key_resp_28.keys == 'left'):
                        key_resp_28.corr = 1
                    else:
                        key_resp_28.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_4* updates
            
            # if arrow_u_4 is starting this frame...
            if arrow_u_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_4.frameNStart = frameN  # exact frame index
                arrow_u_4.tStart = t  # local t and not account for scr refresh
                arrow_u_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_4.started')
                # update status
                arrow_u_4.status = STARTED
                arrow_u_4.setAutoDraw(True)
            
            # if arrow_u_4 is active this frame...
            if arrow_u_4.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_5* updates
            
            # if up_whitesquare_5 is starting this frame...
            if up_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_5.frameNStart = frameN  # exact frame index
                up_whitesquare_5.tStart = t  # local t and not account for scr refresh
                up_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_5.started')
                # update status
                up_whitesquare_5.status = STARTED
                up_whitesquare_5.setAutoDraw(True)
            
            # if up_whitesquare_5 is active this frame...
            if up_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_5 is stopping this frame...
            if up_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_5.tStop = t  # not accounting for scr refresh
                    up_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_5.stopped')
                    # update status
                    up_whitesquare_5.status = FINISHED
                    up_whitesquare_5.setAutoDraw(False)
            
            # *down_whitesquare_5* updates
            
            # if down_whitesquare_5 is starting this frame...
            if down_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_5.frameNStart = frameN  # exact frame index
                down_whitesquare_5.tStart = t  # local t and not account for scr refresh
                down_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_5.started')
                # update status
                down_whitesquare_5.status = STARTED
                down_whitesquare_5.setAutoDraw(True)
            
            # if down_whitesquare_5 is active this frame...
            if down_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_5 is stopping this frame...
            if down_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_5.tStop = t  # not accounting for scr refresh
                    down_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_5.stopped')
                    # update status
                    down_whitesquare_5.status = FINISHED
                    down_whitesquare_5.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_up" ---
        for thisComponent in downA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_up
        downA_on_up.tStop = globalClock.getTime(format='float')
        downA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_up.stopped', downA_on_up.tStop)
        # check responses
        if key_resp_28.keys in ['', [], None]:  # No response was made
            key_resp_28.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_28.corr = 1;  # correct non-response
            else:
               key_resp_28.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b3 (TrialHandler)
        trials_b3.addData('key_resp_28.keys',key_resp_28.keys)
        trials_b3.addData('key_resp_28.corr', key_resp_28.corr)
        if key_resp_28.keys != None:  # we had a response
            trials_b3.addData('key_resp_28.rt', key_resp_28.rt)
            trials_b3.addData('key_resp_28.duration', key_resp_28.duration)
        # the Routine "downA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 5.0 repeats of 'trials_b3'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "end_block3" ---
    # create an object to store info about Routine end_block3
    end_block3 = data.Routine(
        name='end_block3',
        components=[text_31, text_32, key_resp_31],
    )
    end_block3.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_31
    key_resp_31.keys = []
    key_resp_31.rt = []
    _key_resp_31_allKeys = []
    # store start times for end_block3
    end_block3.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    end_block3.tStart = globalClock.getTime(format='float')
    end_block3.status = STARTED
    thisExp.addData('end_block3.started', end_block3.tStart)
    end_block3.maxDuration = None
    # keep track of which components have finished
    end_block3Components = end_block3.components
    for thisComponent in end_block3.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end_block3" ---
    end_block3.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_31* updates
        
        # if text_31 is starting this frame...
        if text_31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_31.frameNStart = frameN  # exact frame index
            text_31.tStart = t  # local t and not account for scr refresh
            text_31.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_31, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_31.started')
            # update status
            text_31.status = STARTED
            text_31.setAutoDraw(True)
        
        # if text_31 is active this frame...
        if text_31.status == STARTED:
            # update params
            pass
        
        # *text_32* updates
        
        # if text_32 is starting this frame...
        if text_32.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_32.frameNStart = frameN  # exact frame index
            text_32.tStart = t  # local t and not account for scr refresh
            text_32.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_32, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_32.started')
            # update status
            text_32.status = STARTED
            text_32.setAutoDraw(True)
        
        # if text_32 is active this frame...
        if text_32.status == STARTED:
            # update params
            pass
        
        # *key_resp_31* updates
        waitOnFlip = False
        
        # if key_resp_31 is starting this frame...
        if key_resp_31.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_31.frameNStart = frameN  # exact frame index
            key_resp_31.tStart = t  # local t and not account for scr refresh
            key_resp_31.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_31, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_31.started')
            # update status
            key_resp_31.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_31.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_31.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_31.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_31.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_31_allKeys.extend(theseKeys)
            if len(_key_resp_31_allKeys):
                key_resp_31.keys = _key_resp_31_allKeys[-1].name  # just the last key pressed
                key_resp_31.rt = _key_resp_31_allKeys[-1].rt
                key_resp_31.duration = _key_resp_31_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            end_block3.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in end_block3.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end_block3" ---
    for thisComponent in end_block3.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for end_block3
    end_block3.tStop = globalClock.getTime(format='float')
    end_block3.tStopRefresh = tThisFlipGlobal
    thisExp.addData('end_block3.stopped', end_block3.tStop)
    # check responses
    if key_resp_31.keys in ['', [], None]:  # No response was made
        key_resp_31.keys = None
    thisExp.addData('key_resp_31.keys',key_resp_31.keys)
    if key_resp_31.keys != None:  # we had a response
        thisExp.addData('key_resp_31.rt', key_resp_31.rt)
        thisExp.addData('key_resp_31.duration', key_resp_31.duration)
    thisExp.nextEntry()
    # the Routine "end_block3" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "block4" ---
    # create an object to store info about Routine block4
    block4 = data.Routine(
        name='block4',
        components=[text_26],
    )
    block4.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for block4
    block4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    block4.tStart = globalClock.getTime(format='float')
    block4.status = STARTED
    thisExp.addData('block4.started', block4.tStart)
    block4.maxDuration = None
    # keep track of which components have finished
    block4Components = block4.components
    for thisComponent in block4.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "block4" ---
    block4.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 2.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_26* updates
        
        # if text_26 is starting this frame...
        if text_26.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_26.frameNStart = frameN  # exact frame index
            text_26.tStart = t  # local t and not account for scr refresh
            text_26.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_26, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_26.started')
            # update status
            text_26.status = STARTED
            text_26.setAutoDraw(True)
        
        # if text_26 is active this frame...
        if text_26.status == STARTED:
            # update params
            pass
        
        # if text_26 is stopping this frame...
        if text_26.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_26.tStartRefresh + 2-frameTolerance:
                # keep track of stop time/frame for later
                text_26.tStop = t  # not accounting for scr refresh
                text_26.tStopRefresh = tThisFlipGlobal  # on global time
                text_26.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_26.stopped')
                # update status
                text_26.status = FINISHED
                text_26.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            block4.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in block4.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "block4" ---
    for thisComponent in block4.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for block4
    block4.tStop = globalClock.getTime(format='float')
    block4.tStopRefresh = tThisFlipGlobal
    thisExp.addData('block4.stopped', block4.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if block4.maxDurationReached:
        routineTimer.addTime(-block4.maxDuration)
    elif block4.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-2.000000)
    thisExp.nextEntry()
    
    # set up handler to look after randomisation of conditions etc
    trials_b4 = data.TrialHandler2(
        name='trials_b4',
        nReps=32.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(trials_b4)  # add the loop to the experiment
    thisTrials_b4 = trials_b4.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_b4.rgb)
    if thisTrials_b4 != None:
        for paramName in thisTrials_b4:
            globals()[paramName] = thisTrials_b4[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_b4 in trials_b4:
        currentLoop = trials_b4
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_b4.rgb)
        if thisTrials_b4 != None:
            for paramName in thisTrials_b4:
                globals()[paramName] = thisTrials_b4[paramName]
        
        # --- Prepare to start Routine "block4_router" ---
        # create an object to store info about Routine block4_router
        block4_router = data.Routine(
            name='block4_router',
            components=[],
        )
        block4_router.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_24
        currentRoutine = schedule[trial_index]
        
        
        # store start times for block4_router
        block4_router.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        block4_router.tStart = globalClock.getTime(format='float')
        block4_router.status = STARTED
        thisExp.addData('block4_router.started', block4_router.tStart)
        block4_router.maxDuration = None
        # keep track of which components have finished
        block4_routerComponents = block4_router.components
        for thisComponent in block4_router.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "block4_router" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        block4_router.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                block4_router.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in block4_router.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "block4_router" ---
        for thisComponent in block4_router.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for block4_router
        block4_router.tStop = globalClock.getTime(format='float')
        block4_router.tStopRefresh = tThisFlipGlobal
        thisExp.addData('block4_router.stopped', block4_router.tStop)
        # Run 'End Routine' code from code_24
        trial_index += 1
        
        # the Routine "block4_router" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_right" ---
        # create an object to store info about Routine LEFT_on_right
        LEFT_on_right = data.Routine(
            name='LEFT_on_right',
            components=[blacksquare_10, white_cross_10, key_resp_13, LEFT_2, whitesquare_3, whitesquare_4],
        )
        LEFT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_13
        key_resp_13.keys = []
        key_resp_13.rt = []
        _key_resp_13_allKeys = []
        # Run 'Begin Routine' code from code_6
        if currentRoutine != "LEFT_on_right":
            continueRoutine = False
        
        # store start times for LEFT_on_right
        LEFT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_right.tStart = globalClock.getTime(format='float')
        LEFT_on_right.status = STARTED
        thisExp.addData('LEFT_on_right.started', LEFT_on_right.tStart)
        LEFT_on_right.maxDuration = None
        # keep track of which components have finished
        LEFT_on_rightComponents = LEFT_on_right.components
        for thisComponent in LEFT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_10* updates
            
            # if blacksquare_10 is starting this frame...
            if blacksquare_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_10.frameNStart = frameN  # exact frame index
                blacksquare_10.tStart = t  # local t and not account for scr refresh
                blacksquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_10.started')
                # update status
                blacksquare_10.status = STARTED
                blacksquare_10.setAutoDraw(True)
            
            # if blacksquare_10 is active this frame...
            if blacksquare_10.status == STARTED:
                # update params
                pass
            
            # *white_cross_10* updates
            
            # if white_cross_10 is starting this frame...
            if white_cross_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                white_cross_10.frameNStart = frameN  # exact frame index
                white_cross_10.tStart = t  # local t and not account for scr refresh
                white_cross_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_10.started')
                # update status
                white_cross_10.status = STARTED
                white_cross_10.setAutoDraw(True)
            
            # if white_cross_10 is active this frame...
            if white_cross_10.status == STARTED:
                # update params
                pass
            
            # *key_resp_13* updates
            waitOnFlip = False
            
            # if key_resp_13 is starting this frame...
            if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_13.frameNStart = frameN  # exact frame index
                key_resp_13.tStart = t  # local t and not account for scr refresh
                key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_13.started')
                # update status
                key_resp_13.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_13.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_13.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_13_allKeys.extend(theseKeys)
                if len(_key_resp_13_allKeys):
                    key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
                    key_resp_13.rt = _key_resp_13_allKeys[-1].rt
                    key_resp_13.duration = _key_resp_13_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_13.keys == str('left')) or (key_resp_13.keys == 'left'):
                        key_resp_13.corr = 1
                    else:
                        key_resp_13.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_2* updates
            
            # if LEFT_2 is starting this frame...
            if LEFT_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_2.frameNStart = frameN  # exact frame index
                LEFT_2.tStart = t  # local t and not account for scr refresh
                LEFT_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_2.started')
                # update status
                LEFT_2.status = STARTED
                LEFT_2.setAutoDraw(True)
            
            # if LEFT_2 is active this frame...
            if LEFT_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_3* updates
            
            # if whitesquare_3 is starting this frame...
            if whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_3.frameNStart = frameN  # exact frame index
                whitesquare_3.tStart = t  # local t and not account for scr refresh
                whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_3.started')
                # update status
                whitesquare_3.status = STARTED
                whitesquare_3.setAutoDraw(True)
            
            # if whitesquare_3 is active this frame...
            if whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if whitesquare_3 is stopping this frame...
            if whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_3.tStop = t  # not accounting for scr refresh
                    whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_3.stopped')
                    # update status
                    whitesquare_3.status = FINISHED
                    whitesquare_3.setAutoDraw(False)
            
            # *whitesquare_4* updates
            
            # if whitesquare_4 is starting this frame...
            if whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_4.frameNStart = frameN  # exact frame index
                whitesquare_4.tStart = t  # local t and not account for scr refresh
                whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_4.started')
                # update status
                whitesquare_4.status = STARTED
                whitesquare_4.setAutoDraw(True)
            
            # if whitesquare_4 is active this frame...
            if whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if whitesquare_4 is stopping this frame...
            if whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_4.tStop = t  # not accounting for scr refresh
                    whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_4.stopped')
                    # update status
                    whitesquare_4.status = FINISHED
                    whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_right" ---
        for thisComponent in LEFT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_right
        LEFT_on_right.tStop = globalClock.getTime(format='float')
        LEFT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_right.stopped', LEFT_on_right.tStop)
        # check responses
        if key_resp_13.keys in ['', [], None]:  # No response was made
            key_resp_13.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_13.corr = 1;  # correct non-response
            else:
               key_resp_13.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_13.keys',key_resp_13.keys)
        trials_b4.addData('key_resp_13.corr', key_resp_13.corr)
        if key_resp_13.keys != None:  # we had a response
            trials_b4.addData('key_resp_13.rt', key_resp_13.rt)
            trials_b4.addData('key_resp_13.duration', key_resp_13.duration)
        # the Routine "LEFT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_right" ---
        # create an object to store info about Routine RIGHT_on_right
        RIGHT_on_right = data.Routine(
            name='RIGHT_on_right',
            components=[blacksquare_11, white_cross_11, key_resp_14, RIGHT_3, whitesquare_10, whitesquare_17],
        )
        RIGHT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_14
        key_resp_14.keys = []
        key_resp_14.rt = []
        _key_resp_14_allKeys = []
        # Run 'Begin Routine' code from code_12
        if currentRoutine != "RIGHT_on_right":
            continueRoutine = False
        
        # store start times for RIGHT_on_right
        RIGHT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_right.tStart = globalClock.getTime(format='float')
        RIGHT_on_right.status = STARTED
        thisExp.addData('RIGHT_on_right.started', RIGHT_on_right.tStart)
        RIGHT_on_right.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_rightComponents = RIGHT_on_right.components
        for thisComponent in RIGHT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_11* updates
            
            # if blacksquare_11 is starting this frame...
            if blacksquare_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_11.frameNStart = frameN  # exact frame index
                blacksquare_11.tStart = t  # local t and not account for scr refresh
                blacksquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_11.started')
                # update status
                blacksquare_11.status = STARTED
                blacksquare_11.setAutoDraw(True)
            
            # if blacksquare_11 is active this frame...
            if blacksquare_11.status == STARTED:
                # update params
                pass
            
            # *white_cross_11* updates
            
            # if white_cross_11 is starting this frame...
            if white_cross_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_11.frameNStart = frameN  # exact frame index
                white_cross_11.tStart = t  # local t and not account for scr refresh
                white_cross_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_11.started')
                # update status
                white_cross_11.status = STARTED
                white_cross_11.setAutoDraw(True)
            
            # if white_cross_11 is active this frame...
            if white_cross_11.status == STARTED:
                # update params
                pass
            
            # *key_resp_14* updates
            waitOnFlip = False
            
            # if key_resp_14 is starting this frame...
            if key_resp_14.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_14.frameNStart = frameN  # exact frame index
                key_resp_14.tStart = t  # local t and not account for scr refresh
                key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_14.started')
                # update status
                key_resp_14.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_14.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_14.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_14_allKeys.extend(theseKeys)
                if len(_key_resp_14_allKeys):
                    key_resp_14.keys = _key_resp_14_allKeys[-1].name  # just the last key pressed
                    key_resp_14.rt = _key_resp_14_allKeys[-1].rt
                    key_resp_14.duration = _key_resp_14_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_14.keys == str('left')) or (key_resp_14.keys == 'left'):
                        key_resp_14.corr = 1
                    else:
                        key_resp_14.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_3* updates
            
            # if RIGHT_3 is starting this frame...
            if RIGHT_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_3.frameNStart = frameN  # exact frame index
                RIGHT_3.tStart = t  # local t and not account for scr refresh
                RIGHT_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_3.started')
                # update status
                RIGHT_3.status = STARTED
                RIGHT_3.setAutoDraw(True)
            
            # if RIGHT_3 is active this frame...
            if RIGHT_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_10* updates
            
            # if whitesquare_10 is starting this frame...
            if whitesquare_10.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_10.frameNStart = frameN  # exact frame index
                whitesquare_10.tStart = t  # local t and not account for scr refresh
                whitesquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_10.started')
                # update status
                whitesquare_10.status = STARTED
                whitesquare_10.setAutoDraw(True)
            
            # if whitesquare_10 is active this frame...
            if whitesquare_10.status == STARTED:
                # update params
                pass
            
            # if whitesquare_10 is stopping this frame...
            if whitesquare_10.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_10.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_10.tStop = t  # not accounting for scr refresh
                    whitesquare_10.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_10.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_10.stopped')
                    # update status
                    whitesquare_10.status = FINISHED
                    whitesquare_10.setAutoDraw(False)
            
            # *whitesquare_17* updates
            
            # if whitesquare_17 is starting this frame...
            if whitesquare_17.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_17.frameNStart = frameN  # exact frame index
                whitesquare_17.tStart = t  # local t and not account for scr refresh
                whitesquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_17.started')
                # update status
                whitesquare_17.status = STARTED
                whitesquare_17.setAutoDraw(True)
            
            # if whitesquare_17 is active this frame...
            if whitesquare_17.status == STARTED:
                # update params
                pass
            
            # if whitesquare_17 is stopping this frame...
            if whitesquare_17.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_17.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_17.tStop = t  # not accounting for scr refresh
                    whitesquare_17.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_17.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_17.stopped')
                    # update status
                    whitesquare_17.status = FINISHED
                    whitesquare_17.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_right" ---
        for thisComponent in RIGHT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_right
        RIGHT_on_right.tStop = globalClock.getTime(format='float')
        RIGHT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_right.stopped', RIGHT_on_right.tStop)
        # check responses
        if key_resp_14.keys in ['', [], None]:  # No response was made
            key_resp_14.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_14.corr = 1;  # correct non-response
            else:
               key_resp_14.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_14.keys',key_resp_14.keys)
        trials_b4.addData('key_resp_14.corr', key_resp_14.corr)
        if key_resp_14.keys != None:  # we had a response
            trials_b4.addData('key_resp_14.rt', key_resp_14.rt)
            trials_b4.addData('key_resp_14.duration', key_resp_14.duration)
        # the Routine "RIGHT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_left" ---
        # create an object to store info about Routine LEFT_on_left
        LEFT_on_left = data.Routine(
            name='LEFT_on_left',
            components=[blacksquare_12, white_cross_12, key_resp_15, LEFT_4, whitesquare_6, whitesquare_13],
        )
        LEFT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_15
        key_resp_15.keys = []
        key_resp_15.rt = []
        _key_resp_15_allKeys = []
        # Run 'Begin Routine' code from code_8
        
        
        if currentRoutine != "LEFT_on_left":
            continueRoutine = False
        
        # store start times for LEFT_on_left
        LEFT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_left.tStart = globalClock.getTime(format='float')
        LEFT_on_left.status = STARTED
        thisExp.addData('LEFT_on_left.started', LEFT_on_left.tStart)
        LEFT_on_left.maxDuration = None
        # keep track of which components have finished
        LEFT_on_leftComponents = LEFT_on_left.components
        for thisComponent in LEFT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_12* updates
            
            # if blacksquare_12 is starting this frame...
            if blacksquare_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_12.frameNStart = frameN  # exact frame index
                blacksquare_12.tStart = t  # local t and not account for scr refresh
                blacksquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_12.started')
                # update status
                blacksquare_12.status = STARTED
                blacksquare_12.setAutoDraw(True)
            
            # if blacksquare_12 is active this frame...
            if blacksquare_12.status == STARTED:
                # update params
                pass
            
            # *white_cross_12* updates
            
            # if white_cross_12 is starting this frame...
            if white_cross_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_12.frameNStart = frameN  # exact frame index
                white_cross_12.tStart = t  # local t and not account for scr refresh
                white_cross_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_12.started')
                # update status
                white_cross_12.status = STARTED
                white_cross_12.setAutoDraw(True)
            
            # if white_cross_12 is active this frame...
            if white_cross_12.status == STARTED:
                # update params
                pass
            
            # *key_resp_15* updates
            waitOnFlip = False
            
            # if key_resp_15 is starting this frame...
            if key_resp_15.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_15.frameNStart = frameN  # exact frame index
                key_resp_15.tStart = t  # local t and not account for scr refresh
                key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_15.started')
                # update status
                key_resp_15.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_15.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_15.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_15_allKeys.extend(theseKeys)
                if len(_key_resp_15_allKeys):
                    key_resp_15.keys = _key_resp_15_allKeys[-1].name  # just the last key pressed
                    key_resp_15.rt = _key_resp_15_allKeys[-1].rt
                    key_resp_15.duration = _key_resp_15_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_15.keys == str('left')) or (key_resp_15.keys == 'left'):
                        key_resp_15.corr = 1
                    else:
                        key_resp_15.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_4* updates
            
            # if LEFT_4 is starting this frame...
            if LEFT_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_4.frameNStart = frameN  # exact frame index
                LEFT_4.tStart = t  # local t and not account for scr refresh
                LEFT_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_4.started')
                # update status
                LEFT_4.status = STARTED
                LEFT_4.setAutoDraw(True)
            
            # if LEFT_4 is active this frame...
            if LEFT_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_6* updates
            
            # if whitesquare_6 is starting this frame...
            if whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_6.frameNStart = frameN  # exact frame index
                whitesquare_6.tStart = t  # local t and not account for scr refresh
                whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_6.started')
                # update status
                whitesquare_6.status = STARTED
                whitesquare_6.setAutoDraw(True)
            
            # if whitesquare_6 is active this frame...
            if whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if whitesquare_6 is stopping this frame...
            if whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_6.tStop = t  # not accounting for scr refresh
                    whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_6.stopped')
                    # update status
                    whitesquare_6.status = FINISHED
                    whitesquare_6.setAutoDraw(False)
            
            # *whitesquare_13* updates
            
            # if whitesquare_13 is starting this frame...
            if whitesquare_13.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_13.frameNStart = frameN  # exact frame index
                whitesquare_13.tStart = t  # local t and not account for scr refresh
                whitesquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_13.started')
                # update status
                whitesquare_13.status = STARTED
                whitesquare_13.setAutoDraw(True)
            
            # if whitesquare_13 is active this frame...
            if whitesquare_13.status == STARTED:
                # update params
                pass
            
            # if whitesquare_13 is stopping this frame...
            if whitesquare_13.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_13.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_13.tStop = t  # not accounting for scr refresh
                    whitesquare_13.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_13.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_13.stopped')
                    # update status
                    whitesquare_13.status = FINISHED
                    whitesquare_13.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_left" ---
        for thisComponent in LEFT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_left
        LEFT_on_left.tStop = globalClock.getTime(format='float')
        LEFT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_left.stopped', LEFT_on_left.tStop)
        # check responses
        if key_resp_15.keys in ['', [], None]:  # No response was made
            key_resp_15.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_15.corr = 1;  # correct non-response
            else:
               key_resp_15.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_15.keys',key_resp_15.keys)
        trials_b4.addData('key_resp_15.corr', key_resp_15.corr)
        if key_resp_15.keys != None:  # we had a response
            trials_b4.addData('key_resp_15.rt', key_resp_15.rt)
            trials_b4.addData('key_resp_15.duration', key_resp_15.duration)
        # the Routine "LEFT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_left" ---
        # create an object to store info about Routine RIGHT_on_left
        RIGHT_on_left = data.Routine(
            name='RIGHT_on_left',
            components=[blacksquare_13, white_cross_13, key_resp_16, RIGHT_5, whitesquare_8, whitesquare_15],
        )
        RIGHT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_16
        key_resp_16.keys = []
        key_resp_16.rt = []
        _key_resp_16_allKeys = []
        # Run 'Begin Routine' code from code_10
        
        if currentRoutine != "RIGHT_on_left":
            continueRoutine = False
        
        # store start times for RIGHT_on_left
        RIGHT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_left.tStart = globalClock.getTime(format='float')
        RIGHT_on_left.status = STARTED
        thisExp.addData('RIGHT_on_left.started', RIGHT_on_left.tStart)
        RIGHT_on_left.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_leftComponents = RIGHT_on_left.components
        for thisComponent in RIGHT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_13* updates
            
            # if blacksquare_13 is starting this frame...
            if blacksquare_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_13.frameNStart = frameN  # exact frame index
                blacksquare_13.tStart = t  # local t and not account for scr refresh
                blacksquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_13.started')
                # update status
                blacksquare_13.status = STARTED
                blacksquare_13.setAutoDraw(True)
            
            # if blacksquare_13 is active this frame...
            if blacksquare_13.status == STARTED:
                # update params
                pass
            
            # *white_cross_13* updates
            
            # if white_cross_13 is starting this frame...
            if white_cross_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_13.frameNStart = frameN  # exact frame index
                white_cross_13.tStart = t  # local t and not account for scr refresh
                white_cross_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_13.started')
                # update status
                white_cross_13.status = STARTED
                white_cross_13.setAutoDraw(True)
            
            # if white_cross_13 is active this frame...
            if white_cross_13.status == STARTED:
                # update params
                pass
            
            # *key_resp_16* updates
            waitOnFlip = False
            
            # if key_resp_16 is starting this frame...
            if key_resp_16.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_16.frameNStart = frameN  # exact frame index
                key_resp_16.tStart = t  # local t and not account for scr refresh
                key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_16.started')
                # update status
                key_resp_16.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_16.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_16.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_16_allKeys.extend(theseKeys)
                if len(_key_resp_16_allKeys):
                    key_resp_16.keys = _key_resp_16_allKeys[-1].name  # just the last key pressed
                    key_resp_16.rt = _key_resp_16_allKeys[-1].rt
                    key_resp_16.duration = _key_resp_16_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_16.keys == str('left')) or (key_resp_16.keys == 'left'):
                        key_resp_16.corr = 1
                    else:
                        key_resp_16.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_5* updates
            
            # if RIGHT_5 is starting this frame...
            if RIGHT_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_5.frameNStart = frameN  # exact frame index
                RIGHT_5.tStart = t  # local t and not account for scr refresh
                RIGHT_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_5.started')
                # update status
                RIGHT_5.status = STARTED
                RIGHT_5.setAutoDraw(True)
            
            # if RIGHT_5 is active this frame...
            if RIGHT_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_8* updates
            
            # if whitesquare_8 is starting this frame...
            if whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_8.frameNStart = frameN  # exact frame index
                whitesquare_8.tStart = t  # local t and not account for scr refresh
                whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_8.started')
                # update status
                whitesquare_8.status = STARTED
                whitesquare_8.setAutoDraw(True)
            
            # if whitesquare_8 is active this frame...
            if whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if whitesquare_8 is stopping this frame...
            if whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_8.tStop = t  # not accounting for scr refresh
                    whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_8.stopped')
                    # update status
                    whitesquare_8.status = FINISHED
                    whitesquare_8.setAutoDraw(False)
            
            # *whitesquare_15* updates
            
            # if whitesquare_15 is starting this frame...
            if whitesquare_15.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_15.frameNStart = frameN  # exact frame index
                whitesquare_15.tStart = t  # local t and not account for scr refresh
                whitesquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_15.started')
                # update status
                whitesquare_15.status = STARTED
                whitesquare_15.setAutoDraw(True)
            
            # if whitesquare_15 is active this frame...
            if whitesquare_15.status == STARTED:
                # update params
                pass
            
            # if whitesquare_15 is stopping this frame...
            if whitesquare_15.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_15.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_15.tStop = t  # not accounting for scr refresh
                    whitesquare_15.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_15.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_15.stopped')
                    # update status
                    whitesquare_15.status = FINISHED
                    whitesquare_15.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_left" ---
        for thisComponent in RIGHT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_left
        RIGHT_on_left.tStop = globalClock.getTime(format='float')
        RIGHT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_left.stopped', RIGHT_on_left.tStop)
        # check responses
        if key_resp_16.keys in ['', [], None]:  # No response was made
            key_resp_16.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_16.corr = 1;  # correct non-response
            else:
               key_resp_16.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_16.keys',key_resp_16.keys)
        trials_b4.addData('key_resp_16.corr', key_resp_16.corr)
        if key_resp_16.keys != None:  # we had a response
            trials_b4.addData('key_resp_16.rt', key_resp_16.rt)
            trials_b4.addData('key_resp_16.duration', key_resp_16.duration)
        # the Routine "RIGHT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_up" ---
        # create an object to store info about Routine UP_on_up
        UP_on_up = data.Routine(
            name='UP_on_up',
            components=[blacksquare_14, white_cross_14, key_resp_17, UP_5, up_whitesquare_2, down_whitesquare_2],
        )
        UP_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_17
        key_resp_17.keys = []
        key_resp_17.rt = []
        _key_resp_17_allKeys = []
        # Run 'Begin Routine' code from code_14
        
        if currentRoutine != "UP_on_up":
            continueRoutine = False
        
        # store start times for UP_on_up
        UP_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_up.tStart = globalClock.getTime(format='float')
        UP_on_up.status = STARTED
        thisExp.addData('UP_on_up.started', UP_on_up.tStart)
        UP_on_up.maxDuration = None
        # keep track of which components have finished
        UP_on_upComponents = UP_on_up.components
        for thisComponent in UP_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        UP_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_14* updates
            
            # if blacksquare_14 is starting this frame...
            if blacksquare_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_14.frameNStart = frameN  # exact frame index
                blacksquare_14.tStart = t  # local t and not account for scr refresh
                blacksquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_14.started')
                # update status
                blacksquare_14.status = STARTED
                blacksquare_14.setAutoDraw(True)
            
            # if blacksquare_14 is active this frame...
            if blacksquare_14.status == STARTED:
                # update params
                pass
            
            # *white_cross_14* updates
            
            # if white_cross_14 is starting this frame...
            if white_cross_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_14.frameNStart = frameN  # exact frame index
                white_cross_14.tStart = t  # local t and not account for scr refresh
                white_cross_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_14.started')
                # update status
                white_cross_14.status = STARTED
                white_cross_14.setAutoDraw(True)
            
            # if white_cross_14 is active this frame...
            if white_cross_14.status == STARTED:
                # update params
                pass
            
            # *key_resp_17* updates
            waitOnFlip = False
            
            # if key_resp_17 is starting this frame...
            if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_17.frameNStart = frameN  # exact frame index
                key_resp_17.tStart = t  # local t and not account for scr refresh
                key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_17.started')
                # update status
                key_resp_17.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_17.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_17.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_17_allKeys.extend(theseKeys)
                if len(_key_resp_17_allKeys):
                    key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
                    key_resp_17.rt = _key_resp_17_allKeys[-1].rt
                    key_resp_17.duration = _key_resp_17_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_17.keys == str('left')) or (key_resp_17.keys == 'left'):
                        key_resp_17.corr = 1
                    else:
                        key_resp_17.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_5* updates
            
            # if UP_5 is starting this frame...
            if UP_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_5.frameNStart = frameN  # exact frame index
                UP_5.tStart = t  # local t and not account for scr refresh
                UP_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_5.started')
                # update status
                UP_5.status = STARTED
                UP_5.setAutoDraw(True)
            
            # if UP_5 is active this frame...
            if UP_5.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_2* updates
            
            # if up_whitesquare_2 is starting this frame...
            if up_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_2.frameNStart = frameN  # exact frame index
                up_whitesquare_2.tStart = t  # local t and not account for scr refresh
                up_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_2.started')
                # update status
                up_whitesquare_2.status = STARTED
                up_whitesquare_2.setAutoDraw(True)
            
            # if up_whitesquare_2 is active this frame...
            if up_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_2 is stopping this frame...
            if up_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_2.tStop = t  # not accounting for scr refresh
                    up_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_2.stopped')
                    # update status
                    up_whitesquare_2.status = FINISHED
                    up_whitesquare_2.setAutoDraw(False)
            
            # *down_whitesquare_2* updates
            
            # if down_whitesquare_2 is starting this frame...
            if down_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_2.frameNStart = frameN  # exact frame index
                down_whitesquare_2.tStart = t  # local t and not account for scr refresh
                down_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_2.started')
                # update status
                down_whitesquare_2.status = STARTED
                down_whitesquare_2.setAutoDraw(True)
            
            # if down_whitesquare_2 is active this frame...
            if down_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_2 is stopping this frame...
            if down_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_2.tStop = t  # not accounting for scr refresh
                    down_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_2.stopped')
                    # update status
                    down_whitesquare_2.status = FINISHED
                    down_whitesquare_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_up" ---
        for thisComponent in UP_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_up
        UP_on_up.tStop = globalClock.getTime(format='float')
        UP_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_up.stopped', UP_on_up.tStop)
        # check responses
        if key_resp_17.keys in ['', [], None]:  # No response was made
            key_resp_17.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_17.corr = 1;  # correct non-response
            else:
               key_resp_17.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_17.keys',key_resp_17.keys)
        trials_b4.addData('key_resp_17.corr', key_resp_17.corr)
        if key_resp_17.keys != None:  # we had a response
            trials_b4.addData('key_resp_17.rt', key_resp_17.rt)
            trials_b4.addData('key_resp_17.duration', key_resp_17.duration)
        # the Routine "UP_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_up" ---
        # create an object to store info about Routine DOWN_on_up
        DOWN_on_up = data.Routine(
            name='DOWN_on_up',
            components=[blacksquare_15, white_cross_15, key_resp_18, UP, up_whitesquare_4, down_whitesquare_4],
        )
        DOWN_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_18
        key_resp_18.keys = []
        key_resp_18.rt = []
        _key_resp_18_allKeys = []
        # Run 'Begin Routine' code from code_16
        
        
        if currentRoutine != "DOWN_on_up":
            continueRoutine = False
        
        # store start times for DOWN_on_up
        DOWN_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_up.tStart = globalClock.getTime(format='float')
        DOWN_on_up.status = STARTED
        thisExp.addData('DOWN_on_up.started', DOWN_on_up.tStart)
        DOWN_on_up.maxDuration = None
        # keep track of which components have finished
        DOWN_on_upComponents = DOWN_on_up.components
        for thisComponent in DOWN_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_15* updates
            
            # if blacksquare_15 is starting this frame...
            if blacksquare_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_15.frameNStart = frameN  # exact frame index
                blacksquare_15.tStart = t  # local t and not account for scr refresh
                blacksquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_15.started')
                # update status
                blacksquare_15.status = STARTED
                blacksquare_15.setAutoDraw(True)
            
            # if blacksquare_15 is active this frame...
            if blacksquare_15.status == STARTED:
                # update params
                pass
            
            # *white_cross_15* updates
            
            # if white_cross_15 is starting this frame...
            if white_cross_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_15.frameNStart = frameN  # exact frame index
                white_cross_15.tStart = t  # local t and not account for scr refresh
                white_cross_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_15.started')
                # update status
                white_cross_15.status = STARTED
                white_cross_15.setAutoDraw(True)
            
            # if white_cross_15 is active this frame...
            if white_cross_15.status == STARTED:
                # update params
                pass
            
            # *key_resp_18* updates
            waitOnFlip = False
            
            # if key_resp_18 is starting this frame...
            if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_18.frameNStart = frameN  # exact frame index
                key_resp_18.tStart = t  # local t and not account for scr refresh
                key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_18.started')
                # update status
                key_resp_18.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_18.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_18.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_18_allKeys.extend(theseKeys)
                if len(_key_resp_18_allKeys):
                    key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
                    key_resp_18.rt = _key_resp_18_allKeys[-1].rt
                    key_resp_18.duration = _key_resp_18_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_18.keys == str('left')) or (key_resp_18.keys == 'left'):
                        key_resp_18.corr = 1
                    else:
                        key_resp_18.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP* updates
            
            # if UP is starting this frame...
            if UP.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP.frameNStart = frameN  # exact frame index
                UP.tStart = t  # local t and not account for scr refresh
                UP.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP.started')
                # update status
                UP.status = STARTED
                UP.setAutoDraw(True)
            
            # if UP is active this frame...
            if UP.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_4* updates
            
            # if up_whitesquare_4 is starting this frame...
            if up_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_4.frameNStart = frameN  # exact frame index
                up_whitesquare_4.tStart = t  # local t and not account for scr refresh
                up_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_4.started')
                # update status
                up_whitesquare_4.status = STARTED
                up_whitesquare_4.setAutoDraw(True)
            
            # if up_whitesquare_4 is active this frame...
            if up_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_4 is stopping this frame...
            if up_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_4.tStop = t  # not accounting for scr refresh
                    up_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_4.stopped')
                    # update status
                    up_whitesquare_4.status = FINISHED
                    up_whitesquare_4.setAutoDraw(False)
            
            # *down_whitesquare_4* updates
            
            # if down_whitesquare_4 is starting this frame...
            if down_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_4.frameNStart = frameN  # exact frame index
                down_whitesquare_4.tStart = t  # local t and not account for scr refresh
                down_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_4.started')
                # update status
                down_whitesquare_4.status = STARTED
                down_whitesquare_4.setAutoDraw(True)
            
            # if down_whitesquare_4 is active this frame...
            if down_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_4 is stopping this frame...
            if down_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_4.tStop = t  # not accounting for scr refresh
                    down_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_4.stopped')
                    # update status
                    down_whitesquare_4.status = FINISHED
                    down_whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_up" ---
        for thisComponent in DOWN_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_up
        DOWN_on_up.tStop = globalClock.getTime(format='float')
        DOWN_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_up.stopped', DOWN_on_up.tStop)
        # check responses
        if key_resp_18.keys in ['', [], None]:  # No response was made
            key_resp_18.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_18.corr = 1;  # correct non-response
            else:
               key_resp_18.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_18.keys',key_resp_18.keys)
        trials_b4.addData('key_resp_18.corr', key_resp_18.corr)
        if key_resp_18.keys != None:  # we had a response
            trials_b4.addData('key_resp_18.rt', key_resp_18.rt)
            trials_b4.addData('key_resp_18.duration', key_resp_18.duration)
        # the Routine "DOWN_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_down" ---
        # create an object to store info about Routine UP_on_down
        UP_on_down = data.Routine(
            name='UP_on_down',
            components=[blacksquare_16, white_cross_16, key_resp_19, UP_6, up_whitesquare_6, down_whitesquare_6],
        )
        UP_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_19
        key_resp_19.keys = []
        key_resp_19.rt = []
        _key_resp_19_allKeys = []
        # Run 'Begin Routine' code from code_18
        
        
        if currentRoutine != "UP_on_down":
            continueRoutine = False
        
        # store start times for UP_on_down
        UP_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_down.tStart = globalClock.getTime(format='float')
        UP_on_down.status = STARTED
        thisExp.addData('UP_on_down.started', UP_on_down.tStart)
        UP_on_down.maxDuration = None
        # keep track of which components have finished
        UP_on_downComponents = UP_on_down.components
        for thisComponent in UP_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        UP_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_16* updates
            
            # if blacksquare_16 is starting this frame...
            if blacksquare_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_16.frameNStart = frameN  # exact frame index
                blacksquare_16.tStart = t  # local t and not account for scr refresh
                blacksquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_16.started')
                # update status
                blacksquare_16.status = STARTED
                blacksquare_16.setAutoDraw(True)
            
            # if blacksquare_16 is active this frame...
            if blacksquare_16.status == STARTED:
                # update params
                pass
            
            # *white_cross_16* updates
            
            # if white_cross_16 is starting this frame...
            if white_cross_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_16.frameNStart = frameN  # exact frame index
                white_cross_16.tStart = t  # local t and not account for scr refresh
                white_cross_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_16.started')
                # update status
                white_cross_16.status = STARTED
                white_cross_16.setAutoDraw(True)
            
            # if white_cross_16 is active this frame...
            if white_cross_16.status == STARTED:
                # update params
                pass
            
            # *key_resp_19* updates
            waitOnFlip = False
            
            # if key_resp_19 is starting this frame...
            if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_19.frameNStart = frameN  # exact frame index
                key_resp_19.tStart = t  # local t and not account for scr refresh
                key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_19.started')
                # update status
                key_resp_19.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_19.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_19.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_19_allKeys.extend(theseKeys)
                if len(_key_resp_19_allKeys):
                    key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
                    key_resp_19.rt = _key_resp_19_allKeys[-1].rt
                    key_resp_19.duration = _key_resp_19_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_19.keys == str('left')) or (key_resp_19.keys == 'left'):
                        key_resp_19.corr = 1
                    else:
                        key_resp_19.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_6* updates
            
            # if UP_6 is starting this frame...
            if UP_6.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_6.frameNStart = frameN  # exact frame index
                UP_6.tStart = t  # local t and not account for scr refresh
                UP_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_6.started')
                # update status
                UP_6.status = STARTED
                UP_6.setAutoDraw(True)
            
            # if UP_6 is active this frame...
            if UP_6.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_6* updates
            
            # if up_whitesquare_6 is starting this frame...
            if up_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_6.frameNStart = frameN  # exact frame index
                up_whitesquare_6.tStart = t  # local t and not account for scr refresh
                up_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_6.started')
                # update status
                up_whitesquare_6.status = STARTED
                up_whitesquare_6.setAutoDraw(True)
            
            # if up_whitesquare_6 is active this frame...
            if up_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_6 is stopping this frame...
            if up_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_6.tStop = t  # not accounting for scr refresh
                    up_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_6.stopped')
                    # update status
                    up_whitesquare_6.status = FINISHED
                    up_whitesquare_6.setAutoDraw(False)
            
            # *down_whitesquare_6* updates
            
            # if down_whitesquare_6 is starting this frame...
            if down_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_6.frameNStart = frameN  # exact frame index
                down_whitesquare_6.tStart = t  # local t and not account for scr refresh
                down_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_6.started')
                # update status
                down_whitesquare_6.status = STARTED
                down_whitesquare_6.setAutoDraw(True)
            
            # if down_whitesquare_6 is active this frame...
            if down_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_6 is stopping this frame...
            if down_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_6.tStop = t  # not accounting for scr refresh
                    down_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_6.stopped')
                    # update status
                    down_whitesquare_6.status = FINISHED
                    down_whitesquare_6.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_down" ---
        for thisComponent in UP_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_down
        UP_on_down.tStop = globalClock.getTime(format='float')
        UP_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_down.stopped', UP_on_down.tStop)
        # check responses
        if key_resp_19.keys in ['', [], None]:  # No response was made
            key_resp_19.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_19.corr = 1;  # correct non-response
            else:
               key_resp_19.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_19.keys',key_resp_19.keys)
        trials_b4.addData('key_resp_19.corr', key_resp_19.corr)
        if key_resp_19.keys != None:  # we had a response
            trials_b4.addData('key_resp_19.rt', key_resp_19.rt)
            trials_b4.addData('key_resp_19.duration', key_resp_19.duration)
        # the Routine "UP_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_down" ---
        # create an object to store info about Routine DOWN_on_down
        DOWN_on_down = data.Routine(
            name='DOWN_on_down',
            components=[blacksquare_17, white_cross_17, key_resp_20, UP_7, up_whitesquare_8, down_whitesquare_8],
        )
        DOWN_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_20
        key_resp_20.keys = []
        key_resp_20.rt = []
        _key_resp_20_allKeys = []
        # Run 'Begin Routine' code from code_20
        
        
        if currentRoutine != "DOWN_on_down":
            continueRoutine = False
        
        # store start times for DOWN_on_down
        DOWN_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_down.tStart = globalClock.getTime(format='float')
        DOWN_on_down.status = STARTED
        thisExp.addData('DOWN_on_down.started', DOWN_on_down.tStart)
        DOWN_on_down.maxDuration = None
        # keep track of which components have finished
        DOWN_on_downComponents = DOWN_on_down.components
        for thisComponent in DOWN_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_17* updates
            
            # if blacksquare_17 is starting this frame...
            if blacksquare_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_17.frameNStart = frameN  # exact frame index
                blacksquare_17.tStart = t  # local t and not account for scr refresh
                blacksquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_17.started')
                # update status
                blacksquare_17.status = STARTED
                blacksquare_17.setAutoDraw(True)
            
            # if blacksquare_17 is active this frame...
            if blacksquare_17.status == STARTED:
                # update params
                pass
            
            # *white_cross_17* updates
            
            # if white_cross_17 is starting this frame...
            if white_cross_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_17.frameNStart = frameN  # exact frame index
                white_cross_17.tStart = t  # local t and not account for scr refresh
                white_cross_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_17.started')
                # update status
                white_cross_17.status = STARTED
                white_cross_17.setAutoDraw(True)
            
            # if white_cross_17 is active this frame...
            if white_cross_17.status == STARTED:
                # update params
                pass
            
            # *key_resp_20* updates
            waitOnFlip = False
            
            # if key_resp_20 is starting this frame...
            if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_20.frameNStart = frameN  # exact frame index
                key_resp_20.tStart = t  # local t and not account for scr refresh
                key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_20.started')
                # update status
                key_resp_20.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_20.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_20.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_20_allKeys.extend(theseKeys)
                if len(_key_resp_20_allKeys):
                    key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
                    key_resp_20.rt = _key_resp_20_allKeys[-1].rt
                    key_resp_20.duration = _key_resp_20_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_20.keys == str('left')) or (key_resp_20.keys == 'left'):
                        key_resp_20.corr = 1
                    else:
                        key_resp_20.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_7* updates
            
            # if UP_7 is starting this frame...
            if UP_7.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_7.frameNStart = frameN  # exact frame index
                UP_7.tStart = t  # local t and not account for scr refresh
                UP_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_7.started')
                # update status
                UP_7.status = STARTED
                UP_7.setAutoDraw(True)
            
            # if UP_7 is active this frame...
            if UP_7.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_8* updates
            
            # if up_whitesquare_8 is starting this frame...
            if up_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_8.frameNStart = frameN  # exact frame index
                up_whitesquare_8.tStart = t  # local t and not account for scr refresh
                up_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_8.started')
                # update status
                up_whitesquare_8.status = STARTED
                up_whitesquare_8.setAutoDraw(True)
            
            # if up_whitesquare_8 is active this frame...
            if up_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_8 is stopping this frame...
            if up_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_8.tStop = t  # not accounting for scr refresh
                    up_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_8.stopped')
                    # update status
                    up_whitesquare_8.status = FINISHED
                    up_whitesquare_8.setAutoDraw(False)
            
            # *down_whitesquare_8* updates
            
            # if down_whitesquare_8 is starting this frame...
            if down_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_8.frameNStart = frameN  # exact frame index
                down_whitesquare_8.tStart = t  # local t and not account for scr refresh
                down_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_8.started')
                # update status
                down_whitesquare_8.status = STARTED
                down_whitesquare_8.setAutoDraw(True)
            
            # if down_whitesquare_8 is active this frame...
            if down_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_8 is stopping this frame...
            if down_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_8.tStop = t  # not accounting for scr refresh
                    down_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_8.stopped')
                    # update status
                    down_whitesquare_8.status = FINISHED
                    down_whitesquare_8.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_down" ---
        for thisComponent in DOWN_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_down
        DOWN_on_down.tStop = globalClock.getTime(format='float')
        DOWN_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_down.stopped', DOWN_on_down.tStop)
        # check responses
        if key_resp_20.keys in ['', [], None]:  # No response was made
            key_resp_20.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_20.corr = 1;  # correct non-response
            else:
               key_resp_20.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_20.keys',key_resp_20.keys)
        trials_b4.addData('key_resp_20.corr', key_resp_20.corr)
        if key_resp_20.keys != None:  # we had a response
            trials_b4.addData('key_resp_20.rt', key_resp_20.rt)
            trials_b4.addData('key_resp_20.duration', key_resp_20.duration)
        # the Routine "DOWN_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_right" ---
        # create an object to store info about Routine leftA_on_right
        leftA_on_right = data.Routine(
            name='leftA_on_right',
            components=[blacksquare_18, white_cross_18, key_resp_21, arrow_l_2, whitesquare_5, whitesquare_12],
        )
        leftA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_21
        key_resp_21.keys = []
        key_resp_21.rt = []
        _key_resp_21_allKeys = []
        # Run 'Begin Routine' code from code_7
        
        
        if currentRoutine != "leftA_on_right":
            continueRoutine = False
        
        # store start times for leftA_on_right
        leftA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_right.tStart = globalClock.getTime(format='float')
        leftA_on_right.status = STARTED
        thisExp.addData('leftA_on_right.started', leftA_on_right.tStart)
        leftA_on_right.maxDuration = None
        # keep track of which components have finished
        leftA_on_rightComponents = leftA_on_right.components
        for thisComponent in leftA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        leftA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_18* updates
            
            # if blacksquare_18 is starting this frame...
            if blacksquare_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_18.frameNStart = frameN  # exact frame index
                blacksquare_18.tStart = t  # local t and not account for scr refresh
                blacksquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_18.started')
                # update status
                blacksquare_18.status = STARTED
                blacksquare_18.setAutoDraw(True)
            
            # if blacksquare_18 is active this frame...
            if blacksquare_18.status == STARTED:
                # update params
                pass
            
            # *white_cross_18* updates
            
            # if white_cross_18 is starting this frame...
            if white_cross_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_18.frameNStart = frameN  # exact frame index
                white_cross_18.tStart = t  # local t and not account for scr refresh
                white_cross_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_18.started')
                # update status
                white_cross_18.status = STARTED
                white_cross_18.setAutoDraw(True)
            
            # if white_cross_18 is active this frame...
            if white_cross_18.status == STARTED:
                # update params
                pass
            
            # *key_resp_21* updates
            waitOnFlip = False
            
            # if key_resp_21 is starting this frame...
            if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_21.frameNStart = frameN  # exact frame index
                key_resp_21.tStart = t  # local t and not account for scr refresh
                key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_21.started')
                # update status
                key_resp_21.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_21.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_21.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_21_allKeys.extend(theseKeys)
                if len(_key_resp_21_allKeys):
                    key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
                    key_resp_21.rt = _key_resp_21_allKeys[-1].rt
                    key_resp_21.duration = _key_resp_21_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_21.keys == str('left')) or (key_resp_21.keys == 'left'):
                        key_resp_21.corr = 1
                    else:
                        key_resp_21.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_2* updates
            
            # if arrow_l_2 is starting this frame...
            if arrow_l_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_2.frameNStart = frameN  # exact frame index
                arrow_l_2.tStart = t  # local t and not account for scr refresh
                arrow_l_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_2.started')
                # update status
                arrow_l_2.status = STARTED
                arrow_l_2.setAutoDraw(True)
            
            # if arrow_l_2 is active this frame...
            if arrow_l_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_5* updates
            
            # if whitesquare_5 is starting this frame...
            if whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_5.frameNStart = frameN  # exact frame index
                whitesquare_5.tStart = t  # local t and not account for scr refresh
                whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_5.started')
                # update status
                whitesquare_5.status = STARTED
                whitesquare_5.setAutoDraw(True)
            
            # if whitesquare_5 is active this frame...
            if whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if whitesquare_5 is stopping this frame...
            if whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_5.tStop = t  # not accounting for scr refresh
                    whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_5.stopped')
                    # update status
                    whitesquare_5.status = FINISHED
                    whitesquare_5.setAutoDraw(False)
            
            # *whitesquare_12* updates
            
            # if whitesquare_12 is starting this frame...
            if whitesquare_12.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_12.frameNStart = frameN  # exact frame index
                whitesquare_12.tStart = t  # local t and not account for scr refresh
                whitesquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_12.started')
                # update status
                whitesquare_12.status = STARTED
                whitesquare_12.setAutoDraw(True)
            
            # if whitesquare_12 is active this frame...
            if whitesquare_12.status == STARTED:
                # update params
                pass
            
            # if whitesquare_12 is stopping this frame...
            if whitesquare_12.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_12.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_12.tStop = t  # not accounting for scr refresh
                    whitesquare_12.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_12.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_12.stopped')
                    # update status
                    whitesquare_12.status = FINISHED
                    whitesquare_12.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_right" ---
        for thisComponent in leftA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_right
        leftA_on_right.tStop = globalClock.getTime(format='float')
        leftA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_right.stopped', leftA_on_right.tStop)
        # check responses
        if key_resp_21.keys in ['', [], None]:  # No response was made
            key_resp_21.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_21.corr = 1;  # correct non-response
            else:
               key_resp_21.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_21.keys',key_resp_21.keys)
        trials_b4.addData('key_resp_21.corr', key_resp_21.corr)
        if key_resp_21.keys != None:  # we had a response
            trials_b4.addData('key_resp_21.rt', key_resp_21.rt)
            trials_b4.addData('key_resp_21.duration', key_resp_21.duration)
        # the Routine "leftA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_left" ---
        # create an object to store info about Routine leftA_on_left
        leftA_on_left = data.Routine(
            name='leftA_on_left',
            components=[blacksquare_19, white_cross_19, key_resp_22, arrow_l_3, whitesquare_7, whitesquare_14],
        )
        leftA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_22
        key_resp_22.keys = []
        key_resp_22.rt = []
        _key_resp_22_allKeys = []
        # Run 'Begin Routine' code from code_9
        
        
        if currentRoutine != "leftA_on_left":
            continueRoutine = False
        
        # store start times for leftA_on_left
        leftA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_left.tStart = globalClock.getTime(format='float')
        leftA_on_left.status = STARTED
        thisExp.addData('leftA_on_left.started', leftA_on_left.tStart)
        leftA_on_left.maxDuration = None
        # keep track of which components have finished
        leftA_on_leftComponents = leftA_on_left.components
        for thisComponent in leftA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        leftA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_19* updates
            
            # if blacksquare_19 is starting this frame...
            if blacksquare_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_19.frameNStart = frameN  # exact frame index
                blacksquare_19.tStart = t  # local t and not account for scr refresh
                blacksquare_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_19.started')
                # update status
                blacksquare_19.status = STARTED
                blacksquare_19.setAutoDraw(True)
            
            # if blacksquare_19 is active this frame...
            if blacksquare_19.status == STARTED:
                # update params
                pass
            
            # *white_cross_19* updates
            
            # if white_cross_19 is starting this frame...
            if white_cross_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_19.frameNStart = frameN  # exact frame index
                white_cross_19.tStart = t  # local t and not account for scr refresh
                white_cross_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_19.started')
                # update status
                white_cross_19.status = STARTED
                white_cross_19.setAutoDraw(True)
            
            # if white_cross_19 is active this frame...
            if white_cross_19.status == STARTED:
                # update params
                pass
            
            # *key_resp_22* updates
            waitOnFlip = False
            
            # if key_resp_22 is starting this frame...
            if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_22.frameNStart = frameN  # exact frame index
                key_resp_22.tStart = t  # local t and not account for scr refresh
                key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_22.started')
                # update status
                key_resp_22.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_22.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_22.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_22_allKeys.extend(theseKeys)
                if len(_key_resp_22_allKeys):
                    key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
                    key_resp_22.rt = _key_resp_22_allKeys[-1].rt
                    key_resp_22.duration = _key_resp_22_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_22.keys == str('left')) or (key_resp_22.keys == 'left'):
                        key_resp_22.corr = 1
                    else:
                        key_resp_22.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_3* updates
            
            # if arrow_l_3 is starting this frame...
            if arrow_l_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_3.frameNStart = frameN  # exact frame index
                arrow_l_3.tStart = t  # local t and not account for scr refresh
                arrow_l_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_3.started')
                # update status
                arrow_l_3.status = STARTED
                arrow_l_3.setAutoDraw(True)
            
            # if arrow_l_3 is active this frame...
            if arrow_l_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_7* updates
            
            # if whitesquare_7 is starting this frame...
            if whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_7.frameNStart = frameN  # exact frame index
                whitesquare_7.tStart = t  # local t and not account for scr refresh
                whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_7.started')
                # update status
                whitesquare_7.status = STARTED
                whitesquare_7.setAutoDraw(True)
            
            # if whitesquare_7 is active this frame...
            if whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if whitesquare_7 is stopping this frame...
            if whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_7.tStop = t  # not accounting for scr refresh
                    whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_7.stopped')
                    # update status
                    whitesquare_7.status = FINISHED
                    whitesquare_7.setAutoDraw(False)
            
            # *whitesquare_14* updates
            
            # if whitesquare_14 is starting this frame...
            if whitesquare_14.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_14.frameNStart = frameN  # exact frame index
                whitesquare_14.tStart = t  # local t and not account for scr refresh
                whitesquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_14.started')
                # update status
                whitesquare_14.status = STARTED
                whitesquare_14.setAutoDraw(True)
            
            # if whitesquare_14 is active this frame...
            if whitesquare_14.status == STARTED:
                # update params
                pass
            
            # if whitesquare_14 is stopping this frame...
            if whitesquare_14.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_14.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_14.tStop = t  # not accounting for scr refresh
                    whitesquare_14.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_14.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_14.stopped')
                    # update status
                    whitesquare_14.status = FINISHED
                    whitesquare_14.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_left" ---
        for thisComponent in leftA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_left
        leftA_on_left.tStop = globalClock.getTime(format='float')
        leftA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_left.stopped', leftA_on_left.tStop)
        # check responses
        if key_resp_22.keys in ['', [], None]:  # No response was made
            key_resp_22.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_22.corr = 1;  # correct non-response
            else:
               key_resp_22.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_22.keys',key_resp_22.keys)
        trials_b4.addData('key_resp_22.corr', key_resp_22.corr)
        if key_resp_22.keys != None:  # we had a response
            trials_b4.addData('key_resp_22.rt', key_resp_22.rt)
            trials_b4.addData('key_resp_22.duration', key_resp_22.duration)
        # the Routine "leftA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_right" ---
        # create an object to store info about Routine rightA_on_right
        rightA_on_right = data.Routine(
            name='rightA_on_right',
            components=[blacksquare_20, white_cross_20, key_resp_23, arrow_l_4, whitesquare_11, whitesquare_18],
        )
        rightA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_23
        key_resp_23.keys = []
        key_resp_23.rt = []
        _key_resp_23_allKeys = []
        # Run 'Begin Routine' code from code_13
        
        
        if currentRoutine != "rightA_on_right":
            continueRoutine = False
        
        # store start times for rightA_on_right
        rightA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_right.tStart = globalClock.getTime(format='float')
        rightA_on_right.status = STARTED
        thisExp.addData('rightA_on_right.started', rightA_on_right.tStart)
        rightA_on_right.maxDuration = None
        # keep track of which components have finished
        rightA_on_rightComponents = rightA_on_right.components
        for thisComponent in rightA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        rightA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_20* updates
            
            # if blacksquare_20 is starting this frame...
            if blacksquare_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_20.frameNStart = frameN  # exact frame index
                blacksquare_20.tStart = t  # local t and not account for scr refresh
                blacksquare_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_20.started')
                # update status
                blacksquare_20.status = STARTED
                blacksquare_20.setAutoDraw(True)
            
            # if blacksquare_20 is active this frame...
            if blacksquare_20.status == STARTED:
                # update params
                pass
            
            # *white_cross_20* updates
            
            # if white_cross_20 is starting this frame...
            if white_cross_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_20.frameNStart = frameN  # exact frame index
                white_cross_20.tStart = t  # local t and not account for scr refresh
                white_cross_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_20.started')
                # update status
                white_cross_20.status = STARTED
                white_cross_20.setAutoDraw(True)
            
            # if white_cross_20 is active this frame...
            if white_cross_20.status == STARTED:
                # update params
                pass
            
            # *key_resp_23* updates
            waitOnFlip = False
            
            # if key_resp_23 is starting this frame...
            if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_23.frameNStart = frameN  # exact frame index
                key_resp_23.tStart = t  # local t and not account for scr refresh
                key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_23.started')
                # update status
                key_resp_23.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_23.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_23.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_23_allKeys.extend(theseKeys)
                if len(_key_resp_23_allKeys):
                    key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
                    key_resp_23.rt = _key_resp_23_allKeys[-1].rt
                    key_resp_23.duration = _key_resp_23_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_23.keys == str('left')) or (key_resp_23.keys == 'left'):
                        key_resp_23.corr = 1
                    else:
                        key_resp_23.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_4* updates
            
            # if arrow_l_4 is starting this frame...
            if arrow_l_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_4.frameNStart = frameN  # exact frame index
                arrow_l_4.tStart = t  # local t and not account for scr refresh
                arrow_l_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_4.started')
                # update status
                arrow_l_4.status = STARTED
                arrow_l_4.setAutoDraw(True)
            
            # if arrow_l_4 is active this frame...
            if arrow_l_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_11* updates
            
            # if whitesquare_11 is starting this frame...
            if whitesquare_11.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_11.frameNStart = frameN  # exact frame index
                whitesquare_11.tStart = t  # local t and not account for scr refresh
                whitesquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_11.started')
                # update status
                whitesquare_11.status = STARTED
                whitesquare_11.setAutoDraw(True)
            
            # if whitesquare_11 is active this frame...
            if whitesquare_11.status == STARTED:
                # update params
                pass
            
            # if whitesquare_11 is stopping this frame...
            if whitesquare_11.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_11.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_11.tStop = t  # not accounting for scr refresh
                    whitesquare_11.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_11.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_11.stopped')
                    # update status
                    whitesquare_11.status = FINISHED
                    whitesquare_11.setAutoDraw(False)
            
            # *whitesquare_18* updates
            
            # if whitesquare_18 is starting this frame...
            if whitesquare_18.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_18.frameNStart = frameN  # exact frame index
                whitesquare_18.tStart = t  # local t and not account for scr refresh
                whitesquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_18.started')
                # update status
                whitesquare_18.status = STARTED
                whitesquare_18.setAutoDraw(True)
            
            # if whitesquare_18 is active this frame...
            if whitesquare_18.status == STARTED:
                # update params
                pass
            
            # if whitesquare_18 is stopping this frame...
            if whitesquare_18.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_18.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_18.tStop = t  # not accounting for scr refresh
                    whitesquare_18.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_18.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_18.stopped')
                    # update status
                    whitesquare_18.status = FINISHED
                    whitesquare_18.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_right" ---
        for thisComponent in rightA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_right
        rightA_on_right.tStop = globalClock.getTime(format='float')
        rightA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_right.stopped', rightA_on_right.tStop)
        # check responses
        if key_resp_23.keys in ['', [], None]:  # No response was made
            key_resp_23.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_23.corr = 1;  # correct non-response
            else:
               key_resp_23.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_23.keys',key_resp_23.keys)
        trials_b4.addData('key_resp_23.corr', key_resp_23.corr)
        if key_resp_23.keys != None:  # we had a response
            trials_b4.addData('key_resp_23.rt', key_resp_23.rt)
            trials_b4.addData('key_resp_23.duration', key_resp_23.duration)
        # the Routine "rightA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_left" ---
        # create an object to store info about Routine rightA_on_left
        rightA_on_left = data.Routine(
            name='rightA_on_left',
            components=[blacksquare_21, white_cross_21, key_resp_24, arrow_l_5, whitesquare_9, whitesquare_16],
        )
        rightA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_24
        key_resp_24.keys = []
        key_resp_24.rt = []
        _key_resp_24_allKeys = []
        # Run 'Begin Routine' code from code_11
        
        
        if currentRoutine != "rightA_on_left":
            continueRoutine = False
        
        # store start times for rightA_on_left
        rightA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_left.tStart = globalClock.getTime(format='float')
        rightA_on_left.status = STARTED
        thisExp.addData('rightA_on_left.started', rightA_on_left.tStart)
        rightA_on_left.maxDuration = None
        # keep track of which components have finished
        rightA_on_leftComponents = rightA_on_left.components
        for thisComponent in rightA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        rightA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_21* updates
            
            # if blacksquare_21 is starting this frame...
            if blacksquare_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_21.frameNStart = frameN  # exact frame index
                blacksquare_21.tStart = t  # local t and not account for scr refresh
                blacksquare_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_21.started')
                # update status
                blacksquare_21.status = STARTED
                blacksquare_21.setAutoDraw(True)
            
            # if blacksquare_21 is active this frame...
            if blacksquare_21.status == STARTED:
                # update params
                pass
            
            # *white_cross_21* updates
            
            # if white_cross_21 is starting this frame...
            if white_cross_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_21.frameNStart = frameN  # exact frame index
                white_cross_21.tStart = t  # local t and not account for scr refresh
                white_cross_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_21.started')
                # update status
                white_cross_21.status = STARTED
                white_cross_21.setAutoDraw(True)
            
            # if white_cross_21 is active this frame...
            if white_cross_21.status == STARTED:
                # update params
                pass
            
            # *key_resp_24* updates
            waitOnFlip = False
            
            # if key_resp_24 is starting this frame...
            if key_resp_24.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_24.frameNStart = frameN  # exact frame index
                key_resp_24.tStart = t  # local t and not account for scr refresh
                key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_24.started')
                # update status
                key_resp_24.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_24.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_24.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_24_allKeys.extend(theseKeys)
                if len(_key_resp_24_allKeys):
                    key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
                    key_resp_24.rt = _key_resp_24_allKeys[-1].rt
                    key_resp_24.duration = _key_resp_24_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_24.keys == str('left')) or (key_resp_24.keys == 'left'):
                        key_resp_24.corr = 1
                    else:
                        key_resp_24.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_5* updates
            
            # if arrow_l_5 is starting this frame...
            if arrow_l_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_5.frameNStart = frameN  # exact frame index
                arrow_l_5.tStart = t  # local t and not account for scr refresh
                arrow_l_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_5.started')
                # update status
                arrow_l_5.status = STARTED
                arrow_l_5.setAutoDraw(True)
            
            # if arrow_l_5 is active this frame...
            if arrow_l_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_9* updates
            
            # if whitesquare_9 is starting this frame...
            if whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_9.frameNStart = frameN  # exact frame index
                whitesquare_9.tStart = t  # local t and not account for scr refresh
                whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_9.started')
                # update status
                whitesquare_9.status = STARTED
                whitesquare_9.setAutoDraw(True)
            
            # if whitesquare_9 is active this frame...
            if whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if whitesquare_9 is stopping this frame...
            if whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_9.tStop = t  # not accounting for scr refresh
                    whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_9.stopped')
                    # update status
                    whitesquare_9.status = FINISHED
                    whitesquare_9.setAutoDraw(False)
            
            # *whitesquare_16* updates
            
            # if whitesquare_16 is starting this frame...
            if whitesquare_16.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_16.frameNStart = frameN  # exact frame index
                whitesquare_16.tStart = t  # local t and not account for scr refresh
                whitesquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_16.started')
                # update status
                whitesquare_16.status = STARTED
                whitesquare_16.setAutoDraw(True)
            
            # if whitesquare_16 is active this frame...
            if whitesquare_16.status == STARTED:
                # update params
                pass
            
            # if whitesquare_16 is stopping this frame...
            if whitesquare_16.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_16.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_16.tStop = t  # not accounting for scr refresh
                    whitesquare_16.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_16.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_16.stopped')
                    # update status
                    whitesquare_16.status = FINISHED
                    whitesquare_16.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_left" ---
        for thisComponent in rightA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_left
        rightA_on_left.tStop = globalClock.getTime(format='float')
        rightA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_left.stopped', rightA_on_left.tStop)
        # check responses
        if key_resp_24.keys in ['', [], None]:  # No response was made
            key_resp_24.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_24.corr = 1;  # correct non-response
            else:
               key_resp_24.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_24.keys',key_resp_24.keys)
        trials_b4.addData('key_resp_24.corr', key_resp_24.corr)
        if key_resp_24.keys != None:  # we had a response
            trials_b4.addData('key_resp_24.rt', key_resp_24.rt)
            trials_b4.addData('key_resp_24.duration', key_resp_24.duration)
        # the Routine "rightA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_up" ---
        # create an object to store info about Routine upA_on_up
        upA_on_up = data.Routine(
            name='upA_on_up',
            components=[blacksquare_22, white_cross_22, key_resp_25, arrow_u, up_whitesquare_3, down_whitesquare_3],
        )
        upA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_25
        key_resp_25.keys = []
        key_resp_25.rt = []
        _key_resp_25_allKeys = []
        # Run 'Begin Routine' code from code_15
        
        
        if currentRoutine != "upA_on_up":
            continueRoutine = False
        
        # store start times for upA_on_up
        upA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_up.tStart = globalClock.getTime(format='float')
        upA_on_up.status = STARTED
        thisExp.addData('upA_on_up.started', upA_on_up.tStart)
        upA_on_up.maxDuration = None
        # keep track of which components have finished
        upA_on_upComponents = upA_on_up.components
        for thisComponent in upA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        upA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_22* updates
            
            # if blacksquare_22 is starting this frame...
            if blacksquare_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_22.frameNStart = frameN  # exact frame index
                blacksquare_22.tStart = t  # local t and not account for scr refresh
                blacksquare_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_22.started')
                # update status
                blacksquare_22.status = STARTED
                blacksquare_22.setAutoDraw(True)
            
            # if blacksquare_22 is active this frame...
            if blacksquare_22.status == STARTED:
                # update params
                pass
            
            # *white_cross_22* updates
            
            # if white_cross_22 is starting this frame...
            if white_cross_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_22.frameNStart = frameN  # exact frame index
                white_cross_22.tStart = t  # local t and not account for scr refresh
                white_cross_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_22.started')
                # update status
                white_cross_22.status = STARTED
                white_cross_22.setAutoDraw(True)
            
            # if white_cross_22 is active this frame...
            if white_cross_22.status == STARTED:
                # update params
                pass
            
            # *key_resp_25* updates
            waitOnFlip = False
            
            # if key_resp_25 is starting this frame...
            if key_resp_25.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_25.frameNStart = frameN  # exact frame index
                key_resp_25.tStart = t  # local t and not account for scr refresh
                key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_25.started')
                # update status
                key_resp_25.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_25.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_25.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_25_allKeys.extend(theseKeys)
                if len(_key_resp_25_allKeys):
                    key_resp_25.keys = _key_resp_25_allKeys[-1].name  # just the last key pressed
                    key_resp_25.rt = _key_resp_25_allKeys[-1].rt
                    key_resp_25.duration = _key_resp_25_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_25.keys == str('left')) or (key_resp_25.keys == 'left'):
                        key_resp_25.corr = 1
                    else:
                        key_resp_25.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u* updates
            
            # if arrow_u is starting this frame...
            if arrow_u.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u.frameNStart = frameN  # exact frame index
                arrow_u.tStart = t  # local t and not account for scr refresh
                arrow_u.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u.started')
                # update status
                arrow_u.status = STARTED
                arrow_u.setAutoDraw(True)
            
            # if arrow_u is active this frame...
            if arrow_u.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_3* updates
            
            # if up_whitesquare_3 is starting this frame...
            if up_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_3.frameNStart = frameN  # exact frame index
                up_whitesquare_3.tStart = t  # local t and not account for scr refresh
                up_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_3.started')
                # update status
                up_whitesquare_3.status = STARTED
                up_whitesquare_3.setAutoDraw(True)
            
            # if up_whitesquare_3 is active this frame...
            if up_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_3 is stopping this frame...
            if up_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_3.tStop = t  # not accounting for scr refresh
                    up_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_3.stopped')
                    # update status
                    up_whitesquare_3.status = FINISHED
                    up_whitesquare_3.setAutoDraw(False)
            
            # *down_whitesquare_3* updates
            
            # if down_whitesquare_3 is starting this frame...
            if down_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_3.frameNStart = frameN  # exact frame index
                down_whitesquare_3.tStart = t  # local t and not account for scr refresh
                down_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_3.started')
                # update status
                down_whitesquare_3.status = STARTED
                down_whitesquare_3.setAutoDraw(True)
            
            # if down_whitesquare_3 is active this frame...
            if down_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_3 is stopping this frame...
            if down_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_3.tStop = t  # not accounting for scr refresh
                    down_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_3.stopped')
                    # update status
                    down_whitesquare_3.status = FINISHED
                    down_whitesquare_3.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_up" ---
        for thisComponent in upA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_up
        upA_on_up.tStop = globalClock.getTime(format='float')
        upA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_up.stopped', upA_on_up.tStop)
        # check responses
        if key_resp_25.keys in ['', [], None]:  # No response was made
            key_resp_25.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_25.corr = 1;  # correct non-response
            else:
               key_resp_25.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_25.keys',key_resp_25.keys)
        trials_b4.addData('key_resp_25.corr', key_resp_25.corr)
        if key_resp_25.keys != None:  # we had a response
            trials_b4.addData('key_resp_25.rt', key_resp_25.rt)
            trials_b4.addData('key_resp_25.duration', key_resp_25.duration)
        # the Routine "upA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_down" ---
        # create an object to store info about Routine upA_on_down
        upA_on_down = data.Routine(
            name='upA_on_down',
            components=[blacksquare_23, white_cross_23, key_resp_26, arrow_u_2, up_whitesquare_7, down_whitesquare_7],
        )
        upA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_26
        key_resp_26.keys = []
        key_resp_26.rt = []
        _key_resp_26_allKeys = []
        # Run 'Begin Routine' code from code_19
        
        
        if currentRoutine != "upA_on_down":
            continueRoutine = False
        
        # store start times for upA_on_down
        upA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_down.tStart = globalClock.getTime(format='float')
        upA_on_down.status = STARTED
        thisExp.addData('upA_on_down.started', upA_on_down.tStart)
        upA_on_down.maxDuration = None
        # keep track of which components have finished
        upA_on_downComponents = upA_on_down.components
        for thisComponent in upA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        upA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_23* updates
            
            # if blacksquare_23 is starting this frame...
            if blacksquare_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_23.frameNStart = frameN  # exact frame index
                blacksquare_23.tStart = t  # local t and not account for scr refresh
                blacksquare_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_23.started')
                # update status
                blacksquare_23.status = STARTED
                blacksquare_23.setAutoDraw(True)
            
            # if blacksquare_23 is active this frame...
            if blacksquare_23.status == STARTED:
                # update params
                pass
            
            # *white_cross_23* updates
            
            # if white_cross_23 is starting this frame...
            if white_cross_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_23.frameNStart = frameN  # exact frame index
                white_cross_23.tStart = t  # local t and not account for scr refresh
                white_cross_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_23.started')
                # update status
                white_cross_23.status = STARTED
                white_cross_23.setAutoDraw(True)
            
            # if white_cross_23 is active this frame...
            if white_cross_23.status == STARTED:
                # update params
                pass
            
            # *key_resp_26* updates
            waitOnFlip = False
            
            # if key_resp_26 is starting this frame...
            if key_resp_26.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_26.frameNStart = frameN  # exact frame index
                key_resp_26.tStart = t  # local t and not account for scr refresh
                key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_26.started')
                # update status
                key_resp_26.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_26.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_26.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_26_allKeys.extend(theseKeys)
                if len(_key_resp_26_allKeys):
                    key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
                    key_resp_26.rt = _key_resp_26_allKeys[-1].rt
                    key_resp_26.duration = _key_resp_26_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_26.keys == str('left')) or (key_resp_26.keys == 'left'):
                        key_resp_26.corr = 1
                    else:
                        key_resp_26.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_2* updates
            
            # if arrow_u_2 is starting this frame...
            if arrow_u_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_2.frameNStart = frameN  # exact frame index
                arrow_u_2.tStart = t  # local t and not account for scr refresh
                arrow_u_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_2.started')
                # update status
                arrow_u_2.status = STARTED
                arrow_u_2.setAutoDraw(True)
            
            # if arrow_u_2 is active this frame...
            if arrow_u_2.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_7* updates
            
            # if up_whitesquare_7 is starting this frame...
            if up_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_7.frameNStart = frameN  # exact frame index
                up_whitesquare_7.tStart = t  # local t and not account for scr refresh
                up_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_7.started')
                # update status
                up_whitesquare_7.status = STARTED
                up_whitesquare_7.setAutoDraw(True)
            
            # if up_whitesquare_7 is active this frame...
            if up_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_7 is stopping this frame...
            if up_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_7.tStop = t  # not accounting for scr refresh
                    up_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_7.stopped')
                    # update status
                    up_whitesquare_7.status = FINISHED
                    up_whitesquare_7.setAutoDraw(False)
            
            # *down_whitesquare_7* updates
            
            # if down_whitesquare_7 is starting this frame...
            if down_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_7.frameNStart = frameN  # exact frame index
                down_whitesquare_7.tStart = t  # local t and not account for scr refresh
                down_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_7.started')
                # update status
                down_whitesquare_7.status = STARTED
                down_whitesquare_7.setAutoDraw(True)
            
            # if down_whitesquare_7 is active this frame...
            if down_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_7 is stopping this frame...
            if down_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_7.tStop = t  # not accounting for scr refresh
                    down_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_7.stopped')
                    # update status
                    down_whitesquare_7.status = FINISHED
                    down_whitesquare_7.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_down" ---
        for thisComponent in upA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_down
        upA_on_down.tStop = globalClock.getTime(format='float')
        upA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_down.stopped', upA_on_down.tStop)
        # check responses
        if key_resp_26.keys in ['', [], None]:  # No response was made
            key_resp_26.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_26.corr = 1;  # correct non-response
            else:
               key_resp_26.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_26.keys',key_resp_26.keys)
        trials_b4.addData('key_resp_26.corr', key_resp_26.corr)
        if key_resp_26.keys != None:  # we had a response
            trials_b4.addData('key_resp_26.rt', key_resp_26.rt)
            trials_b4.addData('key_resp_26.duration', key_resp_26.duration)
        # the Routine "upA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_down" ---
        # create an object to store info about Routine downA_on_down
        downA_on_down = data.Routine(
            name='downA_on_down',
            components=[blacksquare_24, white_cross_24, key_resp_27, arrow_u_3, up_whitesquare_9, down_whitesquare_9],
        )
        downA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_27
        key_resp_27.keys = []
        key_resp_27.rt = []
        _key_resp_27_allKeys = []
        # Run 'Begin Routine' code from code_21
        
        
        if currentRoutine != "downA_on_down":
            continueRoutine = False
        
        # store start times for downA_on_down
        downA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_down.tStart = globalClock.getTime(format='float')
        downA_on_down.status = STARTED
        thisExp.addData('downA_on_down.started', downA_on_down.tStart)
        downA_on_down.maxDuration = None
        # keep track of which components have finished
        downA_on_downComponents = downA_on_down.components
        for thisComponent in downA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        downA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_24* updates
            
            # if blacksquare_24 is starting this frame...
            if blacksquare_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_24.frameNStart = frameN  # exact frame index
                blacksquare_24.tStart = t  # local t and not account for scr refresh
                blacksquare_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_24.started')
                # update status
                blacksquare_24.status = STARTED
                blacksquare_24.setAutoDraw(True)
            
            # if blacksquare_24 is active this frame...
            if blacksquare_24.status == STARTED:
                # update params
                pass
            
            # *white_cross_24* updates
            
            # if white_cross_24 is starting this frame...
            if white_cross_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_24.frameNStart = frameN  # exact frame index
                white_cross_24.tStart = t  # local t and not account for scr refresh
                white_cross_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_24.started')
                # update status
                white_cross_24.status = STARTED
                white_cross_24.setAutoDraw(True)
            
            # if white_cross_24 is active this frame...
            if white_cross_24.status == STARTED:
                # update params
                pass
            
            # *key_resp_27* updates
            waitOnFlip = False
            
            # if key_resp_27 is starting this frame...
            if key_resp_27.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_27.frameNStart = frameN  # exact frame index
                key_resp_27.tStart = t  # local t and not account for scr refresh
                key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_27.started')
                # update status
                key_resp_27.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_27.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_27.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_27_allKeys.extend(theseKeys)
                if len(_key_resp_27_allKeys):
                    key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
                    key_resp_27.rt = _key_resp_27_allKeys[-1].rt
                    key_resp_27.duration = _key_resp_27_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_27.keys == str('left')) or (key_resp_27.keys == 'left'):
                        key_resp_27.corr = 1
                    else:
                        key_resp_27.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_3* updates
            
            # if arrow_u_3 is starting this frame...
            if arrow_u_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_3.frameNStart = frameN  # exact frame index
                arrow_u_3.tStart = t  # local t and not account for scr refresh
                arrow_u_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_3.started')
                # update status
                arrow_u_3.status = STARTED
                arrow_u_3.setAutoDraw(True)
            
            # if arrow_u_3 is active this frame...
            if arrow_u_3.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_9* updates
            
            # if up_whitesquare_9 is starting this frame...
            if up_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_9.frameNStart = frameN  # exact frame index
                up_whitesquare_9.tStart = t  # local t and not account for scr refresh
                up_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_9.started')
                # update status
                up_whitesquare_9.status = STARTED
                up_whitesquare_9.setAutoDraw(True)
            
            # if up_whitesquare_9 is active this frame...
            if up_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_9 is stopping this frame...
            if up_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_9.tStop = t  # not accounting for scr refresh
                    up_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_9.stopped')
                    # update status
                    up_whitesquare_9.status = FINISHED
                    up_whitesquare_9.setAutoDraw(False)
            
            # *down_whitesquare_9* updates
            
            # if down_whitesquare_9 is starting this frame...
            if down_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_9.frameNStart = frameN  # exact frame index
                down_whitesquare_9.tStart = t  # local t and not account for scr refresh
                down_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_9.started')
                # update status
                down_whitesquare_9.status = STARTED
                down_whitesquare_9.setAutoDraw(True)
            
            # if down_whitesquare_9 is active this frame...
            if down_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_9 is stopping this frame...
            if down_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_9.tStop = t  # not accounting for scr refresh
                    down_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_9.stopped')
                    # update status
                    down_whitesquare_9.status = FINISHED
                    down_whitesquare_9.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_down" ---
        for thisComponent in downA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_down
        downA_on_down.tStop = globalClock.getTime(format='float')
        downA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_down.stopped', downA_on_down.tStop)
        # check responses
        if key_resp_27.keys in ['', [], None]:  # No response was made
            key_resp_27.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_27.corr = 1;  # correct non-response
            else:
               key_resp_27.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_27.keys',key_resp_27.keys)
        trials_b4.addData('key_resp_27.corr', key_resp_27.corr)
        if key_resp_27.keys != None:  # we had a response
            trials_b4.addData('key_resp_27.rt', key_resp_27.rt)
            trials_b4.addData('key_resp_27.duration', key_resp_27.duration)
        # the Routine "downA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_up" ---
        # create an object to store info about Routine downA_on_up
        downA_on_up = data.Routine(
            name='downA_on_up',
            components=[blacksquare_25, white_cross_25, key_resp_28, arrow_u_4, up_whitesquare_5, down_whitesquare_5],
        )
        downA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_28
        key_resp_28.keys = []
        key_resp_28.rt = []
        _key_resp_28_allKeys = []
        # Run 'Begin Routine' code from code_17
        
        
        if currentRoutine != "downA_on_up":
            continueRoutine = False
        
        # store start times for downA_on_up
        downA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_up.tStart = globalClock.getTime(format='float')
        downA_on_up.status = STARTED
        thisExp.addData('downA_on_up.started', downA_on_up.tStart)
        downA_on_up.maxDuration = None
        # keep track of which components have finished
        downA_on_upComponents = downA_on_up.components
        for thisComponent in downA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b4, data.TrialHandler2) and thisTrials_b4.thisN != trials_b4.thisTrial.thisN:
            continueRoutine = False
        downA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_25* updates
            
            # if blacksquare_25 is starting this frame...
            if blacksquare_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_25.frameNStart = frameN  # exact frame index
                blacksquare_25.tStart = t  # local t and not account for scr refresh
                blacksquare_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_25.started')
                # update status
                blacksquare_25.status = STARTED
                blacksquare_25.setAutoDraw(True)
            
            # if blacksquare_25 is active this frame...
            if blacksquare_25.status == STARTED:
                # update params
                pass
            
            # *white_cross_25* updates
            
            # if white_cross_25 is starting this frame...
            if white_cross_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_25.frameNStart = frameN  # exact frame index
                white_cross_25.tStart = t  # local t and not account for scr refresh
                white_cross_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_25.started')
                # update status
                white_cross_25.status = STARTED
                white_cross_25.setAutoDraw(True)
            
            # if white_cross_25 is active this frame...
            if white_cross_25.status == STARTED:
                # update params
                pass
            
            # *key_resp_28* updates
            waitOnFlip = False
            
            # if key_resp_28 is starting this frame...
            if key_resp_28.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_28.frameNStart = frameN  # exact frame index
                key_resp_28.tStart = t  # local t and not account for scr refresh
                key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_28.started')
                # update status
                key_resp_28.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_28.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_28.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_28_allKeys.extend(theseKeys)
                if len(_key_resp_28_allKeys):
                    key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
                    key_resp_28.rt = _key_resp_28_allKeys[-1].rt
                    key_resp_28.duration = _key_resp_28_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_28.keys == str('left')) or (key_resp_28.keys == 'left'):
                        key_resp_28.corr = 1
                    else:
                        key_resp_28.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_4* updates
            
            # if arrow_u_4 is starting this frame...
            if arrow_u_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_4.frameNStart = frameN  # exact frame index
                arrow_u_4.tStart = t  # local t and not account for scr refresh
                arrow_u_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_4.started')
                # update status
                arrow_u_4.status = STARTED
                arrow_u_4.setAutoDraw(True)
            
            # if arrow_u_4 is active this frame...
            if arrow_u_4.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_5* updates
            
            # if up_whitesquare_5 is starting this frame...
            if up_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_5.frameNStart = frameN  # exact frame index
                up_whitesquare_5.tStart = t  # local t and not account for scr refresh
                up_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_5.started')
                # update status
                up_whitesquare_5.status = STARTED
                up_whitesquare_5.setAutoDraw(True)
            
            # if up_whitesquare_5 is active this frame...
            if up_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_5 is stopping this frame...
            if up_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_5.tStop = t  # not accounting for scr refresh
                    up_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_5.stopped')
                    # update status
                    up_whitesquare_5.status = FINISHED
                    up_whitesquare_5.setAutoDraw(False)
            
            # *down_whitesquare_5* updates
            
            # if down_whitesquare_5 is starting this frame...
            if down_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_5.frameNStart = frameN  # exact frame index
                down_whitesquare_5.tStart = t  # local t and not account for scr refresh
                down_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_5.started')
                # update status
                down_whitesquare_5.status = STARTED
                down_whitesquare_5.setAutoDraw(True)
            
            # if down_whitesquare_5 is active this frame...
            if down_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_5 is stopping this frame...
            if down_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_5.tStop = t  # not accounting for scr refresh
                    down_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_5.stopped')
                    # update status
                    down_whitesquare_5.status = FINISHED
                    down_whitesquare_5.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_up" ---
        for thisComponent in downA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_up
        downA_on_up.tStop = globalClock.getTime(format='float')
        downA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_up.stopped', downA_on_up.tStop)
        # check responses
        if key_resp_28.keys in ['', [], None]:  # No response was made
            key_resp_28.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_28.corr = 1;  # correct non-response
            else:
               key_resp_28.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b4 (TrialHandler)
        trials_b4.addData('key_resp_28.keys',key_resp_28.keys)
        trials_b4.addData('key_resp_28.corr', key_resp_28.corr)
        if key_resp_28.keys != None:  # we had a response
            trials_b4.addData('key_resp_28.rt', key_resp_28.rt)
            trials_b4.addData('key_resp_28.duration', key_resp_28.duration)
        # the Routine "downA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 32.0 repeats of 'trials_b4'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "end_block4" ---
    # create an object to store info about Routine end_block4
    end_block4 = data.Routine(
        name='end_block4',
        components=[text_33, text_34, key_resp_32],
    )
    end_block4.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_32
    key_resp_32.keys = []
    key_resp_32.rt = []
    _key_resp_32_allKeys = []
    # store start times for end_block4
    end_block4.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    end_block4.tStart = globalClock.getTime(format='float')
    end_block4.status = STARTED
    thisExp.addData('end_block4.started', end_block4.tStart)
    end_block4.maxDuration = None
    # keep track of which components have finished
    end_block4Components = end_block4.components
    for thisComponent in end_block4.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end_block4" ---
    end_block4.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_33* updates
        
        # if text_33 is starting this frame...
        if text_33.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_33.frameNStart = frameN  # exact frame index
            text_33.tStart = t  # local t and not account for scr refresh
            text_33.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_33, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_33.started')
            # update status
            text_33.status = STARTED
            text_33.setAutoDraw(True)
        
        # if text_33 is active this frame...
        if text_33.status == STARTED:
            # update params
            pass
        
        # *text_34* updates
        
        # if text_34 is starting this frame...
        if text_34.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_34.frameNStart = frameN  # exact frame index
            text_34.tStart = t  # local t and not account for scr refresh
            text_34.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_34, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_34.started')
            # update status
            text_34.status = STARTED
            text_34.setAutoDraw(True)
        
        # if text_34 is active this frame...
        if text_34.status == STARTED:
            # update params
            pass
        
        # *key_resp_32* updates
        waitOnFlip = False
        
        # if key_resp_32 is starting this frame...
        if key_resp_32.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_32.frameNStart = frameN  # exact frame index
            key_resp_32.tStart = t  # local t and not account for scr refresh
            key_resp_32.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_32, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_32.started')
            # update status
            key_resp_32.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_32.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_32.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_32.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_32.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_32_allKeys.extend(theseKeys)
            if len(_key_resp_32_allKeys):
                key_resp_32.keys = _key_resp_32_allKeys[-1].name  # just the last key pressed
                key_resp_32.rt = _key_resp_32_allKeys[-1].rt
                key_resp_32.duration = _key_resp_32_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            end_block4.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in end_block4.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end_block4" ---
    for thisComponent in end_block4.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for end_block4
    end_block4.tStop = globalClock.getTime(format='float')
    end_block4.tStopRefresh = tThisFlipGlobal
    thisExp.addData('end_block4.stopped', end_block4.tStop)
    # check responses
    if key_resp_32.keys in ['', [], None]:  # No response was made
        key_resp_32.keys = None
    thisExp.addData('key_resp_32.keys',key_resp_32.keys)
    if key_resp_32.keys != None:  # we had a response
        thisExp.addData('key_resp_32.rt', key_resp_32.rt)
        thisExp.addData('key_resp_32.duration', key_resp_32.duration)
    thisExp.nextEntry()
    # the Routine "end_block4" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "block5" ---
    # create an object to store info about Routine block5
    block5 = data.Routine(
        name='block5',
        components=[text_27],
    )
    block5.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for block5
    block5.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    block5.tStart = globalClock.getTime(format='float')
    block5.status = STARTED
    thisExp.addData('block5.started', block5.tStart)
    block5.maxDuration = None
    # keep track of which components have finished
    block5Components = block5.components
    for thisComponent in block5.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "block5" ---
    block5.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 2.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_27* updates
        
        # if text_27 is starting this frame...
        if text_27.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_27.frameNStart = frameN  # exact frame index
            text_27.tStart = t  # local t and not account for scr refresh
            text_27.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_27, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_27.started')
            # update status
            text_27.status = STARTED
            text_27.setAutoDraw(True)
        
        # if text_27 is active this frame...
        if text_27.status == STARTED:
            # update params
            pass
        
        # if text_27 is stopping this frame...
        if text_27.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_27.tStartRefresh + 2-frameTolerance:
                # keep track of stop time/frame for later
                text_27.tStop = t  # not accounting for scr refresh
                text_27.tStopRefresh = tThisFlipGlobal  # on global time
                text_27.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_27.stopped')
                # update status
                text_27.status = FINISHED
                text_27.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            block5.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in block5.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "block5" ---
    for thisComponent in block5.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for block5
    block5.tStop = globalClock.getTime(format='float')
    block5.tStopRefresh = tThisFlipGlobal
    thisExp.addData('block5.stopped', block5.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if block5.maxDurationReached:
        routineTimer.addTime(-block5.maxDuration)
    elif block5.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-2.000000)
    thisExp.nextEntry()
    
    # set up handler to look after randomisation of conditions etc
    trials_b5 = data.TrialHandler2(
        name='trials_b5',
        nReps=32.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(trials_b5)  # add the loop to the experiment
    thisTrials_b5 = trials_b5.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_b5.rgb)
    if thisTrials_b5 != None:
        for paramName in thisTrials_b5:
            globals()[paramName] = thisTrials_b5[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_b5 in trials_b5:
        currentLoop = trials_b5
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_b5.rgb)
        if thisTrials_b5 != None:
            for paramName in thisTrials_b5:
                globals()[paramName] = thisTrials_b5[paramName]
        
        # --- Prepare to start Routine "block5_router" ---
        # create an object to store info about Routine block5_router
        block5_router = data.Routine(
            name='block5_router',
            components=[],
        )
        block5_router.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_25
        currentRoutine = schedule[trial_index]
        
        
        # store start times for block5_router
        block5_router.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        block5_router.tStart = globalClock.getTime(format='float')
        block5_router.status = STARTED
        thisExp.addData('block5_router.started', block5_router.tStart)
        block5_router.maxDuration = None
        # keep track of which components have finished
        block5_routerComponents = block5_router.components
        for thisComponent in block5_router.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "block5_router" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        block5_router.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                block5_router.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in block5_router.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "block5_router" ---
        for thisComponent in block5_router.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for block5_router
        block5_router.tStop = globalClock.getTime(format='float')
        block5_router.tStopRefresh = tThisFlipGlobal
        thisExp.addData('block5_router.stopped', block5_router.tStop)
        # Run 'End Routine' code from code_25
        trial_index += 1
        
        # the Routine "block5_router" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_right" ---
        # create an object to store info about Routine LEFT_on_right
        LEFT_on_right = data.Routine(
            name='LEFT_on_right',
            components=[blacksquare_10, white_cross_10, key_resp_13, LEFT_2, whitesquare_3, whitesquare_4],
        )
        LEFT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_13
        key_resp_13.keys = []
        key_resp_13.rt = []
        _key_resp_13_allKeys = []
        # Run 'Begin Routine' code from code_6
        if currentRoutine != "LEFT_on_right":
            continueRoutine = False
        
        # store start times for LEFT_on_right
        LEFT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_right.tStart = globalClock.getTime(format='float')
        LEFT_on_right.status = STARTED
        thisExp.addData('LEFT_on_right.started', LEFT_on_right.tStart)
        LEFT_on_right.maxDuration = None
        # keep track of which components have finished
        LEFT_on_rightComponents = LEFT_on_right.components
        for thisComponent in LEFT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_10* updates
            
            # if blacksquare_10 is starting this frame...
            if blacksquare_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_10.frameNStart = frameN  # exact frame index
                blacksquare_10.tStart = t  # local t and not account for scr refresh
                blacksquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_10.started')
                # update status
                blacksquare_10.status = STARTED
                blacksquare_10.setAutoDraw(True)
            
            # if blacksquare_10 is active this frame...
            if blacksquare_10.status == STARTED:
                # update params
                pass
            
            # *white_cross_10* updates
            
            # if white_cross_10 is starting this frame...
            if white_cross_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                white_cross_10.frameNStart = frameN  # exact frame index
                white_cross_10.tStart = t  # local t and not account for scr refresh
                white_cross_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_10.started')
                # update status
                white_cross_10.status = STARTED
                white_cross_10.setAutoDraw(True)
            
            # if white_cross_10 is active this frame...
            if white_cross_10.status == STARTED:
                # update params
                pass
            
            # *key_resp_13* updates
            waitOnFlip = False
            
            # if key_resp_13 is starting this frame...
            if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_13.frameNStart = frameN  # exact frame index
                key_resp_13.tStart = t  # local t and not account for scr refresh
                key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_13.started')
                # update status
                key_resp_13.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_13.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_13.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_13_allKeys.extend(theseKeys)
                if len(_key_resp_13_allKeys):
                    key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
                    key_resp_13.rt = _key_resp_13_allKeys[-1].rt
                    key_resp_13.duration = _key_resp_13_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_13.keys == str('left')) or (key_resp_13.keys == 'left'):
                        key_resp_13.corr = 1
                    else:
                        key_resp_13.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_2* updates
            
            # if LEFT_2 is starting this frame...
            if LEFT_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_2.frameNStart = frameN  # exact frame index
                LEFT_2.tStart = t  # local t and not account for scr refresh
                LEFT_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_2.started')
                # update status
                LEFT_2.status = STARTED
                LEFT_2.setAutoDraw(True)
            
            # if LEFT_2 is active this frame...
            if LEFT_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_3* updates
            
            # if whitesquare_3 is starting this frame...
            if whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_3.frameNStart = frameN  # exact frame index
                whitesquare_3.tStart = t  # local t and not account for scr refresh
                whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_3.started')
                # update status
                whitesquare_3.status = STARTED
                whitesquare_3.setAutoDraw(True)
            
            # if whitesquare_3 is active this frame...
            if whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if whitesquare_3 is stopping this frame...
            if whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_3.tStop = t  # not accounting for scr refresh
                    whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_3.stopped')
                    # update status
                    whitesquare_3.status = FINISHED
                    whitesquare_3.setAutoDraw(False)
            
            # *whitesquare_4* updates
            
            # if whitesquare_4 is starting this frame...
            if whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_4.frameNStart = frameN  # exact frame index
                whitesquare_4.tStart = t  # local t and not account for scr refresh
                whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_4.started')
                # update status
                whitesquare_4.status = STARTED
                whitesquare_4.setAutoDraw(True)
            
            # if whitesquare_4 is active this frame...
            if whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if whitesquare_4 is stopping this frame...
            if whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_4.tStop = t  # not accounting for scr refresh
                    whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_4.stopped')
                    # update status
                    whitesquare_4.status = FINISHED
                    whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_right" ---
        for thisComponent in LEFT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_right
        LEFT_on_right.tStop = globalClock.getTime(format='float')
        LEFT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_right.stopped', LEFT_on_right.tStop)
        # check responses
        if key_resp_13.keys in ['', [], None]:  # No response was made
            key_resp_13.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_13.corr = 1;  # correct non-response
            else:
               key_resp_13.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_13.keys',key_resp_13.keys)
        trials_b5.addData('key_resp_13.corr', key_resp_13.corr)
        if key_resp_13.keys != None:  # we had a response
            trials_b5.addData('key_resp_13.rt', key_resp_13.rt)
            trials_b5.addData('key_resp_13.duration', key_resp_13.duration)
        # the Routine "LEFT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_right" ---
        # create an object to store info about Routine RIGHT_on_right
        RIGHT_on_right = data.Routine(
            name='RIGHT_on_right',
            components=[blacksquare_11, white_cross_11, key_resp_14, RIGHT_3, whitesquare_10, whitesquare_17],
        )
        RIGHT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_14
        key_resp_14.keys = []
        key_resp_14.rt = []
        _key_resp_14_allKeys = []
        # Run 'Begin Routine' code from code_12
        if currentRoutine != "RIGHT_on_right":
            continueRoutine = False
        
        # store start times for RIGHT_on_right
        RIGHT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_right.tStart = globalClock.getTime(format='float')
        RIGHT_on_right.status = STARTED
        thisExp.addData('RIGHT_on_right.started', RIGHT_on_right.tStart)
        RIGHT_on_right.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_rightComponents = RIGHT_on_right.components
        for thisComponent in RIGHT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_11* updates
            
            # if blacksquare_11 is starting this frame...
            if blacksquare_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_11.frameNStart = frameN  # exact frame index
                blacksquare_11.tStart = t  # local t and not account for scr refresh
                blacksquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_11.started')
                # update status
                blacksquare_11.status = STARTED
                blacksquare_11.setAutoDraw(True)
            
            # if blacksquare_11 is active this frame...
            if blacksquare_11.status == STARTED:
                # update params
                pass
            
            # *white_cross_11* updates
            
            # if white_cross_11 is starting this frame...
            if white_cross_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_11.frameNStart = frameN  # exact frame index
                white_cross_11.tStart = t  # local t and not account for scr refresh
                white_cross_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_11.started')
                # update status
                white_cross_11.status = STARTED
                white_cross_11.setAutoDraw(True)
            
            # if white_cross_11 is active this frame...
            if white_cross_11.status == STARTED:
                # update params
                pass
            
            # *key_resp_14* updates
            waitOnFlip = False
            
            # if key_resp_14 is starting this frame...
            if key_resp_14.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_14.frameNStart = frameN  # exact frame index
                key_resp_14.tStart = t  # local t and not account for scr refresh
                key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_14.started')
                # update status
                key_resp_14.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_14.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_14.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_14_allKeys.extend(theseKeys)
                if len(_key_resp_14_allKeys):
                    key_resp_14.keys = _key_resp_14_allKeys[-1].name  # just the last key pressed
                    key_resp_14.rt = _key_resp_14_allKeys[-1].rt
                    key_resp_14.duration = _key_resp_14_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_14.keys == str('left')) or (key_resp_14.keys == 'left'):
                        key_resp_14.corr = 1
                    else:
                        key_resp_14.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_3* updates
            
            # if RIGHT_3 is starting this frame...
            if RIGHT_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_3.frameNStart = frameN  # exact frame index
                RIGHT_3.tStart = t  # local t and not account for scr refresh
                RIGHT_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_3.started')
                # update status
                RIGHT_3.status = STARTED
                RIGHT_3.setAutoDraw(True)
            
            # if RIGHT_3 is active this frame...
            if RIGHT_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_10* updates
            
            # if whitesquare_10 is starting this frame...
            if whitesquare_10.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_10.frameNStart = frameN  # exact frame index
                whitesquare_10.tStart = t  # local t and not account for scr refresh
                whitesquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_10.started')
                # update status
                whitesquare_10.status = STARTED
                whitesquare_10.setAutoDraw(True)
            
            # if whitesquare_10 is active this frame...
            if whitesquare_10.status == STARTED:
                # update params
                pass
            
            # if whitesquare_10 is stopping this frame...
            if whitesquare_10.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_10.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_10.tStop = t  # not accounting for scr refresh
                    whitesquare_10.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_10.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_10.stopped')
                    # update status
                    whitesquare_10.status = FINISHED
                    whitesquare_10.setAutoDraw(False)
            
            # *whitesquare_17* updates
            
            # if whitesquare_17 is starting this frame...
            if whitesquare_17.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_17.frameNStart = frameN  # exact frame index
                whitesquare_17.tStart = t  # local t and not account for scr refresh
                whitesquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_17.started')
                # update status
                whitesquare_17.status = STARTED
                whitesquare_17.setAutoDraw(True)
            
            # if whitesquare_17 is active this frame...
            if whitesquare_17.status == STARTED:
                # update params
                pass
            
            # if whitesquare_17 is stopping this frame...
            if whitesquare_17.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_17.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_17.tStop = t  # not accounting for scr refresh
                    whitesquare_17.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_17.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_17.stopped')
                    # update status
                    whitesquare_17.status = FINISHED
                    whitesquare_17.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_right" ---
        for thisComponent in RIGHT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_right
        RIGHT_on_right.tStop = globalClock.getTime(format='float')
        RIGHT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_right.stopped', RIGHT_on_right.tStop)
        # check responses
        if key_resp_14.keys in ['', [], None]:  # No response was made
            key_resp_14.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_14.corr = 1;  # correct non-response
            else:
               key_resp_14.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_14.keys',key_resp_14.keys)
        trials_b5.addData('key_resp_14.corr', key_resp_14.corr)
        if key_resp_14.keys != None:  # we had a response
            trials_b5.addData('key_resp_14.rt', key_resp_14.rt)
            trials_b5.addData('key_resp_14.duration', key_resp_14.duration)
        # the Routine "RIGHT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_left" ---
        # create an object to store info about Routine LEFT_on_left
        LEFT_on_left = data.Routine(
            name='LEFT_on_left',
            components=[blacksquare_12, white_cross_12, key_resp_15, LEFT_4, whitesquare_6, whitesquare_13],
        )
        LEFT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_15
        key_resp_15.keys = []
        key_resp_15.rt = []
        _key_resp_15_allKeys = []
        # Run 'Begin Routine' code from code_8
        
        
        if currentRoutine != "LEFT_on_left":
            continueRoutine = False
        
        # store start times for LEFT_on_left
        LEFT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_left.tStart = globalClock.getTime(format='float')
        LEFT_on_left.status = STARTED
        thisExp.addData('LEFT_on_left.started', LEFT_on_left.tStart)
        LEFT_on_left.maxDuration = None
        # keep track of which components have finished
        LEFT_on_leftComponents = LEFT_on_left.components
        for thisComponent in LEFT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_12* updates
            
            # if blacksquare_12 is starting this frame...
            if blacksquare_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_12.frameNStart = frameN  # exact frame index
                blacksquare_12.tStart = t  # local t and not account for scr refresh
                blacksquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_12.started')
                # update status
                blacksquare_12.status = STARTED
                blacksquare_12.setAutoDraw(True)
            
            # if blacksquare_12 is active this frame...
            if blacksquare_12.status == STARTED:
                # update params
                pass
            
            # *white_cross_12* updates
            
            # if white_cross_12 is starting this frame...
            if white_cross_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_12.frameNStart = frameN  # exact frame index
                white_cross_12.tStart = t  # local t and not account for scr refresh
                white_cross_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_12.started')
                # update status
                white_cross_12.status = STARTED
                white_cross_12.setAutoDraw(True)
            
            # if white_cross_12 is active this frame...
            if white_cross_12.status == STARTED:
                # update params
                pass
            
            # *key_resp_15* updates
            waitOnFlip = False
            
            # if key_resp_15 is starting this frame...
            if key_resp_15.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_15.frameNStart = frameN  # exact frame index
                key_resp_15.tStart = t  # local t and not account for scr refresh
                key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_15.started')
                # update status
                key_resp_15.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_15.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_15.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_15_allKeys.extend(theseKeys)
                if len(_key_resp_15_allKeys):
                    key_resp_15.keys = _key_resp_15_allKeys[-1].name  # just the last key pressed
                    key_resp_15.rt = _key_resp_15_allKeys[-1].rt
                    key_resp_15.duration = _key_resp_15_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_15.keys == str('left')) or (key_resp_15.keys == 'left'):
                        key_resp_15.corr = 1
                    else:
                        key_resp_15.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_4* updates
            
            # if LEFT_4 is starting this frame...
            if LEFT_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_4.frameNStart = frameN  # exact frame index
                LEFT_4.tStart = t  # local t and not account for scr refresh
                LEFT_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_4.started')
                # update status
                LEFT_4.status = STARTED
                LEFT_4.setAutoDraw(True)
            
            # if LEFT_4 is active this frame...
            if LEFT_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_6* updates
            
            # if whitesquare_6 is starting this frame...
            if whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_6.frameNStart = frameN  # exact frame index
                whitesquare_6.tStart = t  # local t and not account for scr refresh
                whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_6.started')
                # update status
                whitesquare_6.status = STARTED
                whitesquare_6.setAutoDraw(True)
            
            # if whitesquare_6 is active this frame...
            if whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if whitesquare_6 is stopping this frame...
            if whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_6.tStop = t  # not accounting for scr refresh
                    whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_6.stopped')
                    # update status
                    whitesquare_6.status = FINISHED
                    whitesquare_6.setAutoDraw(False)
            
            # *whitesquare_13* updates
            
            # if whitesquare_13 is starting this frame...
            if whitesquare_13.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_13.frameNStart = frameN  # exact frame index
                whitesquare_13.tStart = t  # local t and not account for scr refresh
                whitesquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_13.started')
                # update status
                whitesquare_13.status = STARTED
                whitesquare_13.setAutoDraw(True)
            
            # if whitesquare_13 is active this frame...
            if whitesquare_13.status == STARTED:
                # update params
                pass
            
            # if whitesquare_13 is stopping this frame...
            if whitesquare_13.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_13.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_13.tStop = t  # not accounting for scr refresh
                    whitesquare_13.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_13.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_13.stopped')
                    # update status
                    whitesquare_13.status = FINISHED
                    whitesquare_13.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_left" ---
        for thisComponent in LEFT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_left
        LEFT_on_left.tStop = globalClock.getTime(format='float')
        LEFT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_left.stopped', LEFT_on_left.tStop)
        # check responses
        if key_resp_15.keys in ['', [], None]:  # No response was made
            key_resp_15.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_15.corr = 1;  # correct non-response
            else:
               key_resp_15.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_15.keys',key_resp_15.keys)
        trials_b5.addData('key_resp_15.corr', key_resp_15.corr)
        if key_resp_15.keys != None:  # we had a response
            trials_b5.addData('key_resp_15.rt', key_resp_15.rt)
            trials_b5.addData('key_resp_15.duration', key_resp_15.duration)
        # the Routine "LEFT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_left" ---
        # create an object to store info about Routine RIGHT_on_left
        RIGHT_on_left = data.Routine(
            name='RIGHT_on_left',
            components=[blacksquare_13, white_cross_13, key_resp_16, RIGHT_5, whitesquare_8, whitesquare_15],
        )
        RIGHT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_16
        key_resp_16.keys = []
        key_resp_16.rt = []
        _key_resp_16_allKeys = []
        # Run 'Begin Routine' code from code_10
        
        if currentRoutine != "RIGHT_on_left":
            continueRoutine = False
        
        # store start times for RIGHT_on_left
        RIGHT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_left.tStart = globalClock.getTime(format='float')
        RIGHT_on_left.status = STARTED
        thisExp.addData('RIGHT_on_left.started', RIGHT_on_left.tStart)
        RIGHT_on_left.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_leftComponents = RIGHT_on_left.components
        for thisComponent in RIGHT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_13* updates
            
            # if blacksquare_13 is starting this frame...
            if blacksquare_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_13.frameNStart = frameN  # exact frame index
                blacksquare_13.tStart = t  # local t and not account for scr refresh
                blacksquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_13.started')
                # update status
                blacksquare_13.status = STARTED
                blacksquare_13.setAutoDraw(True)
            
            # if blacksquare_13 is active this frame...
            if blacksquare_13.status == STARTED:
                # update params
                pass
            
            # *white_cross_13* updates
            
            # if white_cross_13 is starting this frame...
            if white_cross_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_13.frameNStart = frameN  # exact frame index
                white_cross_13.tStart = t  # local t and not account for scr refresh
                white_cross_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_13.started')
                # update status
                white_cross_13.status = STARTED
                white_cross_13.setAutoDraw(True)
            
            # if white_cross_13 is active this frame...
            if white_cross_13.status == STARTED:
                # update params
                pass
            
            # *key_resp_16* updates
            waitOnFlip = False
            
            # if key_resp_16 is starting this frame...
            if key_resp_16.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_16.frameNStart = frameN  # exact frame index
                key_resp_16.tStart = t  # local t and not account for scr refresh
                key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_16.started')
                # update status
                key_resp_16.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_16.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_16.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_16_allKeys.extend(theseKeys)
                if len(_key_resp_16_allKeys):
                    key_resp_16.keys = _key_resp_16_allKeys[-1].name  # just the last key pressed
                    key_resp_16.rt = _key_resp_16_allKeys[-1].rt
                    key_resp_16.duration = _key_resp_16_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_16.keys == str('left')) or (key_resp_16.keys == 'left'):
                        key_resp_16.corr = 1
                    else:
                        key_resp_16.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_5* updates
            
            # if RIGHT_5 is starting this frame...
            if RIGHT_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_5.frameNStart = frameN  # exact frame index
                RIGHT_5.tStart = t  # local t and not account for scr refresh
                RIGHT_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_5.started')
                # update status
                RIGHT_5.status = STARTED
                RIGHT_5.setAutoDraw(True)
            
            # if RIGHT_5 is active this frame...
            if RIGHT_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_8* updates
            
            # if whitesquare_8 is starting this frame...
            if whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_8.frameNStart = frameN  # exact frame index
                whitesquare_8.tStart = t  # local t and not account for scr refresh
                whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_8.started')
                # update status
                whitesquare_8.status = STARTED
                whitesquare_8.setAutoDraw(True)
            
            # if whitesquare_8 is active this frame...
            if whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if whitesquare_8 is stopping this frame...
            if whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_8.tStop = t  # not accounting for scr refresh
                    whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_8.stopped')
                    # update status
                    whitesquare_8.status = FINISHED
                    whitesquare_8.setAutoDraw(False)
            
            # *whitesquare_15* updates
            
            # if whitesquare_15 is starting this frame...
            if whitesquare_15.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_15.frameNStart = frameN  # exact frame index
                whitesquare_15.tStart = t  # local t and not account for scr refresh
                whitesquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_15.started')
                # update status
                whitesquare_15.status = STARTED
                whitesquare_15.setAutoDraw(True)
            
            # if whitesquare_15 is active this frame...
            if whitesquare_15.status == STARTED:
                # update params
                pass
            
            # if whitesquare_15 is stopping this frame...
            if whitesquare_15.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_15.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_15.tStop = t  # not accounting for scr refresh
                    whitesquare_15.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_15.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_15.stopped')
                    # update status
                    whitesquare_15.status = FINISHED
                    whitesquare_15.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_left" ---
        for thisComponent in RIGHT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_left
        RIGHT_on_left.tStop = globalClock.getTime(format='float')
        RIGHT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_left.stopped', RIGHT_on_left.tStop)
        # check responses
        if key_resp_16.keys in ['', [], None]:  # No response was made
            key_resp_16.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_16.corr = 1;  # correct non-response
            else:
               key_resp_16.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_16.keys',key_resp_16.keys)
        trials_b5.addData('key_resp_16.corr', key_resp_16.corr)
        if key_resp_16.keys != None:  # we had a response
            trials_b5.addData('key_resp_16.rt', key_resp_16.rt)
            trials_b5.addData('key_resp_16.duration', key_resp_16.duration)
        # the Routine "RIGHT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_up" ---
        # create an object to store info about Routine UP_on_up
        UP_on_up = data.Routine(
            name='UP_on_up',
            components=[blacksquare_14, white_cross_14, key_resp_17, UP_5, up_whitesquare_2, down_whitesquare_2],
        )
        UP_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_17
        key_resp_17.keys = []
        key_resp_17.rt = []
        _key_resp_17_allKeys = []
        # Run 'Begin Routine' code from code_14
        
        if currentRoutine != "UP_on_up":
            continueRoutine = False
        
        # store start times for UP_on_up
        UP_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_up.tStart = globalClock.getTime(format='float')
        UP_on_up.status = STARTED
        thisExp.addData('UP_on_up.started', UP_on_up.tStart)
        UP_on_up.maxDuration = None
        # keep track of which components have finished
        UP_on_upComponents = UP_on_up.components
        for thisComponent in UP_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        UP_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_14* updates
            
            # if blacksquare_14 is starting this frame...
            if blacksquare_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_14.frameNStart = frameN  # exact frame index
                blacksquare_14.tStart = t  # local t and not account for scr refresh
                blacksquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_14.started')
                # update status
                blacksquare_14.status = STARTED
                blacksquare_14.setAutoDraw(True)
            
            # if blacksquare_14 is active this frame...
            if blacksquare_14.status == STARTED:
                # update params
                pass
            
            # *white_cross_14* updates
            
            # if white_cross_14 is starting this frame...
            if white_cross_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_14.frameNStart = frameN  # exact frame index
                white_cross_14.tStart = t  # local t and not account for scr refresh
                white_cross_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_14.started')
                # update status
                white_cross_14.status = STARTED
                white_cross_14.setAutoDraw(True)
            
            # if white_cross_14 is active this frame...
            if white_cross_14.status == STARTED:
                # update params
                pass
            
            # *key_resp_17* updates
            waitOnFlip = False
            
            # if key_resp_17 is starting this frame...
            if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_17.frameNStart = frameN  # exact frame index
                key_resp_17.tStart = t  # local t and not account for scr refresh
                key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_17.started')
                # update status
                key_resp_17.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_17.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_17.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_17_allKeys.extend(theseKeys)
                if len(_key_resp_17_allKeys):
                    key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
                    key_resp_17.rt = _key_resp_17_allKeys[-1].rt
                    key_resp_17.duration = _key_resp_17_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_17.keys == str('left')) or (key_resp_17.keys == 'left'):
                        key_resp_17.corr = 1
                    else:
                        key_resp_17.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_5* updates
            
            # if UP_5 is starting this frame...
            if UP_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_5.frameNStart = frameN  # exact frame index
                UP_5.tStart = t  # local t and not account for scr refresh
                UP_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_5.started')
                # update status
                UP_5.status = STARTED
                UP_5.setAutoDraw(True)
            
            # if UP_5 is active this frame...
            if UP_5.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_2* updates
            
            # if up_whitesquare_2 is starting this frame...
            if up_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_2.frameNStart = frameN  # exact frame index
                up_whitesquare_2.tStart = t  # local t and not account for scr refresh
                up_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_2.started')
                # update status
                up_whitesquare_2.status = STARTED
                up_whitesquare_2.setAutoDraw(True)
            
            # if up_whitesquare_2 is active this frame...
            if up_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_2 is stopping this frame...
            if up_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_2.tStop = t  # not accounting for scr refresh
                    up_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_2.stopped')
                    # update status
                    up_whitesquare_2.status = FINISHED
                    up_whitesquare_2.setAutoDraw(False)
            
            # *down_whitesquare_2* updates
            
            # if down_whitesquare_2 is starting this frame...
            if down_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_2.frameNStart = frameN  # exact frame index
                down_whitesquare_2.tStart = t  # local t and not account for scr refresh
                down_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_2.started')
                # update status
                down_whitesquare_2.status = STARTED
                down_whitesquare_2.setAutoDraw(True)
            
            # if down_whitesquare_2 is active this frame...
            if down_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_2 is stopping this frame...
            if down_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_2.tStop = t  # not accounting for scr refresh
                    down_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_2.stopped')
                    # update status
                    down_whitesquare_2.status = FINISHED
                    down_whitesquare_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_up" ---
        for thisComponent in UP_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_up
        UP_on_up.tStop = globalClock.getTime(format='float')
        UP_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_up.stopped', UP_on_up.tStop)
        # check responses
        if key_resp_17.keys in ['', [], None]:  # No response was made
            key_resp_17.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_17.corr = 1;  # correct non-response
            else:
               key_resp_17.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_17.keys',key_resp_17.keys)
        trials_b5.addData('key_resp_17.corr', key_resp_17.corr)
        if key_resp_17.keys != None:  # we had a response
            trials_b5.addData('key_resp_17.rt', key_resp_17.rt)
            trials_b5.addData('key_resp_17.duration', key_resp_17.duration)
        # the Routine "UP_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_up" ---
        # create an object to store info about Routine DOWN_on_up
        DOWN_on_up = data.Routine(
            name='DOWN_on_up',
            components=[blacksquare_15, white_cross_15, key_resp_18, UP, up_whitesquare_4, down_whitesquare_4],
        )
        DOWN_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_18
        key_resp_18.keys = []
        key_resp_18.rt = []
        _key_resp_18_allKeys = []
        # Run 'Begin Routine' code from code_16
        
        
        if currentRoutine != "DOWN_on_up":
            continueRoutine = False
        
        # store start times for DOWN_on_up
        DOWN_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_up.tStart = globalClock.getTime(format='float')
        DOWN_on_up.status = STARTED
        thisExp.addData('DOWN_on_up.started', DOWN_on_up.tStart)
        DOWN_on_up.maxDuration = None
        # keep track of which components have finished
        DOWN_on_upComponents = DOWN_on_up.components
        for thisComponent in DOWN_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_15* updates
            
            # if blacksquare_15 is starting this frame...
            if blacksquare_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_15.frameNStart = frameN  # exact frame index
                blacksquare_15.tStart = t  # local t and not account for scr refresh
                blacksquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_15.started')
                # update status
                blacksquare_15.status = STARTED
                blacksquare_15.setAutoDraw(True)
            
            # if blacksquare_15 is active this frame...
            if blacksquare_15.status == STARTED:
                # update params
                pass
            
            # *white_cross_15* updates
            
            # if white_cross_15 is starting this frame...
            if white_cross_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_15.frameNStart = frameN  # exact frame index
                white_cross_15.tStart = t  # local t and not account for scr refresh
                white_cross_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_15.started')
                # update status
                white_cross_15.status = STARTED
                white_cross_15.setAutoDraw(True)
            
            # if white_cross_15 is active this frame...
            if white_cross_15.status == STARTED:
                # update params
                pass
            
            # *key_resp_18* updates
            waitOnFlip = False
            
            # if key_resp_18 is starting this frame...
            if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_18.frameNStart = frameN  # exact frame index
                key_resp_18.tStart = t  # local t and not account for scr refresh
                key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_18.started')
                # update status
                key_resp_18.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_18.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_18.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_18_allKeys.extend(theseKeys)
                if len(_key_resp_18_allKeys):
                    key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
                    key_resp_18.rt = _key_resp_18_allKeys[-1].rt
                    key_resp_18.duration = _key_resp_18_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_18.keys == str('left')) or (key_resp_18.keys == 'left'):
                        key_resp_18.corr = 1
                    else:
                        key_resp_18.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP* updates
            
            # if UP is starting this frame...
            if UP.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP.frameNStart = frameN  # exact frame index
                UP.tStart = t  # local t and not account for scr refresh
                UP.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP.started')
                # update status
                UP.status = STARTED
                UP.setAutoDraw(True)
            
            # if UP is active this frame...
            if UP.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_4* updates
            
            # if up_whitesquare_4 is starting this frame...
            if up_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_4.frameNStart = frameN  # exact frame index
                up_whitesquare_4.tStart = t  # local t and not account for scr refresh
                up_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_4.started')
                # update status
                up_whitesquare_4.status = STARTED
                up_whitesquare_4.setAutoDraw(True)
            
            # if up_whitesquare_4 is active this frame...
            if up_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_4 is stopping this frame...
            if up_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_4.tStop = t  # not accounting for scr refresh
                    up_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_4.stopped')
                    # update status
                    up_whitesquare_4.status = FINISHED
                    up_whitesquare_4.setAutoDraw(False)
            
            # *down_whitesquare_4* updates
            
            # if down_whitesquare_4 is starting this frame...
            if down_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_4.frameNStart = frameN  # exact frame index
                down_whitesquare_4.tStart = t  # local t and not account for scr refresh
                down_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_4.started')
                # update status
                down_whitesquare_4.status = STARTED
                down_whitesquare_4.setAutoDraw(True)
            
            # if down_whitesquare_4 is active this frame...
            if down_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_4 is stopping this frame...
            if down_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_4.tStop = t  # not accounting for scr refresh
                    down_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_4.stopped')
                    # update status
                    down_whitesquare_4.status = FINISHED
                    down_whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_up" ---
        for thisComponent in DOWN_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_up
        DOWN_on_up.tStop = globalClock.getTime(format='float')
        DOWN_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_up.stopped', DOWN_on_up.tStop)
        # check responses
        if key_resp_18.keys in ['', [], None]:  # No response was made
            key_resp_18.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_18.corr = 1;  # correct non-response
            else:
               key_resp_18.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_18.keys',key_resp_18.keys)
        trials_b5.addData('key_resp_18.corr', key_resp_18.corr)
        if key_resp_18.keys != None:  # we had a response
            trials_b5.addData('key_resp_18.rt', key_resp_18.rt)
            trials_b5.addData('key_resp_18.duration', key_resp_18.duration)
        # the Routine "DOWN_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_down" ---
        # create an object to store info about Routine UP_on_down
        UP_on_down = data.Routine(
            name='UP_on_down',
            components=[blacksquare_16, white_cross_16, key_resp_19, UP_6, up_whitesquare_6, down_whitesquare_6],
        )
        UP_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_19
        key_resp_19.keys = []
        key_resp_19.rt = []
        _key_resp_19_allKeys = []
        # Run 'Begin Routine' code from code_18
        
        
        if currentRoutine != "UP_on_down":
            continueRoutine = False
        
        # store start times for UP_on_down
        UP_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_down.tStart = globalClock.getTime(format='float')
        UP_on_down.status = STARTED
        thisExp.addData('UP_on_down.started', UP_on_down.tStart)
        UP_on_down.maxDuration = None
        # keep track of which components have finished
        UP_on_downComponents = UP_on_down.components
        for thisComponent in UP_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        UP_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_16* updates
            
            # if blacksquare_16 is starting this frame...
            if blacksquare_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_16.frameNStart = frameN  # exact frame index
                blacksquare_16.tStart = t  # local t and not account for scr refresh
                blacksquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_16.started')
                # update status
                blacksquare_16.status = STARTED
                blacksquare_16.setAutoDraw(True)
            
            # if blacksquare_16 is active this frame...
            if blacksquare_16.status == STARTED:
                # update params
                pass
            
            # *white_cross_16* updates
            
            # if white_cross_16 is starting this frame...
            if white_cross_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_16.frameNStart = frameN  # exact frame index
                white_cross_16.tStart = t  # local t and not account for scr refresh
                white_cross_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_16.started')
                # update status
                white_cross_16.status = STARTED
                white_cross_16.setAutoDraw(True)
            
            # if white_cross_16 is active this frame...
            if white_cross_16.status == STARTED:
                # update params
                pass
            
            # *key_resp_19* updates
            waitOnFlip = False
            
            # if key_resp_19 is starting this frame...
            if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_19.frameNStart = frameN  # exact frame index
                key_resp_19.tStart = t  # local t and not account for scr refresh
                key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_19.started')
                # update status
                key_resp_19.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_19.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_19.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_19_allKeys.extend(theseKeys)
                if len(_key_resp_19_allKeys):
                    key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
                    key_resp_19.rt = _key_resp_19_allKeys[-1].rt
                    key_resp_19.duration = _key_resp_19_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_19.keys == str('left')) or (key_resp_19.keys == 'left'):
                        key_resp_19.corr = 1
                    else:
                        key_resp_19.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_6* updates
            
            # if UP_6 is starting this frame...
            if UP_6.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_6.frameNStart = frameN  # exact frame index
                UP_6.tStart = t  # local t and not account for scr refresh
                UP_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_6.started')
                # update status
                UP_6.status = STARTED
                UP_6.setAutoDraw(True)
            
            # if UP_6 is active this frame...
            if UP_6.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_6* updates
            
            # if up_whitesquare_6 is starting this frame...
            if up_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_6.frameNStart = frameN  # exact frame index
                up_whitesquare_6.tStart = t  # local t and not account for scr refresh
                up_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_6.started')
                # update status
                up_whitesquare_6.status = STARTED
                up_whitesquare_6.setAutoDraw(True)
            
            # if up_whitesquare_6 is active this frame...
            if up_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_6 is stopping this frame...
            if up_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_6.tStop = t  # not accounting for scr refresh
                    up_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_6.stopped')
                    # update status
                    up_whitesquare_6.status = FINISHED
                    up_whitesquare_6.setAutoDraw(False)
            
            # *down_whitesquare_6* updates
            
            # if down_whitesquare_6 is starting this frame...
            if down_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_6.frameNStart = frameN  # exact frame index
                down_whitesquare_6.tStart = t  # local t and not account for scr refresh
                down_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_6.started')
                # update status
                down_whitesquare_6.status = STARTED
                down_whitesquare_6.setAutoDraw(True)
            
            # if down_whitesquare_6 is active this frame...
            if down_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_6 is stopping this frame...
            if down_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_6.tStop = t  # not accounting for scr refresh
                    down_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_6.stopped')
                    # update status
                    down_whitesquare_6.status = FINISHED
                    down_whitesquare_6.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_down" ---
        for thisComponent in UP_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_down
        UP_on_down.tStop = globalClock.getTime(format='float')
        UP_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_down.stopped', UP_on_down.tStop)
        # check responses
        if key_resp_19.keys in ['', [], None]:  # No response was made
            key_resp_19.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_19.corr = 1;  # correct non-response
            else:
               key_resp_19.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_19.keys',key_resp_19.keys)
        trials_b5.addData('key_resp_19.corr', key_resp_19.corr)
        if key_resp_19.keys != None:  # we had a response
            trials_b5.addData('key_resp_19.rt', key_resp_19.rt)
            trials_b5.addData('key_resp_19.duration', key_resp_19.duration)
        # the Routine "UP_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_down" ---
        # create an object to store info about Routine DOWN_on_down
        DOWN_on_down = data.Routine(
            name='DOWN_on_down',
            components=[blacksquare_17, white_cross_17, key_resp_20, UP_7, up_whitesquare_8, down_whitesquare_8],
        )
        DOWN_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_20
        key_resp_20.keys = []
        key_resp_20.rt = []
        _key_resp_20_allKeys = []
        # Run 'Begin Routine' code from code_20
        
        
        if currentRoutine != "DOWN_on_down":
            continueRoutine = False
        
        # store start times for DOWN_on_down
        DOWN_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_down.tStart = globalClock.getTime(format='float')
        DOWN_on_down.status = STARTED
        thisExp.addData('DOWN_on_down.started', DOWN_on_down.tStart)
        DOWN_on_down.maxDuration = None
        # keep track of which components have finished
        DOWN_on_downComponents = DOWN_on_down.components
        for thisComponent in DOWN_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_17* updates
            
            # if blacksquare_17 is starting this frame...
            if blacksquare_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_17.frameNStart = frameN  # exact frame index
                blacksquare_17.tStart = t  # local t and not account for scr refresh
                blacksquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_17.started')
                # update status
                blacksquare_17.status = STARTED
                blacksquare_17.setAutoDraw(True)
            
            # if blacksquare_17 is active this frame...
            if blacksquare_17.status == STARTED:
                # update params
                pass
            
            # *white_cross_17* updates
            
            # if white_cross_17 is starting this frame...
            if white_cross_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_17.frameNStart = frameN  # exact frame index
                white_cross_17.tStart = t  # local t and not account for scr refresh
                white_cross_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_17.started')
                # update status
                white_cross_17.status = STARTED
                white_cross_17.setAutoDraw(True)
            
            # if white_cross_17 is active this frame...
            if white_cross_17.status == STARTED:
                # update params
                pass
            
            # *key_resp_20* updates
            waitOnFlip = False
            
            # if key_resp_20 is starting this frame...
            if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_20.frameNStart = frameN  # exact frame index
                key_resp_20.tStart = t  # local t and not account for scr refresh
                key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_20.started')
                # update status
                key_resp_20.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_20.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_20.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_20_allKeys.extend(theseKeys)
                if len(_key_resp_20_allKeys):
                    key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
                    key_resp_20.rt = _key_resp_20_allKeys[-1].rt
                    key_resp_20.duration = _key_resp_20_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_20.keys == str('left')) or (key_resp_20.keys == 'left'):
                        key_resp_20.corr = 1
                    else:
                        key_resp_20.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_7* updates
            
            # if UP_7 is starting this frame...
            if UP_7.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_7.frameNStart = frameN  # exact frame index
                UP_7.tStart = t  # local t and not account for scr refresh
                UP_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_7.started')
                # update status
                UP_7.status = STARTED
                UP_7.setAutoDraw(True)
            
            # if UP_7 is active this frame...
            if UP_7.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_8* updates
            
            # if up_whitesquare_8 is starting this frame...
            if up_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_8.frameNStart = frameN  # exact frame index
                up_whitesquare_8.tStart = t  # local t and not account for scr refresh
                up_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_8.started')
                # update status
                up_whitesquare_8.status = STARTED
                up_whitesquare_8.setAutoDraw(True)
            
            # if up_whitesquare_8 is active this frame...
            if up_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_8 is stopping this frame...
            if up_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_8.tStop = t  # not accounting for scr refresh
                    up_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_8.stopped')
                    # update status
                    up_whitesquare_8.status = FINISHED
                    up_whitesquare_8.setAutoDraw(False)
            
            # *down_whitesquare_8* updates
            
            # if down_whitesquare_8 is starting this frame...
            if down_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_8.frameNStart = frameN  # exact frame index
                down_whitesquare_8.tStart = t  # local t and not account for scr refresh
                down_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_8.started')
                # update status
                down_whitesquare_8.status = STARTED
                down_whitesquare_8.setAutoDraw(True)
            
            # if down_whitesquare_8 is active this frame...
            if down_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_8 is stopping this frame...
            if down_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_8.tStop = t  # not accounting for scr refresh
                    down_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_8.stopped')
                    # update status
                    down_whitesquare_8.status = FINISHED
                    down_whitesquare_8.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_down" ---
        for thisComponent in DOWN_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_down
        DOWN_on_down.tStop = globalClock.getTime(format='float')
        DOWN_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_down.stopped', DOWN_on_down.tStop)
        # check responses
        if key_resp_20.keys in ['', [], None]:  # No response was made
            key_resp_20.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_20.corr = 1;  # correct non-response
            else:
               key_resp_20.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_20.keys',key_resp_20.keys)
        trials_b5.addData('key_resp_20.corr', key_resp_20.corr)
        if key_resp_20.keys != None:  # we had a response
            trials_b5.addData('key_resp_20.rt', key_resp_20.rt)
            trials_b5.addData('key_resp_20.duration', key_resp_20.duration)
        # the Routine "DOWN_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_right" ---
        # create an object to store info about Routine leftA_on_right
        leftA_on_right = data.Routine(
            name='leftA_on_right',
            components=[blacksquare_18, white_cross_18, key_resp_21, arrow_l_2, whitesquare_5, whitesquare_12],
        )
        leftA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_21
        key_resp_21.keys = []
        key_resp_21.rt = []
        _key_resp_21_allKeys = []
        # Run 'Begin Routine' code from code_7
        
        
        if currentRoutine != "leftA_on_right":
            continueRoutine = False
        
        # store start times for leftA_on_right
        leftA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_right.tStart = globalClock.getTime(format='float')
        leftA_on_right.status = STARTED
        thisExp.addData('leftA_on_right.started', leftA_on_right.tStart)
        leftA_on_right.maxDuration = None
        # keep track of which components have finished
        leftA_on_rightComponents = leftA_on_right.components
        for thisComponent in leftA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        leftA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_18* updates
            
            # if blacksquare_18 is starting this frame...
            if blacksquare_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_18.frameNStart = frameN  # exact frame index
                blacksquare_18.tStart = t  # local t and not account for scr refresh
                blacksquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_18.started')
                # update status
                blacksquare_18.status = STARTED
                blacksquare_18.setAutoDraw(True)
            
            # if blacksquare_18 is active this frame...
            if blacksquare_18.status == STARTED:
                # update params
                pass
            
            # *white_cross_18* updates
            
            # if white_cross_18 is starting this frame...
            if white_cross_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_18.frameNStart = frameN  # exact frame index
                white_cross_18.tStart = t  # local t and not account for scr refresh
                white_cross_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_18.started')
                # update status
                white_cross_18.status = STARTED
                white_cross_18.setAutoDraw(True)
            
            # if white_cross_18 is active this frame...
            if white_cross_18.status == STARTED:
                # update params
                pass
            
            # *key_resp_21* updates
            waitOnFlip = False
            
            # if key_resp_21 is starting this frame...
            if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_21.frameNStart = frameN  # exact frame index
                key_resp_21.tStart = t  # local t and not account for scr refresh
                key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_21.started')
                # update status
                key_resp_21.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_21.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_21.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_21_allKeys.extend(theseKeys)
                if len(_key_resp_21_allKeys):
                    key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
                    key_resp_21.rt = _key_resp_21_allKeys[-1].rt
                    key_resp_21.duration = _key_resp_21_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_21.keys == str('left')) or (key_resp_21.keys == 'left'):
                        key_resp_21.corr = 1
                    else:
                        key_resp_21.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_2* updates
            
            # if arrow_l_2 is starting this frame...
            if arrow_l_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_2.frameNStart = frameN  # exact frame index
                arrow_l_2.tStart = t  # local t and not account for scr refresh
                arrow_l_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_2.started')
                # update status
                arrow_l_2.status = STARTED
                arrow_l_2.setAutoDraw(True)
            
            # if arrow_l_2 is active this frame...
            if arrow_l_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_5* updates
            
            # if whitesquare_5 is starting this frame...
            if whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_5.frameNStart = frameN  # exact frame index
                whitesquare_5.tStart = t  # local t and not account for scr refresh
                whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_5.started')
                # update status
                whitesquare_5.status = STARTED
                whitesquare_5.setAutoDraw(True)
            
            # if whitesquare_5 is active this frame...
            if whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if whitesquare_5 is stopping this frame...
            if whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_5.tStop = t  # not accounting for scr refresh
                    whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_5.stopped')
                    # update status
                    whitesquare_5.status = FINISHED
                    whitesquare_5.setAutoDraw(False)
            
            # *whitesquare_12* updates
            
            # if whitesquare_12 is starting this frame...
            if whitesquare_12.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_12.frameNStart = frameN  # exact frame index
                whitesquare_12.tStart = t  # local t and not account for scr refresh
                whitesquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_12.started')
                # update status
                whitesquare_12.status = STARTED
                whitesquare_12.setAutoDraw(True)
            
            # if whitesquare_12 is active this frame...
            if whitesquare_12.status == STARTED:
                # update params
                pass
            
            # if whitesquare_12 is stopping this frame...
            if whitesquare_12.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_12.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_12.tStop = t  # not accounting for scr refresh
                    whitesquare_12.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_12.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_12.stopped')
                    # update status
                    whitesquare_12.status = FINISHED
                    whitesquare_12.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_right" ---
        for thisComponent in leftA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_right
        leftA_on_right.tStop = globalClock.getTime(format='float')
        leftA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_right.stopped', leftA_on_right.tStop)
        # check responses
        if key_resp_21.keys in ['', [], None]:  # No response was made
            key_resp_21.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_21.corr = 1;  # correct non-response
            else:
               key_resp_21.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_21.keys',key_resp_21.keys)
        trials_b5.addData('key_resp_21.corr', key_resp_21.corr)
        if key_resp_21.keys != None:  # we had a response
            trials_b5.addData('key_resp_21.rt', key_resp_21.rt)
            trials_b5.addData('key_resp_21.duration', key_resp_21.duration)
        # the Routine "leftA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_left" ---
        # create an object to store info about Routine leftA_on_left
        leftA_on_left = data.Routine(
            name='leftA_on_left',
            components=[blacksquare_19, white_cross_19, key_resp_22, arrow_l_3, whitesquare_7, whitesquare_14],
        )
        leftA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_22
        key_resp_22.keys = []
        key_resp_22.rt = []
        _key_resp_22_allKeys = []
        # Run 'Begin Routine' code from code_9
        
        
        if currentRoutine != "leftA_on_left":
            continueRoutine = False
        
        # store start times for leftA_on_left
        leftA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_left.tStart = globalClock.getTime(format='float')
        leftA_on_left.status = STARTED
        thisExp.addData('leftA_on_left.started', leftA_on_left.tStart)
        leftA_on_left.maxDuration = None
        # keep track of which components have finished
        leftA_on_leftComponents = leftA_on_left.components
        for thisComponent in leftA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        leftA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_19* updates
            
            # if blacksquare_19 is starting this frame...
            if blacksquare_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_19.frameNStart = frameN  # exact frame index
                blacksquare_19.tStart = t  # local t and not account for scr refresh
                blacksquare_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_19.started')
                # update status
                blacksquare_19.status = STARTED
                blacksquare_19.setAutoDraw(True)
            
            # if blacksquare_19 is active this frame...
            if blacksquare_19.status == STARTED:
                # update params
                pass
            
            # *white_cross_19* updates
            
            # if white_cross_19 is starting this frame...
            if white_cross_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_19.frameNStart = frameN  # exact frame index
                white_cross_19.tStart = t  # local t and not account for scr refresh
                white_cross_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_19.started')
                # update status
                white_cross_19.status = STARTED
                white_cross_19.setAutoDraw(True)
            
            # if white_cross_19 is active this frame...
            if white_cross_19.status == STARTED:
                # update params
                pass
            
            # *key_resp_22* updates
            waitOnFlip = False
            
            # if key_resp_22 is starting this frame...
            if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_22.frameNStart = frameN  # exact frame index
                key_resp_22.tStart = t  # local t and not account for scr refresh
                key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_22.started')
                # update status
                key_resp_22.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_22.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_22.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_22_allKeys.extend(theseKeys)
                if len(_key_resp_22_allKeys):
                    key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
                    key_resp_22.rt = _key_resp_22_allKeys[-1].rt
                    key_resp_22.duration = _key_resp_22_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_22.keys == str('left')) or (key_resp_22.keys == 'left'):
                        key_resp_22.corr = 1
                    else:
                        key_resp_22.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_3* updates
            
            # if arrow_l_3 is starting this frame...
            if arrow_l_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_3.frameNStart = frameN  # exact frame index
                arrow_l_3.tStart = t  # local t and not account for scr refresh
                arrow_l_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_3.started')
                # update status
                arrow_l_3.status = STARTED
                arrow_l_3.setAutoDraw(True)
            
            # if arrow_l_3 is active this frame...
            if arrow_l_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_7* updates
            
            # if whitesquare_7 is starting this frame...
            if whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_7.frameNStart = frameN  # exact frame index
                whitesquare_7.tStart = t  # local t and not account for scr refresh
                whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_7.started')
                # update status
                whitesquare_7.status = STARTED
                whitesquare_7.setAutoDraw(True)
            
            # if whitesquare_7 is active this frame...
            if whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if whitesquare_7 is stopping this frame...
            if whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_7.tStop = t  # not accounting for scr refresh
                    whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_7.stopped')
                    # update status
                    whitesquare_7.status = FINISHED
                    whitesquare_7.setAutoDraw(False)
            
            # *whitesquare_14* updates
            
            # if whitesquare_14 is starting this frame...
            if whitesquare_14.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_14.frameNStart = frameN  # exact frame index
                whitesquare_14.tStart = t  # local t and not account for scr refresh
                whitesquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_14.started')
                # update status
                whitesquare_14.status = STARTED
                whitesquare_14.setAutoDraw(True)
            
            # if whitesquare_14 is active this frame...
            if whitesquare_14.status == STARTED:
                # update params
                pass
            
            # if whitesquare_14 is stopping this frame...
            if whitesquare_14.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_14.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_14.tStop = t  # not accounting for scr refresh
                    whitesquare_14.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_14.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_14.stopped')
                    # update status
                    whitesquare_14.status = FINISHED
                    whitesquare_14.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_left" ---
        for thisComponent in leftA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_left
        leftA_on_left.tStop = globalClock.getTime(format='float')
        leftA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_left.stopped', leftA_on_left.tStop)
        # check responses
        if key_resp_22.keys in ['', [], None]:  # No response was made
            key_resp_22.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_22.corr = 1;  # correct non-response
            else:
               key_resp_22.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_22.keys',key_resp_22.keys)
        trials_b5.addData('key_resp_22.corr', key_resp_22.corr)
        if key_resp_22.keys != None:  # we had a response
            trials_b5.addData('key_resp_22.rt', key_resp_22.rt)
            trials_b5.addData('key_resp_22.duration', key_resp_22.duration)
        # the Routine "leftA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_right" ---
        # create an object to store info about Routine rightA_on_right
        rightA_on_right = data.Routine(
            name='rightA_on_right',
            components=[blacksquare_20, white_cross_20, key_resp_23, arrow_l_4, whitesquare_11, whitesquare_18],
        )
        rightA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_23
        key_resp_23.keys = []
        key_resp_23.rt = []
        _key_resp_23_allKeys = []
        # Run 'Begin Routine' code from code_13
        
        
        if currentRoutine != "rightA_on_right":
            continueRoutine = False
        
        # store start times for rightA_on_right
        rightA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_right.tStart = globalClock.getTime(format='float')
        rightA_on_right.status = STARTED
        thisExp.addData('rightA_on_right.started', rightA_on_right.tStart)
        rightA_on_right.maxDuration = None
        # keep track of which components have finished
        rightA_on_rightComponents = rightA_on_right.components
        for thisComponent in rightA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        rightA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_20* updates
            
            # if blacksquare_20 is starting this frame...
            if blacksquare_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_20.frameNStart = frameN  # exact frame index
                blacksquare_20.tStart = t  # local t and not account for scr refresh
                blacksquare_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_20.started')
                # update status
                blacksquare_20.status = STARTED
                blacksquare_20.setAutoDraw(True)
            
            # if blacksquare_20 is active this frame...
            if blacksquare_20.status == STARTED:
                # update params
                pass
            
            # *white_cross_20* updates
            
            # if white_cross_20 is starting this frame...
            if white_cross_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_20.frameNStart = frameN  # exact frame index
                white_cross_20.tStart = t  # local t and not account for scr refresh
                white_cross_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_20.started')
                # update status
                white_cross_20.status = STARTED
                white_cross_20.setAutoDraw(True)
            
            # if white_cross_20 is active this frame...
            if white_cross_20.status == STARTED:
                # update params
                pass
            
            # *key_resp_23* updates
            waitOnFlip = False
            
            # if key_resp_23 is starting this frame...
            if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_23.frameNStart = frameN  # exact frame index
                key_resp_23.tStart = t  # local t and not account for scr refresh
                key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_23.started')
                # update status
                key_resp_23.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_23.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_23.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_23_allKeys.extend(theseKeys)
                if len(_key_resp_23_allKeys):
                    key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
                    key_resp_23.rt = _key_resp_23_allKeys[-1].rt
                    key_resp_23.duration = _key_resp_23_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_23.keys == str('left')) or (key_resp_23.keys == 'left'):
                        key_resp_23.corr = 1
                    else:
                        key_resp_23.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_4* updates
            
            # if arrow_l_4 is starting this frame...
            if arrow_l_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_4.frameNStart = frameN  # exact frame index
                arrow_l_4.tStart = t  # local t and not account for scr refresh
                arrow_l_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_4.started')
                # update status
                arrow_l_4.status = STARTED
                arrow_l_4.setAutoDraw(True)
            
            # if arrow_l_4 is active this frame...
            if arrow_l_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_11* updates
            
            # if whitesquare_11 is starting this frame...
            if whitesquare_11.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_11.frameNStart = frameN  # exact frame index
                whitesquare_11.tStart = t  # local t and not account for scr refresh
                whitesquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_11.started')
                # update status
                whitesquare_11.status = STARTED
                whitesquare_11.setAutoDraw(True)
            
            # if whitesquare_11 is active this frame...
            if whitesquare_11.status == STARTED:
                # update params
                pass
            
            # if whitesquare_11 is stopping this frame...
            if whitesquare_11.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_11.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_11.tStop = t  # not accounting for scr refresh
                    whitesquare_11.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_11.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_11.stopped')
                    # update status
                    whitesquare_11.status = FINISHED
                    whitesquare_11.setAutoDraw(False)
            
            # *whitesquare_18* updates
            
            # if whitesquare_18 is starting this frame...
            if whitesquare_18.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_18.frameNStart = frameN  # exact frame index
                whitesquare_18.tStart = t  # local t and not account for scr refresh
                whitesquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_18.started')
                # update status
                whitesquare_18.status = STARTED
                whitesquare_18.setAutoDraw(True)
            
            # if whitesquare_18 is active this frame...
            if whitesquare_18.status == STARTED:
                # update params
                pass
            
            # if whitesquare_18 is stopping this frame...
            if whitesquare_18.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_18.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_18.tStop = t  # not accounting for scr refresh
                    whitesquare_18.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_18.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_18.stopped')
                    # update status
                    whitesquare_18.status = FINISHED
                    whitesquare_18.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_right" ---
        for thisComponent in rightA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_right
        rightA_on_right.tStop = globalClock.getTime(format='float')
        rightA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_right.stopped', rightA_on_right.tStop)
        # check responses
        if key_resp_23.keys in ['', [], None]:  # No response was made
            key_resp_23.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_23.corr = 1;  # correct non-response
            else:
               key_resp_23.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_23.keys',key_resp_23.keys)
        trials_b5.addData('key_resp_23.corr', key_resp_23.corr)
        if key_resp_23.keys != None:  # we had a response
            trials_b5.addData('key_resp_23.rt', key_resp_23.rt)
            trials_b5.addData('key_resp_23.duration', key_resp_23.duration)
        # the Routine "rightA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_left" ---
        # create an object to store info about Routine rightA_on_left
        rightA_on_left = data.Routine(
            name='rightA_on_left',
            components=[blacksquare_21, white_cross_21, key_resp_24, arrow_l_5, whitesquare_9, whitesquare_16],
        )
        rightA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_24
        key_resp_24.keys = []
        key_resp_24.rt = []
        _key_resp_24_allKeys = []
        # Run 'Begin Routine' code from code_11
        
        
        if currentRoutine != "rightA_on_left":
            continueRoutine = False
        
        # store start times for rightA_on_left
        rightA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_left.tStart = globalClock.getTime(format='float')
        rightA_on_left.status = STARTED
        thisExp.addData('rightA_on_left.started', rightA_on_left.tStart)
        rightA_on_left.maxDuration = None
        # keep track of which components have finished
        rightA_on_leftComponents = rightA_on_left.components
        for thisComponent in rightA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        rightA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_21* updates
            
            # if blacksquare_21 is starting this frame...
            if blacksquare_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_21.frameNStart = frameN  # exact frame index
                blacksquare_21.tStart = t  # local t and not account for scr refresh
                blacksquare_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_21.started')
                # update status
                blacksquare_21.status = STARTED
                blacksquare_21.setAutoDraw(True)
            
            # if blacksquare_21 is active this frame...
            if blacksquare_21.status == STARTED:
                # update params
                pass
            
            # *white_cross_21* updates
            
            # if white_cross_21 is starting this frame...
            if white_cross_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_21.frameNStart = frameN  # exact frame index
                white_cross_21.tStart = t  # local t and not account for scr refresh
                white_cross_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_21.started')
                # update status
                white_cross_21.status = STARTED
                white_cross_21.setAutoDraw(True)
            
            # if white_cross_21 is active this frame...
            if white_cross_21.status == STARTED:
                # update params
                pass
            
            # *key_resp_24* updates
            waitOnFlip = False
            
            # if key_resp_24 is starting this frame...
            if key_resp_24.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_24.frameNStart = frameN  # exact frame index
                key_resp_24.tStart = t  # local t and not account for scr refresh
                key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_24.started')
                # update status
                key_resp_24.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_24.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_24.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_24_allKeys.extend(theseKeys)
                if len(_key_resp_24_allKeys):
                    key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
                    key_resp_24.rt = _key_resp_24_allKeys[-1].rt
                    key_resp_24.duration = _key_resp_24_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_24.keys == str('left')) or (key_resp_24.keys == 'left'):
                        key_resp_24.corr = 1
                    else:
                        key_resp_24.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_5* updates
            
            # if arrow_l_5 is starting this frame...
            if arrow_l_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_5.frameNStart = frameN  # exact frame index
                arrow_l_5.tStart = t  # local t and not account for scr refresh
                arrow_l_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_5.started')
                # update status
                arrow_l_5.status = STARTED
                arrow_l_5.setAutoDraw(True)
            
            # if arrow_l_5 is active this frame...
            if arrow_l_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_9* updates
            
            # if whitesquare_9 is starting this frame...
            if whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_9.frameNStart = frameN  # exact frame index
                whitesquare_9.tStart = t  # local t and not account for scr refresh
                whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_9.started')
                # update status
                whitesquare_9.status = STARTED
                whitesquare_9.setAutoDraw(True)
            
            # if whitesquare_9 is active this frame...
            if whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if whitesquare_9 is stopping this frame...
            if whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_9.tStop = t  # not accounting for scr refresh
                    whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_9.stopped')
                    # update status
                    whitesquare_9.status = FINISHED
                    whitesquare_9.setAutoDraw(False)
            
            # *whitesquare_16* updates
            
            # if whitesquare_16 is starting this frame...
            if whitesquare_16.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_16.frameNStart = frameN  # exact frame index
                whitesquare_16.tStart = t  # local t and not account for scr refresh
                whitesquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_16.started')
                # update status
                whitesquare_16.status = STARTED
                whitesquare_16.setAutoDraw(True)
            
            # if whitesquare_16 is active this frame...
            if whitesquare_16.status == STARTED:
                # update params
                pass
            
            # if whitesquare_16 is stopping this frame...
            if whitesquare_16.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_16.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_16.tStop = t  # not accounting for scr refresh
                    whitesquare_16.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_16.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_16.stopped')
                    # update status
                    whitesquare_16.status = FINISHED
                    whitesquare_16.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_left" ---
        for thisComponent in rightA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_left
        rightA_on_left.tStop = globalClock.getTime(format='float')
        rightA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_left.stopped', rightA_on_left.tStop)
        # check responses
        if key_resp_24.keys in ['', [], None]:  # No response was made
            key_resp_24.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_24.corr = 1;  # correct non-response
            else:
               key_resp_24.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_24.keys',key_resp_24.keys)
        trials_b5.addData('key_resp_24.corr', key_resp_24.corr)
        if key_resp_24.keys != None:  # we had a response
            trials_b5.addData('key_resp_24.rt', key_resp_24.rt)
            trials_b5.addData('key_resp_24.duration', key_resp_24.duration)
        # the Routine "rightA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_up" ---
        # create an object to store info about Routine upA_on_up
        upA_on_up = data.Routine(
            name='upA_on_up',
            components=[blacksquare_22, white_cross_22, key_resp_25, arrow_u, up_whitesquare_3, down_whitesquare_3],
        )
        upA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_25
        key_resp_25.keys = []
        key_resp_25.rt = []
        _key_resp_25_allKeys = []
        # Run 'Begin Routine' code from code_15
        
        
        if currentRoutine != "upA_on_up":
            continueRoutine = False
        
        # store start times for upA_on_up
        upA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_up.tStart = globalClock.getTime(format='float')
        upA_on_up.status = STARTED
        thisExp.addData('upA_on_up.started', upA_on_up.tStart)
        upA_on_up.maxDuration = None
        # keep track of which components have finished
        upA_on_upComponents = upA_on_up.components
        for thisComponent in upA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        upA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_22* updates
            
            # if blacksquare_22 is starting this frame...
            if blacksquare_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_22.frameNStart = frameN  # exact frame index
                blacksquare_22.tStart = t  # local t and not account for scr refresh
                blacksquare_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_22.started')
                # update status
                blacksquare_22.status = STARTED
                blacksquare_22.setAutoDraw(True)
            
            # if blacksquare_22 is active this frame...
            if blacksquare_22.status == STARTED:
                # update params
                pass
            
            # *white_cross_22* updates
            
            # if white_cross_22 is starting this frame...
            if white_cross_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_22.frameNStart = frameN  # exact frame index
                white_cross_22.tStart = t  # local t and not account for scr refresh
                white_cross_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_22.started')
                # update status
                white_cross_22.status = STARTED
                white_cross_22.setAutoDraw(True)
            
            # if white_cross_22 is active this frame...
            if white_cross_22.status == STARTED:
                # update params
                pass
            
            # *key_resp_25* updates
            waitOnFlip = False
            
            # if key_resp_25 is starting this frame...
            if key_resp_25.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_25.frameNStart = frameN  # exact frame index
                key_resp_25.tStart = t  # local t and not account for scr refresh
                key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_25.started')
                # update status
                key_resp_25.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_25.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_25.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_25_allKeys.extend(theseKeys)
                if len(_key_resp_25_allKeys):
                    key_resp_25.keys = _key_resp_25_allKeys[-1].name  # just the last key pressed
                    key_resp_25.rt = _key_resp_25_allKeys[-1].rt
                    key_resp_25.duration = _key_resp_25_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_25.keys == str('left')) or (key_resp_25.keys == 'left'):
                        key_resp_25.corr = 1
                    else:
                        key_resp_25.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u* updates
            
            # if arrow_u is starting this frame...
            if arrow_u.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u.frameNStart = frameN  # exact frame index
                arrow_u.tStart = t  # local t and not account for scr refresh
                arrow_u.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u.started')
                # update status
                arrow_u.status = STARTED
                arrow_u.setAutoDraw(True)
            
            # if arrow_u is active this frame...
            if arrow_u.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_3* updates
            
            # if up_whitesquare_3 is starting this frame...
            if up_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_3.frameNStart = frameN  # exact frame index
                up_whitesquare_3.tStart = t  # local t and not account for scr refresh
                up_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_3.started')
                # update status
                up_whitesquare_3.status = STARTED
                up_whitesquare_3.setAutoDraw(True)
            
            # if up_whitesquare_3 is active this frame...
            if up_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_3 is stopping this frame...
            if up_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_3.tStop = t  # not accounting for scr refresh
                    up_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_3.stopped')
                    # update status
                    up_whitesquare_3.status = FINISHED
                    up_whitesquare_3.setAutoDraw(False)
            
            # *down_whitesquare_3* updates
            
            # if down_whitesquare_3 is starting this frame...
            if down_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_3.frameNStart = frameN  # exact frame index
                down_whitesquare_3.tStart = t  # local t and not account for scr refresh
                down_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_3.started')
                # update status
                down_whitesquare_3.status = STARTED
                down_whitesquare_3.setAutoDraw(True)
            
            # if down_whitesquare_3 is active this frame...
            if down_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_3 is stopping this frame...
            if down_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_3.tStop = t  # not accounting for scr refresh
                    down_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_3.stopped')
                    # update status
                    down_whitesquare_3.status = FINISHED
                    down_whitesquare_3.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_up" ---
        for thisComponent in upA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_up
        upA_on_up.tStop = globalClock.getTime(format='float')
        upA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_up.stopped', upA_on_up.tStop)
        # check responses
        if key_resp_25.keys in ['', [], None]:  # No response was made
            key_resp_25.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_25.corr = 1;  # correct non-response
            else:
               key_resp_25.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_25.keys',key_resp_25.keys)
        trials_b5.addData('key_resp_25.corr', key_resp_25.corr)
        if key_resp_25.keys != None:  # we had a response
            trials_b5.addData('key_resp_25.rt', key_resp_25.rt)
            trials_b5.addData('key_resp_25.duration', key_resp_25.duration)
        # the Routine "upA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_down" ---
        # create an object to store info about Routine upA_on_down
        upA_on_down = data.Routine(
            name='upA_on_down',
            components=[blacksquare_23, white_cross_23, key_resp_26, arrow_u_2, up_whitesquare_7, down_whitesquare_7],
        )
        upA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_26
        key_resp_26.keys = []
        key_resp_26.rt = []
        _key_resp_26_allKeys = []
        # Run 'Begin Routine' code from code_19
        
        
        if currentRoutine != "upA_on_down":
            continueRoutine = False
        
        # store start times for upA_on_down
        upA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_down.tStart = globalClock.getTime(format='float')
        upA_on_down.status = STARTED
        thisExp.addData('upA_on_down.started', upA_on_down.tStart)
        upA_on_down.maxDuration = None
        # keep track of which components have finished
        upA_on_downComponents = upA_on_down.components
        for thisComponent in upA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        upA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_23* updates
            
            # if blacksquare_23 is starting this frame...
            if blacksquare_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_23.frameNStart = frameN  # exact frame index
                blacksquare_23.tStart = t  # local t and not account for scr refresh
                blacksquare_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_23.started')
                # update status
                blacksquare_23.status = STARTED
                blacksquare_23.setAutoDraw(True)
            
            # if blacksquare_23 is active this frame...
            if blacksquare_23.status == STARTED:
                # update params
                pass
            
            # *white_cross_23* updates
            
            # if white_cross_23 is starting this frame...
            if white_cross_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_23.frameNStart = frameN  # exact frame index
                white_cross_23.tStart = t  # local t and not account for scr refresh
                white_cross_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_23.started')
                # update status
                white_cross_23.status = STARTED
                white_cross_23.setAutoDraw(True)
            
            # if white_cross_23 is active this frame...
            if white_cross_23.status == STARTED:
                # update params
                pass
            
            # *key_resp_26* updates
            waitOnFlip = False
            
            # if key_resp_26 is starting this frame...
            if key_resp_26.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_26.frameNStart = frameN  # exact frame index
                key_resp_26.tStart = t  # local t and not account for scr refresh
                key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_26.started')
                # update status
                key_resp_26.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_26.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_26.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_26_allKeys.extend(theseKeys)
                if len(_key_resp_26_allKeys):
                    key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
                    key_resp_26.rt = _key_resp_26_allKeys[-1].rt
                    key_resp_26.duration = _key_resp_26_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_26.keys == str('left')) or (key_resp_26.keys == 'left'):
                        key_resp_26.corr = 1
                    else:
                        key_resp_26.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_2* updates
            
            # if arrow_u_2 is starting this frame...
            if arrow_u_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_2.frameNStart = frameN  # exact frame index
                arrow_u_2.tStart = t  # local t and not account for scr refresh
                arrow_u_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_2.started')
                # update status
                arrow_u_2.status = STARTED
                arrow_u_2.setAutoDraw(True)
            
            # if arrow_u_2 is active this frame...
            if arrow_u_2.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_7* updates
            
            # if up_whitesquare_7 is starting this frame...
            if up_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_7.frameNStart = frameN  # exact frame index
                up_whitesquare_7.tStart = t  # local t and not account for scr refresh
                up_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_7.started')
                # update status
                up_whitesquare_7.status = STARTED
                up_whitesquare_7.setAutoDraw(True)
            
            # if up_whitesquare_7 is active this frame...
            if up_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_7 is stopping this frame...
            if up_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_7.tStop = t  # not accounting for scr refresh
                    up_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_7.stopped')
                    # update status
                    up_whitesquare_7.status = FINISHED
                    up_whitesquare_7.setAutoDraw(False)
            
            # *down_whitesquare_7* updates
            
            # if down_whitesquare_7 is starting this frame...
            if down_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_7.frameNStart = frameN  # exact frame index
                down_whitesquare_7.tStart = t  # local t and not account for scr refresh
                down_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_7.started')
                # update status
                down_whitesquare_7.status = STARTED
                down_whitesquare_7.setAutoDraw(True)
            
            # if down_whitesquare_7 is active this frame...
            if down_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_7 is stopping this frame...
            if down_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_7.tStop = t  # not accounting for scr refresh
                    down_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_7.stopped')
                    # update status
                    down_whitesquare_7.status = FINISHED
                    down_whitesquare_7.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_down" ---
        for thisComponent in upA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_down
        upA_on_down.tStop = globalClock.getTime(format='float')
        upA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_down.stopped', upA_on_down.tStop)
        # check responses
        if key_resp_26.keys in ['', [], None]:  # No response was made
            key_resp_26.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_26.corr = 1;  # correct non-response
            else:
               key_resp_26.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_26.keys',key_resp_26.keys)
        trials_b5.addData('key_resp_26.corr', key_resp_26.corr)
        if key_resp_26.keys != None:  # we had a response
            trials_b5.addData('key_resp_26.rt', key_resp_26.rt)
            trials_b5.addData('key_resp_26.duration', key_resp_26.duration)
        # the Routine "upA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_down" ---
        # create an object to store info about Routine downA_on_down
        downA_on_down = data.Routine(
            name='downA_on_down',
            components=[blacksquare_24, white_cross_24, key_resp_27, arrow_u_3, up_whitesquare_9, down_whitesquare_9],
        )
        downA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_27
        key_resp_27.keys = []
        key_resp_27.rt = []
        _key_resp_27_allKeys = []
        # Run 'Begin Routine' code from code_21
        
        
        if currentRoutine != "downA_on_down":
            continueRoutine = False
        
        # store start times for downA_on_down
        downA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_down.tStart = globalClock.getTime(format='float')
        downA_on_down.status = STARTED
        thisExp.addData('downA_on_down.started', downA_on_down.tStart)
        downA_on_down.maxDuration = None
        # keep track of which components have finished
        downA_on_downComponents = downA_on_down.components
        for thisComponent in downA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        downA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_24* updates
            
            # if blacksquare_24 is starting this frame...
            if blacksquare_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_24.frameNStart = frameN  # exact frame index
                blacksquare_24.tStart = t  # local t and not account for scr refresh
                blacksquare_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_24.started')
                # update status
                blacksquare_24.status = STARTED
                blacksquare_24.setAutoDraw(True)
            
            # if blacksquare_24 is active this frame...
            if blacksquare_24.status == STARTED:
                # update params
                pass
            
            # *white_cross_24* updates
            
            # if white_cross_24 is starting this frame...
            if white_cross_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_24.frameNStart = frameN  # exact frame index
                white_cross_24.tStart = t  # local t and not account for scr refresh
                white_cross_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_24.started')
                # update status
                white_cross_24.status = STARTED
                white_cross_24.setAutoDraw(True)
            
            # if white_cross_24 is active this frame...
            if white_cross_24.status == STARTED:
                # update params
                pass
            
            # *key_resp_27* updates
            waitOnFlip = False
            
            # if key_resp_27 is starting this frame...
            if key_resp_27.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_27.frameNStart = frameN  # exact frame index
                key_resp_27.tStart = t  # local t and not account for scr refresh
                key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_27.started')
                # update status
                key_resp_27.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_27.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_27.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_27_allKeys.extend(theseKeys)
                if len(_key_resp_27_allKeys):
                    key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
                    key_resp_27.rt = _key_resp_27_allKeys[-1].rt
                    key_resp_27.duration = _key_resp_27_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_27.keys == str('left')) or (key_resp_27.keys == 'left'):
                        key_resp_27.corr = 1
                    else:
                        key_resp_27.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_3* updates
            
            # if arrow_u_3 is starting this frame...
            if arrow_u_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_3.frameNStart = frameN  # exact frame index
                arrow_u_3.tStart = t  # local t and not account for scr refresh
                arrow_u_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_3.started')
                # update status
                arrow_u_3.status = STARTED
                arrow_u_3.setAutoDraw(True)
            
            # if arrow_u_3 is active this frame...
            if arrow_u_3.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_9* updates
            
            # if up_whitesquare_9 is starting this frame...
            if up_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_9.frameNStart = frameN  # exact frame index
                up_whitesquare_9.tStart = t  # local t and not account for scr refresh
                up_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_9.started')
                # update status
                up_whitesquare_9.status = STARTED
                up_whitesquare_9.setAutoDraw(True)
            
            # if up_whitesquare_9 is active this frame...
            if up_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_9 is stopping this frame...
            if up_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_9.tStop = t  # not accounting for scr refresh
                    up_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_9.stopped')
                    # update status
                    up_whitesquare_9.status = FINISHED
                    up_whitesquare_9.setAutoDraw(False)
            
            # *down_whitesquare_9* updates
            
            # if down_whitesquare_9 is starting this frame...
            if down_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_9.frameNStart = frameN  # exact frame index
                down_whitesquare_9.tStart = t  # local t and not account for scr refresh
                down_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_9.started')
                # update status
                down_whitesquare_9.status = STARTED
                down_whitesquare_9.setAutoDraw(True)
            
            # if down_whitesquare_9 is active this frame...
            if down_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_9 is stopping this frame...
            if down_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_9.tStop = t  # not accounting for scr refresh
                    down_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_9.stopped')
                    # update status
                    down_whitesquare_9.status = FINISHED
                    down_whitesquare_9.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_down" ---
        for thisComponent in downA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_down
        downA_on_down.tStop = globalClock.getTime(format='float')
        downA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_down.stopped', downA_on_down.tStop)
        # check responses
        if key_resp_27.keys in ['', [], None]:  # No response was made
            key_resp_27.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_27.corr = 1;  # correct non-response
            else:
               key_resp_27.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_27.keys',key_resp_27.keys)
        trials_b5.addData('key_resp_27.corr', key_resp_27.corr)
        if key_resp_27.keys != None:  # we had a response
            trials_b5.addData('key_resp_27.rt', key_resp_27.rt)
            trials_b5.addData('key_resp_27.duration', key_resp_27.duration)
        # the Routine "downA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_up" ---
        # create an object to store info about Routine downA_on_up
        downA_on_up = data.Routine(
            name='downA_on_up',
            components=[blacksquare_25, white_cross_25, key_resp_28, arrow_u_4, up_whitesquare_5, down_whitesquare_5],
        )
        downA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_28
        key_resp_28.keys = []
        key_resp_28.rt = []
        _key_resp_28_allKeys = []
        # Run 'Begin Routine' code from code_17
        
        
        if currentRoutine != "downA_on_up":
            continueRoutine = False
        
        # store start times for downA_on_up
        downA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_up.tStart = globalClock.getTime(format='float')
        downA_on_up.status = STARTED
        thisExp.addData('downA_on_up.started', downA_on_up.tStart)
        downA_on_up.maxDuration = None
        # keep track of which components have finished
        downA_on_upComponents = downA_on_up.components
        for thisComponent in downA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b5, data.TrialHandler2) and thisTrials_b5.thisN != trials_b5.thisTrial.thisN:
            continueRoutine = False
        downA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_25* updates
            
            # if blacksquare_25 is starting this frame...
            if blacksquare_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_25.frameNStart = frameN  # exact frame index
                blacksquare_25.tStart = t  # local t and not account for scr refresh
                blacksquare_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_25.started')
                # update status
                blacksquare_25.status = STARTED
                blacksquare_25.setAutoDraw(True)
            
            # if blacksquare_25 is active this frame...
            if blacksquare_25.status == STARTED:
                # update params
                pass
            
            # *white_cross_25* updates
            
            # if white_cross_25 is starting this frame...
            if white_cross_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_25.frameNStart = frameN  # exact frame index
                white_cross_25.tStart = t  # local t and not account for scr refresh
                white_cross_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_25.started')
                # update status
                white_cross_25.status = STARTED
                white_cross_25.setAutoDraw(True)
            
            # if white_cross_25 is active this frame...
            if white_cross_25.status == STARTED:
                # update params
                pass
            
            # *key_resp_28* updates
            waitOnFlip = False
            
            # if key_resp_28 is starting this frame...
            if key_resp_28.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_28.frameNStart = frameN  # exact frame index
                key_resp_28.tStart = t  # local t and not account for scr refresh
                key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_28.started')
                # update status
                key_resp_28.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_28.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_28.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_28_allKeys.extend(theseKeys)
                if len(_key_resp_28_allKeys):
                    key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
                    key_resp_28.rt = _key_resp_28_allKeys[-1].rt
                    key_resp_28.duration = _key_resp_28_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_28.keys == str('left')) or (key_resp_28.keys == 'left'):
                        key_resp_28.corr = 1
                    else:
                        key_resp_28.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_4* updates
            
            # if arrow_u_4 is starting this frame...
            if arrow_u_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_4.frameNStart = frameN  # exact frame index
                arrow_u_4.tStart = t  # local t and not account for scr refresh
                arrow_u_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_4.started')
                # update status
                arrow_u_4.status = STARTED
                arrow_u_4.setAutoDraw(True)
            
            # if arrow_u_4 is active this frame...
            if arrow_u_4.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_5* updates
            
            # if up_whitesquare_5 is starting this frame...
            if up_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_5.frameNStart = frameN  # exact frame index
                up_whitesquare_5.tStart = t  # local t and not account for scr refresh
                up_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_5.started')
                # update status
                up_whitesquare_5.status = STARTED
                up_whitesquare_5.setAutoDraw(True)
            
            # if up_whitesquare_5 is active this frame...
            if up_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_5 is stopping this frame...
            if up_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_5.tStop = t  # not accounting for scr refresh
                    up_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_5.stopped')
                    # update status
                    up_whitesquare_5.status = FINISHED
                    up_whitesquare_5.setAutoDraw(False)
            
            # *down_whitesquare_5* updates
            
            # if down_whitesquare_5 is starting this frame...
            if down_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_5.frameNStart = frameN  # exact frame index
                down_whitesquare_5.tStart = t  # local t and not account for scr refresh
                down_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_5.started')
                # update status
                down_whitesquare_5.status = STARTED
                down_whitesquare_5.setAutoDraw(True)
            
            # if down_whitesquare_5 is active this frame...
            if down_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_5 is stopping this frame...
            if down_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_5.tStop = t  # not accounting for scr refresh
                    down_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_5.stopped')
                    # update status
                    down_whitesquare_5.status = FINISHED
                    down_whitesquare_5.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_up" ---
        for thisComponent in downA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_up
        downA_on_up.tStop = globalClock.getTime(format='float')
        downA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_up.stopped', downA_on_up.tStop)
        # check responses
        if key_resp_28.keys in ['', [], None]:  # No response was made
            key_resp_28.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_28.corr = 1;  # correct non-response
            else:
               key_resp_28.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b5 (TrialHandler)
        trials_b5.addData('key_resp_28.keys',key_resp_28.keys)
        trials_b5.addData('key_resp_28.corr', key_resp_28.corr)
        if key_resp_28.keys != None:  # we had a response
            trials_b5.addData('key_resp_28.rt', key_resp_28.rt)
            trials_b5.addData('key_resp_28.duration', key_resp_28.duration)
        # the Routine "downA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 32.0 repeats of 'trials_b5'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "end_block5" ---
    # create an object to store info about Routine end_block5
    end_block5 = data.Routine(
        name='end_block5',
        components=[text_35, text_36, key_resp_33],
    )
    end_block5.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_33
    key_resp_33.keys = []
    key_resp_33.rt = []
    _key_resp_33_allKeys = []
    # store start times for end_block5
    end_block5.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    end_block5.tStart = globalClock.getTime(format='float')
    end_block5.status = STARTED
    thisExp.addData('end_block5.started', end_block5.tStart)
    end_block5.maxDuration = None
    # keep track of which components have finished
    end_block5Components = end_block5.components
    for thisComponent in end_block5.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end_block5" ---
    end_block5.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_35* updates
        
        # if text_35 is starting this frame...
        if text_35.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_35.frameNStart = frameN  # exact frame index
            text_35.tStart = t  # local t and not account for scr refresh
            text_35.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_35, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_35.started')
            # update status
            text_35.status = STARTED
            text_35.setAutoDraw(True)
        
        # if text_35 is active this frame...
        if text_35.status == STARTED:
            # update params
            pass
        
        # *text_36* updates
        
        # if text_36 is starting this frame...
        if text_36.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_36.frameNStart = frameN  # exact frame index
            text_36.tStart = t  # local t and not account for scr refresh
            text_36.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_36, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_36.started')
            # update status
            text_36.status = STARTED
            text_36.setAutoDraw(True)
        
        # if text_36 is active this frame...
        if text_36.status == STARTED:
            # update params
            pass
        
        # *key_resp_33* updates
        waitOnFlip = False
        
        # if key_resp_33 is starting this frame...
        if key_resp_33.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_33.frameNStart = frameN  # exact frame index
            key_resp_33.tStart = t  # local t and not account for scr refresh
            key_resp_33.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_33, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_33.started')
            # update status
            key_resp_33.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_33.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_33.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_33.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_33.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_33_allKeys.extend(theseKeys)
            if len(_key_resp_33_allKeys):
                key_resp_33.keys = _key_resp_33_allKeys[-1].name  # just the last key pressed
                key_resp_33.rt = _key_resp_33_allKeys[-1].rt
                key_resp_33.duration = _key_resp_33_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            end_block5.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in end_block5.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end_block5" ---
    for thisComponent in end_block5.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for end_block5
    end_block5.tStop = globalClock.getTime(format='float')
    end_block5.tStopRefresh = tThisFlipGlobal
    thisExp.addData('end_block5.stopped', end_block5.tStop)
    # check responses
    if key_resp_33.keys in ['', [], None]:  # No response was made
        key_resp_33.keys = None
    thisExp.addData('key_resp_33.keys',key_resp_33.keys)
    if key_resp_33.keys != None:  # we had a response
        thisExp.addData('key_resp_33.rt', key_resp_33.rt)
        thisExp.addData('key_resp_33.duration', key_resp_33.duration)
    thisExp.nextEntry()
    # the Routine "end_block5" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # --- Prepare to start Routine "block6" ---
    # create an object to store info about Routine block6
    block6 = data.Routine(
        name='block6',
        components=[text_28],
    )
    block6.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # store start times for block6
    block6.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    block6.tStart = globalClock.getTime(format='float')
    block6.status = STARTED
    thisExp.addData('block6.started', block6.tStart)
    block6.maxDuration = None
    # keep track of which components have finished
    block6Components = block6.components
    for thisComponent in block6.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "block6" ---
    block6.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine and routineTimer.getTime() < 2.0:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_28* updates
        
        # if text_28 is starting this frame...
        if text_28.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_28.frameNStart = frameN  # exact frame index
            text_28.tStart = t  # local t and not account for scr refresh
            text_28.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_28, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_28.started')
            # update status
            text_28.status = STARTED
            text_28.setAutoDraw(True)
        
        # if text_28 is active this frame...
        if text_28.status == STARTED:
            # update params
            pass
        
        # if text_28 is stopping this frame...
        if text_28.status == STARTED:
            # is it time to stop? (based on global clock, using actual start)
            if tThisFlipGlobal > text_28.tStartRefresh + 2-frameTolerance:
                # keep track of stop time/frame for later
                text_28.tStop = t  # not accounting for scr refresh
                text_28.tStopRefresh = tThisFlipGlobal  # on global time
                text_28.frameNStop = frameN  # exact frame index
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'text_28.stopped')
                # update status
                text_28.status = FINISHED
                text_28.setAutoDraw(False)
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            block6.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in block6.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "block6" ---
    for thisComponent in block6.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for block6
    block6.tStop = globalClock.getTime(format='float')
    block6.tStopRefresh = tThisFlipGlobal
    thisExp.addData('block6.stopped', block6.tStop)
    # using non-slip timing so subtract the expected duration of this Routine (unless ended on request)
    if block6.maxDurationReached:
        routineTimer.addTime(-block6.maxDuration)
    elif block6.forceEnded:
        routineTimer.reset()
    else:
        routineTimer.addTime(-2.000000)
    thisExp.nextEntry()
    
    # set up handler to look after randomisation of conditions etc
    trials_b6 = data.TrialHandler2(
        name='trials_b6',
        nReps=32.0, 
        method='random', 
        extraInfo=expInfo, 
        originPath=-1, 
        trialList=[None], 
        seed=None, 
    )
    thisExp.addLoop(trials_b6)  # add the loop to the experiment
    thisTrials_b6 = trials_b6.trialList[0]  # so we can initialise stimuli with some values
    # abbreviate parameter names if possible (e.g. rgb = thisTrials_b6.rgb)
    if thisTrials_b6 != None:
        for paramName in thisTrials_b6:
            globals()[paramName] = thisTrials_b6[paramName]
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    for thisTrials_b6 in trials_b6:
        currentLoop = trials_b6
        thisExp.timestampOnFlip(win, 'thisRow.t', format=globalClock.format)
        if thisSession is not None:
            # if running in a Session with a Liaison client, send data up to now
            thisSession.sendExperimentData()
        # abbreviate parameter names if possible (e.g. rgb = thisTrials_b6.rgb)
        if thisTrials_b6 != None:
            for paramName in thisTrials_b6:
                globals()[paramName] = thisTrials_b6[paramName]
        
        # --- Prepare to start Routine "block6_router" ---
        # create an object to store info about Routine block6_router
        block6_router = data.Routine(
            name='block6_router',
            components=[],
        )
        block6_router.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # Run 'Begin Routine' code from code_26
        currentRoutine = schedule[trial_index]
        
        
        # store start times for block6_router
        block6_router.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        block6_router.tStart = globalClock.getTime(format='float')
        block6_router.status = STARTED
        thisExp.addData('block6_router.started', block6_router.tStart)
        block6_router.maxDuration = None
        # keep track of which components have finished
        block6_routerComponents = block6_router.components
        for thisComponent in block6_router.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "block6_router" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        block6_router.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                block6_router.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in block6_router.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "block6_router" ---
        for thisComponent in block6_router.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for block6_router
        block6_router.tStop = globalClock.getTime(format='float')
        block6_router.tStopRefresh = tThisFlipGlobal
        thisExp.addData('block6_router.stopped', block6_router.tStop)
        # Run 'End Routine' code from code_26
        trial_index += 1
        
        # the Routine "block6_router" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_right" ---
        # create an object to store info about Routine LEFT_on_right
        LEFT_on_right = data.Routine(
            name='LEFT_on_right',
            components=[blacksquare_10, white_cross_10, key_resp_13, LEFT_2, whitesquare_3, whitesquare_4],
        )
        LEFT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_13
        key_resp_13.keys = []
        key_resp_13.rt = []
        _key_resp_13_allKeys = []
        # Run 'Begin Routine' code from code_6
        if currentRoutine != "LEFT_on_right":
            continueRoutine = False
        
        # store start times for LEFT_on_right
        LEFT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_right.tStart = globalClock.getTime(format='float')
        LEFT_on_right.status = STARTED
        thisExp.addData('LEFT_on_right.started', LEFT_on_right.tStart)
        LEFT_on_right.maxDuration = None
        # keep track of which components have finished
        LEFT_on_rightComponents = LEFT_on_right.components
        for thisComponent in LEFT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_10* updates
            
            # if blacksquare_10 is starting this frame...
            if blacksquare_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_10.frameNStart = frameN  # exact frame index
                blacksquare_10.tStart = t  # local t and not account for scr refresh
                blacksquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_10.started')
                # update status
                blacksquare_10.status = STARTED
                blacksquare_10.setAutoDraw(True)
            
            # if blacksquare_10 is active this frame...
            if blacksquare_10.status == STARTED:
                # update params
                pass
            
            # *white_cross_10* updates
            
            # if white_cross_10 is starting this frame...
            if white_cross_10.status == NOT_STARTED and tThisFlip >= 0.-frameTolerance:
                # keep track of start time/frame for later
                white_cross_10.frameNStart = frameN  # exact frame index
                white_cross_10.tStart = t  # local t and not account for scr refresh
                white_cross_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_10.started')
                # update status
                white_cross_10.status = STARTED
                white_cross_10.setAutoDraw(True)
            
            # if white_cross_10 is active this frame...
            if white_cross_10.status == STARTED:
                # update params
                pass
            
            # *key_resp_13* updates
            waitOnFlip = False
            
            # if key_resp_13 is starting this frame...
            if key_resp_13.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_13.frameNStart = frameN  # exact frame index
                key_resp_13.tStart = t  # local t and not account for scr refresh
                key_resp_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_13.started')
                # update status
                key_resp_13.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_13.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_13.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_13.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_13.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_13_allKeys.extend(theseKeys)
                if len(_key_resp_13_allKeys):
                    key_resp_13.keys = _key_resp_13_allKeys[-1].name  # just the last key pressed
                    key_resp_13.rt = _key_resp_13_allKeys[-1].rt
                    key_resp_13.duration = _key_resp_13_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_13.keys == str('left')) or (key_resp_13.keys == 'left'):
                        key_resp_13.corr = 1
                    else:
                        key_resp_13.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_2* updates
            
            # if LEFT_2 is starting this frame...
            if LEFT_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_2.frameNStart = frameN  # exact frame index
                LEFT_2.tStart = t  # local t and not account for scr refresh
                LEFT_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_2.started')
                # update status
                LEFT_2.status = STARTED
                LEFT_2.setAutoDraw(True)
            
            # if LEFT_2 is active this frame...
            if LEFT_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_3* updates
            
            # if whitesquare_3 is starting this frame...
            if whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_3.frameNStart = frameN  # exact frame index
                whitesquare_3.tStart = t  # local t and not account for scr refresh
                whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_3.started')
                # update status
                whitesquare_3.status = STARTED
                whitesquare_3.setAutoDraw(True)
            
            # if whitesquare_3 is active this frame...
            if whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if whitesquare_3 is stopping this frame...
            if whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_3.tStop = t  # not accounting for scr refresh
                    whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_3.stopped')
                    # update status
                    whitesquare_3.status = FINISHED
                    whitesquare_3.setAutoDraw(False)
            
            # *whitesquare_4* updates
            
            # if whitesquare_4 is starting this frame...
            if whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_4.frameNStart = frameN  # exact frame index
                whitesquare_4.tStart = t  # local t and not account for scr refresh
                whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_4.started')
                # update status
                whitesquare_4.status = STARTED
                whitesquare_4.setAutoDraw(True)
            
            # if whitesquare_4 is active this frame...
            if whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if whitesquare_4 is stopping this frame...
            if whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_4.tStop = t  # not accounting for scr refresh
                    whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_4.stopped')
                    # update status
                    whitesquare_4.status = FINISHED
                    whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_right" ---
        for thisComponent in LEFT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_right
        LEFT_on_right.tStop = globalClock.getTime(format='float')
        LEFT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_right.stopped', LEFT_on_right.tStop)
        # check responses
        if key_resp_13.keys in ['', [], None]:  # No response was made
            key_resp_13.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_13.corr = 1;  # correct non-response
            else:
               key_resp_13.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_13.keys',key_resp_13.keys)
        trials_b6.addData('key_resp_13.corr', key_resp_13.corr)
        if key_resp_13.keys != None:  # we had a response
            trials_b6.addData('key_resp_13.rt', key_resp_13.rt)
            trials_b6.addData('key_resp_13.duration', key_resp_13.duration)
        # the Routine "LEFT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_right" ---
        # create an object to store info about Routine RIGHT_on_right
        RIGHT_on_right = data.Routine(
            name='RIGHT_on_right',
            components=[blacksquare_11, white_cross_11, key_resp_14, RIGHT_3, whitesquare_10, whitesquare_17],
        )
        RIGHT_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_14
        key_resp_14.keys = []
        key_resp_14.rt = []
        _key_resp_14_allKeys = []
        # Run 'Begin Routine' code from code_12
        if currentRoutine != "RIGHT_on_right":
            continueRoutine = False
        
        # store start times for RIGHT_on_right
        RIGHT_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_right.tStart = globalClock.getTime(format='float')
        RIGHT_on_right.status = STARTED
        thisExp.addData('RIGHT_on_right.started', RIGHT_on_right.tStart)
        RIGHT_on_right.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_rightComponents = RIGHT_on_right.components
        for thisComponent in RIGHT_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_11* updates
            
            # if blacksquare_11 is starting this frame...
            if blacksquare_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_11.frameNStart = frameN  # exact frame index
                blacksquare_11.tStart = t  # local t and not account for scr refresh
                blacksquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_11.started')
                # update status
                blacksquare_11.status = STARTED
                blacksquare_11.setAutoDraw(True)
            
            # if blacksquare_11 is active this frame...
            if blacksquare_11.status == STARTED:
                # update params
                pass
            
            # *white_cross_11* updates
            
            # if white_cross_11 is starting this frame...
            if white_cross_11.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_11.frameNStart = frameN  # exact frame index
                white_cross_11.tStart = t  # local t and not account for scr refresh
                white_cross_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_11.started')
                # update status
                white_cross_11.status = STARTED
                white_cross_11.setAutoDraw(True)
            
            # if white_cross_11 is active this frame...
            if white_cross_11.status == STARTED:
                # update params
                pass
            
            # *key_resp_14* updates
            waitOnFlip = False
            
            # if key_resp_14 is starting this frame...
            if key_resp_14.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_14.frameNStart = frameN  # exact frame index
                key_resp_14.tStart = t  # local t and not account for scr refresh
                key_resp_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_14.started')
                # update status
                key_resp_14.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_14.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_14.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_14.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_14.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_14_allKeys.extend(theseKeys)
                if len(_key_resp_14_allKeys):
                    key_resp_14.keys = _key_resp_14_allKeys[-1].name  # just the last key pressed
                    key_resp_14.rt = _key_resp_14_allKeys[-1].rt
                    key_resp_14.duration = _key_resp_14_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_14.keys == str('left')) or (key_resp_14.keys == 'left'):
                        key_resp_14.corr = 1
                    else:
                        key_resp_14.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_3* updates
            
            # if RIGHT_3 is starting this frame...
            if RIGHT_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_3.frameNStart = frameN  # exact frame index
                RIGHT_3.tStart = t  # local t and not account for scr refresh
                RIGHT_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_3.started')
                # update status
                RIGHT_3.status = STARTED
                RIGHT_3.setAutoDraw(True)
            
            # if RIGHT_3 is active this frame...
            if RIGHT_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_10* updates
            
            # if whitesquare_10 is starting this frame...
            if whitesquare_10.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_10.frameNStart = frameN  # exact frame index
                whitesquare_10.tStart = t  # local t and not account for scr refresh
                whitesquare_10.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_10, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_10.started')
                # update status
                whitesquare_10.status = STARTED
                whitesquare_10.setAutoDraw(True)
            
            # if whitesquare_10 is active this frame...
            if whitesquare_10.status == STARTED:
                # update params
                pass
            
            # if whitesquare_10 is stopping this frame...
            if whitesquare_10.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_10.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_10.tStop = t  # not accounting for scr refresh
                    whitesquare_10.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_10.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_10.stopped')
                    # update status
                    whitesquare_10.status = FINISHED
                    whitesquare_10.setAutoDraw(False)
            
            # *whitesquare_17* updates
            
            # if whitesquare_17 is starting this frame...
            if whitesquare_17.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_17.frameNStart = frameN  # exact frame index
                whitesquare_17.tStart = t  # local t and not account for scr refresh
                whitesquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_17.started')
                # update status
                whitesquare_17.status = STARTED
                whitesquare_17.setAutoDraw(True)
            
            # if whitesquare_17 is active this frame...
            if whitesquare_17.status == STARTED:
                # update params
                pass
            
            # if whitesquare_17 is stopping this frame...
            if whitesquare_17.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_17.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_17.tStop = t  # not accounting for scr refresh
                    whitesquare_17.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_17.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_17.stopped')
                    # update status
                    whitesquare_17.status = FINISHED
                    whitesquare_17.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_right" ---
        for thisComponent in RIGHT_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_right
        RIGHT_on_right.tStop = globalClock.getTime(format='float')
        RIGHT_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_right.stopped', RIGHT_on_right.tStop)
        # check responses
        if key_resp_14.keys in ['', [], None]:  # No response was made
            key_resp_14.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_14.corr = 1;  # correct non-response
            else:
               key_resp_14.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_14.keys',key_resp_14.keys)
        trials_b6.addData('key_resp_14.corr', key_resp_14.corr)
        if key_resp_14.keys != None:  # we had a response
            trials_b6.addData('key_resp_14.rt', key_resp_14.rt)
            trials_b6.addData('key_resp_14.duration', key_resp_14.duration)
        # the Routine "RIGHT_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "LEFT_on_left" ---
        # create an object to store info about Routine LEFT_on_left
        LEFT_on_left = data.Routine(
            name='LEFT_on_left',
            components=[blacksquare_12, white_cross_12, key_resp_15, LEFT_4, whitesquare_6, whitesquare_13],
        )
        LEFT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_15
        key_resp_15.keys = []
        key_resp_15.rt = []
        _key_resp_15_allKeys = []
        # Run 'Begin Routine' code from code_8
        
        
        if currentRoutine != "LEFT_on_left":
            continueRoutine = False
        
        # store start times for LEFT_on_left
        LEFT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        LEFT_on_left.tStart = globalClock.getTime(format='float')
        LEFT_on_left.status = STARTED
        thisExp.addData('LEFT_on_left.started', LEFT_on_left.tStart)
        LEFT_on_left.maxDuration = None
        # keep track of which components have finished
        LEFT_on_leftComponents = LEFT_on_left.components
        for thisComponent in LEFT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "LEFT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        LEFT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_12* updates
            
            # if blacksquare_12 is starting this frame...
            if blacksquare_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_12.frameNStart = frameN  # exact frame index
                blacksquare_12.tStart = t  # local t and not account for scr refresh
                blacksquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_12.started')
                # update status
                blacksquare_12.status = STARTED
                blacksquare_12.setAutoDraw(True)
            
            # if blacksquare_12 is active this frame...
            if blacksquare_12.status == STARTED:
                # update params
                pass
            
            # *white_cross_12* updates
            
            # if white_cross_12 is starting this frame...
            if white_cross_12.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_12.frameNStart = frameN  # exact frame index
                white_cross_12.tStart = t  # local t and not account for scr refresh
                white_cross_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_12.started')
                # update status
                white_cross_12.status = STARTED
                white_cross_12.setAutoDraw(True)
            
            # if white_cross_12 is active this frame...
            if white_cross_12.status == STARTED:
                # update params
                pass
            
            # *key_resp_15* updates
            waitOnFlip = False
            
            # if key_resp_15 is starting this frame...
            if key_resp_15.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_15.frameNStart = frameN  # exact frame index
                key_resp_15.tStart = t  # local t and not account for scr refresh
                key_resp_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_15.started')
                # update status
                key_resp_15.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_15.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_15.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_15.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_15.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_15_allKeys.extend(theseKeys)
                if len(_key_resp_15_allKeys):
                    key_resp_15.keys = _key_resp_15_allKeys[-1].name  # just the last key pressed
                    key_resp_15.rt = _key_resp_15_allKeys[-1].rt
                    key_resp_15.duration = _key_resp_15_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_15.keys == str('left')) or (key_resp_15.keys == 'left'):
                        key_resp_15.corr = 1
                    else:
                        key_resp_15.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *LEFT_4* updates
            
            # if LEFT_4 is starting this frame...
            if LEFT_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                LEFT_4.frameNStart = frameN  # exact frame index
                LEFT_4.tStart = t  # local t and not account for scr refresh
                LEFT_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(LEFT_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'LEFT_4.started')
                # update status
                LEFT_4.status = STARTED
                LEFT_4.setAutoDraw(True)
            
            # if LEFT_4 is active this frame...
            if LEFT_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_6* updates
            
            # if whitesquare_6 is starting this frame...
            if whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_6.frameNStart = frameN  # exact frame index
                whitesquare_6.tStart = t  # local t and not account for scr refresh
                whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_6.started')
                # update status
                whitesquare_6.status = STARTED
                whitesquare_6.setAutoDraw(True)
            
            # if whitesquare_6 is active this frame...
            if whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if whitesquare_6 is stopping this frame...
            if whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_6.tStop = t  # not accounting for scr refresh
                    whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_6.stopped')
                    # update status
                    whitesquare_6.status = FINISHED
                    whitesquare_6.setAutoDraw(False)
            
            # *whitesquare_13* updates
            
            # if whitesquare_13 is starting this frame...
            if whitesquare_13.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_13.frameNStart = frameN  # exact frame index
                whitesquare_13.tStart = t  # local t and not account for scr refresh
                whitesquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_13.started')
                # update status
                whitesquare_13.status = STARTED
                whitesquare_13.setAutoDraw(True)
            
            # if whitesquare_13 is active this frame...
            if whitesquare_13.status == STARTED:
                # update params
                pass
            
            # if whitesquare_13 is stopping this frame...
            if whitesquare_13.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_13.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_13.tStop = t  # not accounting for scr refresh
                    whitesquare_13.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_13.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_13.stopped')
                    # update status
                    whitesquare_13.status = FINISHED
                    whitesquare_13.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                LEFT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in LEFT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "LEFT_on_left" ---
        for thisComponent in LEFT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for LEFT_on_left
        LEFT_on_left.tStop = globalClock.getTime(format='float')
        LEFT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('LEFT_on_left.stopped', LEFT_on_left.tStop)
        # check responses
        if key_resp_15.keys in ['', [], None]:  # No response was made
            key_resp_15.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_15.corr = 1;  # correct non-response
            else:
               key_resp_15.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_15.keys',key_resp_15.keys)
        trials_b6.addData('key_resp_15.corr', key_resp_15.corr)
        if key_resp_15.keys != None:  # we had a response
            trials_b6.addData('key_resp_15.rt', key_resp_15.rt)
            trials_b6.addData('key_resp_15.duration', key_resp_15.duration)
        # the Routine "LEFT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "RIGHT_on_left" ---
        # create an object to store info about Routine RIGHT_on_left
        RIGHT_on_left = data.Routine(
            name='RIGHT_on_left',
            components=[blacksquare_13, white_cross_13, key_resp_16, RIGHT_5, whitesquare_8, whitesquare_15],
        )
        RIGHT_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_16
        key_resp_16.keys = []
        key_resp_16.rt = []
        _key_resp_16_allKeys = []
        # Run 'Begin Routine' code from code_10
        
        if currentRoutine != "RIGHT_on_left":
            continueRoutine = False
        
        # store start times for RIGHT_on_left
        RIGHT_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        RIGHT_on_left.tStart = globalClock.getTime(format='float')
        RIGHT_on_left.status = STARTED
        thisExp.addData('RIGHT_on_left.started', RIGHT_on_left.tStart)
        RIGHT_on_left.maxDuration = None
        # keep track of which components have finished
        RIGHT_on_leftComponents = RIGHT_on_left.components
        for thisComponent in RIGHT_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "RIGHT_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        RIGHT_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_13* updates
            
            # if blacksquare_13 is starting this frame...
            if blacksquare_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_13.frameNStart = frameN  # exact frame index
                blacksquare_13.tStart = t  # local t and not account for scr refresh
                blacksquare_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_13.started')
                # update status
                blacksquare_13.status = STARTED
                blacksquare_13.setAutoDraw(True)
            
            # if blacksquare_13 is active this frame...
            if blacksquare_13.status == STARTED:
                # update params
                pass
            
            # *white_cross_13* updates
            
            # if white_cross_13 is starting this frame...
            if white_cross_13.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_13.frameNStart = frameN  # exact frame index
                white_cross_13.tStart = t  # local t and not account for scr refresh
                white_cross_13.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_13, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_13.started')
                # update status
                white_cross_13.status = STARTED
                white_cross_13.setAutoDraw(True)
            
            # if white_cross_13 is active this frame...
            if white_cross_13.status == STARTED:
                # update params
                pass
            
            # *key_resp_16* updates
            waitOnFlip = False
            
            # if key_resp_16 is starting this frame...
            if key_resp_16.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_16.frameNStart = frameN  # exact frame index
                key_resp_16.tStart = t  # local t and not account for scr refresh
                key_resp_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_16.started')
                # update status
                key_resp_16.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_16.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_16.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_16.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_16.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_16_allKeys.extend(theseKeys)
                if len(_key_resp_16_allKeys):
                    key_resp_16.keys = _key_resp_16_allKeys[-1].name  # just the last key pressed
                    key_resp_16.rt = _key_resp_16_allKeys[-1].rt
                    key_resp_16.duration = _key_resp_16_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_16.keys == str('left')) or (key_resp_16.keys == 'left'):
                        key_resp_16.corr = 1
                    else:
                        key_resp_16.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *RIGHT_5* updates
            
            # if RIGHT_5 is starting this frame...
            if RIGHT_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                RIGHT_5.frameNStart = frameN  # exact frame index
                RIGHT_5.tStart = t  # local t and not account for scr refresh
                RIGHT_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(RIGHT_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'RIGHT_5.started')
                # update status
                RIGHT_5.status = STARTED
                RIGHT_5.setAutoDraw(True)
            
            # if RIGHT_5 is active this frame...
            if RIGHT_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_8* updates
            
            # if whitesquare_8 is starting this frame...
            if whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_8.frameNStart = frameN  # exact frame index
                whitesquare_8.tStart = t  # local t and not account for scr refresh
                whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_8.started')
                # update status
                whitesquare_8.status = STARTED
                whitesquare_8.setAutoDraw(True)
            
            # if whitesquare_8 is active this frame...
            if whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if whitesquare_8 is stopping this frame...
            if whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_8.tStop = t  # not accounting for scr refresh
                    whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_8.stopped')
                    # update status
                    whitesquare_8.status = FINISHED
                    whitesquare_8.setAutoDraw(False)
            
            # *whitesquare_15* updates
            
            # if whitesquare_15 is starting this frame...
            if whitesquare_15.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_15.frameNStart = frameN  # exact frame index
                whitesquare_15.tStart = t  # local t and not account for scr refresh
                whitesquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_15.started')
                # update status
                whitesquare_15.status = STARTED
                whitesquare_15.setAutoDraw(True)
            
            # if whitesquare_15 is active this frame...
            if whitesquare_15.status == STARTED:
                # update params
                pass
            
            # if whitesquare_15 is stopping this frame...
            if whitesquare_15.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_15.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_15.tStop = t  # not accounting for scr refresh
                    whitesquare_15.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_15.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_15.stopped')
                    # update status
                    whitesquare_15.status = FINISHED
                    whitesquare_15.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                RIGHT_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in RIGHT_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "RIGHT_on_left" ---
        for thisComponent in RIGHT_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for RIGHT_on_left
        RIGHT_on_left.tStop = globalClock.getTime(format='float')
        RIGHT_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('RIGHT_on_left.stopped', RIGHT_on_left.tStop)
        # check responses
        if key_resp_16.keys in ['', [], None]:  # No response was made
            key_resp_16.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_16.corr = 1;  # correct non-response
            else:
               key_resp_16.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_16.keys',key_resp_16.keys)
        trials_b6.addData('key_resp_16.corr', key_resp_16.corr)
        if key_resp_16.keys != None:  # we had a response
            trials_b6.addData('key_resp_16.rt', key_resp_16.rt)
            trials_b6.addData('key_resp_16.duration', key_resp_16.duration)
        # the Routine "RIGHT_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_up" ---
        # create an object to store info about Routine UP_on_up
        UP_on_up = data.Routine(
            name='UP_on_up',
            components=[blacksquare_14, white_cross_14, key_resp_17, UP_5, up_whitesquare_2, down_whitesquare_2],
        )
        UP_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_17
        key_resp_17.keys = []
        key_resp_17.rt = []
        _key_resp_17_allKeys = []
        # Run 'Begin Routine' code from code_14
        
        if currentRoutine != "UP_on_up":
            continueRoutine = False
        
        # store start times for UP_on_up
        UP_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_up.tStart = globalClock.getTime(format='float')
        UP_on_up.status = STARTED
        thisExp.addData('UP_on_up.started', UP_on_up.tStart)
        UP_on_up.maxDuration = None
        # keep track of which components have finished
        UP_on_upComponents = UP_on_up.components
        for thisComponent in UP_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        UP_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_14* updates
            
            # if blacksquare_14 is starting this frame...
            if blacksquare_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_14.frameNStart = frameN  # exact frame index
                blacksquare_14.tStart = t  # local t and not account for scr refresh
                blacksquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_14.started')
                # update status
                blacksquare_14.status = STARTED
                blacksquare_14.setAutoDraw(True)
            
            # if blacksquare_14 is active this frame...
            if blacksquare_14.status == STARTED:
                # update params
                pass
            
            # *white_cross_14* updates
            
            # if white_cross_14 is starting this frame...
            if white_cross_14.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_14.frameNStart = frameN  # exact frame index
                white_cross_14.tStart = t  # local t and not account for scr refresh
                white_cross_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_14.started')
                # update status
                white_cross_14.status = STARTED
                white_cross_14.setAutoDraw(True)
            
            # if white_cross_14 is active this frame...
            if white_cross_14.status == STARTED:
                # update params
                pass
            
            # *key_resp_17* updates
            waitOnFlip = False
            
            # if key_resp_17 is starting this frame...
            if key_resp_17.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_17.frameNStart = frameN  # exact frame index
                key_resp_17.tStart = t  # local t and not account for scr refresh
                key_resp_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_17.started')
                # update status
                key_resp_17.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_17.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_17.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_17.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_17.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_17_allKeys.extend(theseKeys)
                if len(_key_resp_17_allKeys):
                    key_resp_17.keys = _key_resp_17_allKeys[-1].name  # just the last key pressed
                    key_resp_17.rt = _key_resp_17_allKeys[-1].rt
                    key_resp_17.duration = _key_resp_17_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_17.keys == str('left')) or (key_resp_17.keys == 'left'):
                        key_resp_17.corr = 1
                    else:
                        key_resp_17.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_5* updates
            
            # if UP_5 is starting this frame...
            if UP_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_5.frameNStart = frameN  # exact frame index
                UP_5.tStart = t  # local t and not account for scr refresh
                UP_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_5.started')
                # update status
                UP_5.status = STARTED
                UP_5.setAutoDraw(True)
            
            # if UP_5 is active this frame...
            if UP_5.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_2* updates
            
            # if up_whitesquare_2 is starting this frame...
            if up_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_2.frameNStart = frameN  # exact frame index
                up_whitesquare_2.tStart = t  # local t and not account for scr refresh
                up_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_2.started')
                # update status
                up_whitesquare_2.status = STARTED
                up_whitesquare_2.setAutoDraw(True)
            
            # if up_whitesquare_2 is active this frame...
            if up_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_2 is stopping this frame...
            if up_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_2.tStop = t  # not accounting for scr refresh
                    up_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_2.stopped')
                    # update status
                    up_whitesquare_2.status = FINISHED
                    up_whitesquare_2.setAutoDraw(False)
            
            # *down_whitesquare_2* updates
            
            # if down_whitesquare_2 is starting this frame...
            if down_whitesquare_2.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_2.frameNStart = frameN  # exact frame index
                down_whitesquare_2.tStart = t  # local t and not account for scr refresh
                down_whitesquare_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_2.started')
                # update status
                down_whitesquare_2.status = STARTED
                down_whitesquare_2.setAutoDraw(True)
            
            # if down_whitesquare_2 is active this frame...
            if down_whitesquare_2.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_2 is stopping this frame...
            if down_whitesquare_2.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_2.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_2.tStop = t  # not accounting for scr refresh
                    down_whitesquare_2.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_2.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_2.stopped')
                    # update status
                    down_whitesquare_2.status = FINISHED
                    down_whitesquare_2.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_up" ---
        for thisComponent in UP_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_up
        UP_on_up.tStop = globalClock.getTime(format='float')
        UP_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_up.stopped', UP_on_up.tStop)
        # check responses
        if key_resp_17.keys in ['', [], None]:  # No response was made
            key_resp_17.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_17.corr = 1;  # correct non-response
            else:
               key_resp_17.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_17.keys',key_resp_17.keys)
        trials_b6.addData('key_resp_17.corr', key_resp_17.corr)
        if key_resp_17.keys != None:  # we had a response
            trials_b6.addData('key_resp_17.rt', key_resp_17.rt)
            trials_b6.addData('key_resp_17.duration', key_resp_17.duration)
        # the Routine "UP_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_up" ---
        # create an object to store info about Routine DOWN_on_up
        DOWN_on_up = data.Routine(
            name='DOWN_on_up',
            components=[blacksquare_15, white_cross_15, key_resp_18, UP, up_whitesquare_4, down_whitesquare_4],
        )
        DOWN_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_18
        key_resp_18.keys = []
        key_resp_18.rt = []
        _key_resp_18_allKeys = []
        # Run 'Begin Routine' code from code_16
        
        
        if currentRoutine != "DOWN_on_up":
            continueRoutine = False
        
        # store start times for DOWN_on_up
        DOWN_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_up.tStart = globalClock.getTime(format='float')
        DOWN_on_up.status = STARTED
        thisExp.addData('DOWN_on_up.started', DOWN_on_up.tStart)
        DOWN_on_up.maxDuration = None
        # keep track of which components have finished
        DOWN_on_upComponents = DOWN_on_up.components
        for thisComponent in DOWN_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_15* updates
            
            # if blacksquare_15 is starting this frame...
            if blacksquare_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_15.frameNStart = frameN  # exact frame index
                blacksquare_15.tStart = t  # local t and not account for scr refresh
                blacksquare_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_15.started')
                # update status
                blacksquare_15.status = STARTED
                blacksquare_15.setAutoDraw(True)
            
            # if blacksquare_15 is active this frame...
            if blacksquare_15.status == STARTED:
                # update params
                pass
            
            # *white_cross_15* updates
            
            # if white_cross_15 is starting this frame...
            if white_cross_15.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_15.frameNStart = frameN  # exact frame index
                white_cross_15.tStart = t  # local t and not account for scr refresh
                white_cross_15.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_15, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_15.started')
                # update status
                white_cross_15.status = STARTED
                white_cross_15.setAutoDraw(True)
            
            # if white_cross_15 is active this frame...
            if white_cross_15.status == STARTED:
                # update params
                pass
            
            # *key_resp_18* updates
            waitOnFlip = False
            
            # if key_resp_18 is starting this frame...
            if key_resp_18.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_18.frameNStart = frameN  # exact frame index
                key_resp_18.tStart = t  # local t and not account for scr refresh
                key_resp_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_18.started')
                # update status
                key_resp_18.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_18.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_18.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_18.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_18.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_18_allKeys.extend(theseKeys)
                if len(_key_resp_18_allKeys):
                    key_resp_18.keys = _key_resp_18_allKeys[-1].name  # just the last key pressed
                    key_resp_18.rt = _key_resp_18_allKeys[-1].rt
                    key_resp_18.duration = _key_resp_18_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_18.keys == str('left')) or (key_resp_18.keys == 'left'):
                        key_resp_18.corr = 1
                    else:
                        key_resp_18.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP* updates
            
            # if UP is starting this frame...
            if UP.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP.frameNStart = frameN  # exact frame index
                UP.tStart = t  # local t and not account for scr refresh
                UP.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP.started')
                # update status
                UP.status = STARTED
                UP.setAutoDraw(True)
            
            # if UP is active this frame...
            if UP.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_4* updates
            
            # if up_whitesquare_4 is starting this frame...
            if up_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_4.frameNStart = frameN  # exact frame index
                up_whitesquare_4.tStart = t  # local t and not account for scr refresh
                up_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_4.started')
                # update status
                up_whitesquare_4.status = STARTED
                up_whitesquare_4.setAutoDraw(True)
            
            # if up_whitesquare_4 is active this frame...
            if up_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_4 is stopping this frame...
            if up_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_4.tStop = t  # not accounting for scr refresh
                    up_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_4.stopped')
                    # update status
                    up_whitesquare_4.status = FINISHED
                    up_whitesquare_4.setAutoDraw(False)
            
            # *down_whitesquare_4* updates
            
            # if down_whitesquare_4 is starting this frame...
            if down_whitesquare_4.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_4.frameNStart = frameN  # exact frame index
                down_whitesquare_4.tStart = t  # local t and not account for scr refresh
                down_whitesquare_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_4.started')
                # update status
                down_whitesquare_4.status = STARTED
                down_whitesquare_4.setAutoDraw(True)
            
            # if down_whitesquare_4 is active this frame...
            if down_whitesquare_4.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_4 is stopping this frame...
            if down_whitesquare_4.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_4.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_4.tStop = t  # not accounting for scr refresh
                    down_whitesquare_4.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_4.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_4.stopped')
                    # update status
                    down_whitesquare_4.status = FINISHED
                    down_whitesquare_4.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_up" ---
        for thisComponent in DOWN_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_up
        DOWN_on_up.tStop = globalClock.getTime(format='float')
        DOWN_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_up.stopped', DOWN_on_up.tStop)
        # check responses
        if key_resp_18.keys in ['', [], None]:  # No response was made
            key_resp_18.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_18.corr = 1;  # correct non-response
            else:
               key_resp_18.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_18.keys',key_resp_18.keys)
        trials_b6.addData('key_resp_18.corr', key_resp_18.corr)
        if key_resp_18.keys != None:  # we had a response
            trials_b6.addData('key_resp_18.rt', key_resp_18.rt)
            trials_b6.addData('key_resp_18.duration', key_resp_18.duration)
        # the Routine "DOWN_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "UP_on_down" ---
        # create an object to store info about Routine UP_on_down
        UP_on_down = data.Routine(
            name='UP_on_down',
            components=[blacksquare_16, white_cross_16, key_resp_19, UP_6, up_whitesquare_6, down_whitesquare_6],
        )
        UP_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_19
        key_resp_19.keys = []
        key_resp_19.rt = []
        _key_resp_19_allKeys = []
        # Run 'Begin Routine' code from code_18
        
        
        if currentRoutine != "UP_on_down":
            continueRoutine = False
        
        # store start times for UP_on_down
        UP_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        UP_on_down.tStart = globalClock.getTime(format='float')
        UP_on_down.status = STARTED
        thisExp.addData('UP_on_down.started', UP_on_down.tStart)
        UP_on_down.maxDuration = None
        # keep track of which components have finished
        UP_on_downComponents = UP_on_down.components
        for thisComponent in UP_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "UP_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        UP_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_16* updates
            
            # if blacksquare_16 is starting this frame...
            if blacksquare_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_16.frameNStart = frameN  # exact frame index
                blacksquare_16.tStart = t  # local t and not account for scr refresh
                blacksquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_16.started')
                # update status
                blacksquare_16.status = STARTED
                blacksquare_16.setAutoDraw(True)
            
            # if blacksquare_16 is active this frame...
            if blacksquare_16.status == STARTED:
                # update params
                pass
            
            # *white_cross_16* updates
            
            # if white_cross_16 is starting this frame...
            if white_cross_16.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_16.frameNStart = frameN  # exact frame index
                white_cross_16.tStart = t  # local t and not account for scr refresh
                white_cross_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_16.started')
                # update status
                white_cross_16.status = STARTED
                white_cross_16.setAutoDraw(True)
            
            # if white_cross_16 is active this frame...
            if white_cross_16.status == STARTED:
                # update params
                pass
            
            # *key_resp_19* updates
            waitOnFlip = False
            
            # if key_resp_19 is starting this frame...
            if key_resp_19.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_19.frameNStart = frameN  # exact frame index
                key_resp_19.tStart = t  # local t and not account for scr refresh
                key_resp_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_19.started')
                # update status
                key_resp_19.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_19.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_19.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_19.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_19.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_19_allKeys.extend(theseKeys)
                if len(_key_resp_19_allKeys):
                    key_resp_19.keys = _key_resp_19_allKeys[-1].name  # just the last key pressed
                    key_resp_19.rt = _key_resp_19_allKeys[-1].rt
                    key_resp_19.duration = _key_resp_19_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_19.keys == str('left')) or (key_resp_19.keys == 'left'):
                        key_resp_19.corr = 1
                    else:
                        key_resp_19.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_6* updates
            
            # if UP_6 is starting this frame...
            if UP_6.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_6.frameNStart = frameN  # exact frame index
                UP_6.tStart = t  # local t and not account for scr refresh
                UP_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_6.started')
                # update status
                UP_6.status = STARTED
                UP_6.setAutoDraw(True)
            
            # if UP_6 is active this frame...
            if UP_6.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_6* updates
            
            # if up_whitesquare_6 is starting this frame...
            if up_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_6.frameNStart = frameN  # exact frame index
                up_whitesquare_6.tStart = t  # local t and not account for scr refresh
                up_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_6.started')
                # update status
                up_whitesquare_6.status = STARTED
                up_whitesquare_6.setAutoDraw(True)
            
            # if up_whitesquare_6 is active this frame...
            if up_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_6 is stopping this frame...
            if up_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_6.tStop = t  # not accounting for scr refresh
                    up_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_6.stopped')
                    # update status
                    up_whitesquare_6.status = FINISHED
                    up_whitesquare_6.setAutoDraw(False)
            
            # *down_whitesquare_6* updates
            
            # if down_whitesquare_6 is starting this frame...
            if down_whitesquare_6.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_6.frameNStart = frameN  # exact frame index
                down_whitesquare_6.tStart = t  # local t and not account for scr refresh
                down_whitesquare_6.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_6, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_6.started')
                # update status
                down_whitesquare_6.status = STARTED
                down_whitesquare_6.setAutoDraw(True)
            
            # if down_whitesquare_6 is active this frame...
            if down_whitesquare_6.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_6 is stopping this frame...
            if down_whitesquare_6.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_6.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_6.tStop = t  # not accounting for scr refresh
                    down_whitesquare_6.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_6.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_6.stopped')
                    # update status
                    down_whitesquare_6.status = FINISHED
                    down_whitesquare_6.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                UP_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in UP_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "UP_on_down" ---
        for thisComponent in UP_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for UP_on_down
        UP_on_down.tStop = globalClock.getTime(format='float')
        UP_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('UP_on_down.stopped', UP_on_down.tStop)
        # check responses
        if key_resp_19.keys in ['', [], None]:  # No response was made
            key_resp_19.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_19.corr = 1;  # correct non-response
            else:
               key_resp_19.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_19.keys',key_resp_19.keys)
        trials_b6.addData('key_resp_19.corr', key_resp_19.corr)
        if key_resp_19.keys != None:  # we had a response
            trials_b6.addData('key_resp_19.rt', key_resp_19.rt)
            trials_b6.addData('key_resp_19.duration', key_resp_19.duration)
        # the Routine "UP_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "DOWN_on_down" ---
        # create an object to store info about Routine DOWN_on_down
        DOWN_on_down = data.Routine(
            name='DOWN_on_down',
            components=[blacksquare_17, white_cross_17, key_resp_20, UP_7, up_whitesquare_8, down_whitesquare_8],
        )
        DOWN_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_20
        key_resp_20.keys = []
        key_resp_20.rt = []
        _key_resp_20_allKeys = []
        # Run 'Begin Routine' code from code_20
        
        
        if currentRoutine != "DOWN_on_down":
            continueRoutine = False
        
        # store start times for DOWN_on_down
        DOWN_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        DOWN_on_down.tStart = globalClock.getTime(format='float')
        DOWN_on_down.status = STARTED
        thisExp.addData('DOWN_on_down.started', DOWN_on_down.tStart)
        DOWN_on_down.maxDuration = None
        # keep track of which components have finished
        DOWN_on_downComponents = DOWN_on_down.components
        for thisComponent in DOWN_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "DOWN_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        DOWN_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_17* updates
            
            # if blacksquare_17 is starting this frame...
            if blacksquare_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_17.frameNStart = frameN  # exact frame index
                blacksquare_17.tStart = t  # local t and not account for scr refresh
                blacksquare_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_17.started')
                # update status
                blacksquare_17.status = STARTED
                blacksquare_17.setAutoDraw(True)
            
            # if blacksquare_17 is active this frame...
            if blacksquare_17.status == STARTED:
                # update params
                pass
            
            # *white_cross_17* updates
            
            # if white_cross_17 is starting this frame...
            if white_cross_17.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_17.frameNStart = frameN  # exact frame index
                white_cross_17.tStart = t  # local t and not account for scr refresh
                white_cross_17.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_17, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_17.started')
                # update status
                white_cross_17.status = STARTED
                white_cross_17.setAutoDraw(True)
            
            # if white_cross_17 is active this frame...
            if white_cross_17.status == STARTED:
                # update params
                pass
            
            # *key_resp_20* updates
            waitOnFlip = False
            
            # if key_resp_20 is starting this frame...
            if key_resp_20.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_20.frameNStart = frameN  # exact frame index
                key_resp_20.tStart = t  # local t and not account for scr refresh
                key_resp_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_20.started')
                # update status
                key_resp_20.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_20.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_20.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_20.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_20.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_20_allKeys.extend(theseKeys)
                if len(_key_resp_20_allKeys):
                    key_resp_20.keys = _key_resp_20_allKeys[-1].name  # just the last key pressed
                    key_resp_20.rt = _key_resp_20_allKeys[-1].rt
                    key_resp_20.duration = _key_resp_20_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_20.keys == str('left')) or (key_resp_20.keys == 'left'):
                        key_resp_20.corr = 1
                    else:
                        key_resp_20.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *UP_7* updates
            
            # if UP_7 is starting this frame...
            if UP_7.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                UP_7.frameNStart = frameN  # exact frame index
                UP_7.tStart = t  # local t and not account for scr refresh
                UP_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(UP_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'UP_7.started')
                # update status
                UP_7.status = STARTED
                UP_7.setAutoDraw(True)
            
            # if UP_7 is active this frame...
            if UP_7.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_8* updates
            
            # if up_whitesquare_8 is starting this frame...
            if up_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_8.frameNStart = frameN  # exact frame index
                up_whitesquare_8.tStart = t  # local t and not account for scr refresh
                up_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_8.started')
                # update status
                up_whitesquare_8.status = STARTED
                up_whitesquare_8.setAutoDraw(True)
            
            # if up_whitesquare_8 is active this frame...
            if up_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_8 is stopping this frame...
            if up_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_8.tStop = t  # not accounting for scr refresh
                    up_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_8.stopped')
                    # update status
                    up_whitesquare_8.status = FINISHED
                    up_whitesquare_8.setAutoDraw(False)
            
            # *down_whitesquare_8* updates
            
            # if down_whitesquare_8 is starting this frame...
            if down_whitesquare_8.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_8.frameNStart = frameN  # exact frame index
                down_whitesquare_8.tStart = t  # local t and not account for scr refresh
                down_whitesquare_8.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_8, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_8.started')
                # update status
                down_whitesquare_8.status = STARTED
                down_whitesquare_8.setAutoDraw(True)
            
            # if down_whitesquare_8 is active this frame...
            if down_whitesquare_8.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_8 is stopping this frame...
            if down_whitesquare_8.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_8.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_8.tStop = t  # not accounting for scr refresh
                    down_whitesquare_8.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_8.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_8.stopped')
                    # update status
                    down_whitesquare_8.status = FINISHED
                    down_whitesquare_8.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                DOWN_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in DOWN_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "DOWN_on_down" ---
        for thisComponent in DOWN_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for DOWN_on_down
        DOWN_on_down.tStop = globalClock.getTime(format='float')
        DOWN_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('DOWN_on_down.stopped', DOWN_on_down.tStop)
        # check responses
        if key_resp_20.keys in ['', [], None]:  # No response was made
            key_resp_20.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_20.corr = 1;  # correct non-response
            else:
               key_resp_20.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_20.keys',key_resp_20.keys)
        trials_b6.addData('key_resp_20.corr', key_resp_20.corr)
        if key_resp_20.keys != None:  # we had a response
            trials_b6.addData('key_resp_20.rt', key_resp_20.rt)
            trials_b6.addData('key_resp_20.duration', key_resp_20.duration)
        # the Routine "DOWN_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_right" ---
        # create an object to store info about Routine leftA_on_right
        leftA_on_right = data.Routine(
            name='leftA_on_right',
            components=[blacksquare_18, white_cross_18, key_resp_21, arrow_l_2, whitesquare_5, whitesquare_12],
        )
        leftA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_21
        key_resp_21.keys = []
        key_resp_21.rt = []
        _key_resp_21_allKeys = []
        # Run 'Begin Routine' code from code_7
        
        
        if currentRoutine != "leftA_on_right":
            continueRoutine = False
        
        # store start times for leftA_on_right
        leftA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_right.tStart = globalClock.getTime(format='float')
        leftA_on_right.status = STARTED
        thisExp.addData('leftA_on_right.started', leftA_on_right.tStart)
        leftA_on_right.maxDuration = None
        # keep track of which components have finished
        leftA_on_rightComponents = leftA_on_right.components
        for thisComponent in leftA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        leftA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_18* updates
            
            # if blacksquare_18 is starting this frame...
            if blacksquare_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_18.frameNStart = frameN  # exact frame index
                blacksquare_18.tStart = t  # local t and not account for scr refresh
                blacksquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_18.started')
                # update status
                blacksquare_18.status = STARTED
                blacksquare_18.setAutoDraw(True)
            
            # if blacksquare_18 is active this frame...
            if blacksquare_18.status == STARTED:
                # update params
                pass
            
            # *white_cross_18* updates
            
            # if white_cross_18 is starting this frame...
            if white_cross_18.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_18.frameNStart = frameN  # exact frame index
                white_cross_18.tStart = t  # local t and not account for scr refresh
                white_cross_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_18.started')
                # update status
                white_cross_18.status = STARTED
                white_cross_18.setAutoDraw(True)
            
            # if white_cross_18 is active this frame...
            if white_cross_18.status == STARTED:
                # update params
                pass
            
            # *key_resp_21* updates
            waitOnFlip = False
            
            # if key_resp_21 is starting this frame...
            if key_resp_21.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_21.frameNStart = frameN  # exact frame index
                key_resp_21.tStart = t  # local t and not account for scr refresh
                key_resp_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_21.started')
                # update status
                key_resp_21.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_21.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_21.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_21.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_21.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_21_allKeys.extend(theseKeys)
                if len(_key_resp_21_allKeys):
                    key_resp_21.keys = _key_resp_21_allKeys[-1].name  # just the last key pressed
                    key_resp_21.rt = _key_resp_21_allKeys[-1].rt
                    key_resp_21.duration = _key_resp_21_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_21.keys == str('left')) or (key_resp_21.keys == 'left'):
                        key_resp_21.corr = 1
                    else:
                        key_resp_21.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_2* updates
            
            # if arrow_l_2 is starting this frame...
            if arrow_l_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_2.frameNStart = frameN  # exact frame index
                arrow_l_2.tStart = t  # local t and not account for scr refresh
                arrow_l_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_2.started')
                # update status
                arrow_l_2.status = STARTED
                arrow_l_2.setAutoDraw(True)
            
            # if arrow_l_2 is active this frame...
            if arrow_l_2.status == STARTED:
                # update params
                pass
            
            # *whitesquare_5* updates
            
            # if whitesquare_5 is starting this frame...
            if whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_5.frameNStart = frameN  # exact frame index
                whitesquare_5.tStart = t  # local t and not account for scr refresh
                whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_5.started')
                # update status
                whitesquare_5.status = STARTED
                whitesquare_5.setAutoDraw(True)
            
            # if whitesquare_5 is active this frame...
            if whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if whitesquare_5 is stopping this frame...
            if whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_5.tStop = t  # not accounting for scr refresh
                    whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_5.stopped')
                    # update status
                    whitesquare_5.status = FINISHED
                    whitesquare_5.setAutoDraw(False)
            
            # *whitesquare_12* updates
            
            # if whitesquare_12 is starting this frame...
            if whitesquare_12.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_12.frameNStart = frameN  # exact frame index
                whitesquare_12.tStart = t  # local t and not account for scr refresh
                whitesquare_12.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_12, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_12.started')
                # update status
                whitesquare_12.status = STARTED
                whitesquare_12.setAutoDraw(True)
            
            # if whitesquare_12 is active this frame...
            if whitesquare_12.status == STARTED:
                # update params
                pass
            
            # if whitesquare_12 is stopping this frame...
            if whitesquare_12.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_12.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_12.tStop = t  # not accounting for scr refresh
                    whitesquare_12.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_12.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_12.stopped')
                    # update status
                    whitesquare_12.status = FINISHED
                    whitesquare_12.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_right" ---
        for thisComponent in leftA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_right
        leftA_on_right.tStop = globalClock.getTime(format='float')
        leftA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_right.stopped', leftA_on_right.tStop)
        # check responses
        if key_resp_21.keys in ['', [], None]:  # No response was made
            key_resp_21.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_21.corr = 1;  # correct non-response
            else:
               key_resp_21.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_21.keys',key_resp_21.keys)
        trials_b6.addData('key_resp_21.corr', key_resp_21.corr)
        if key_resp_21.keys != None:  # we had a response
            trials_b6.addData('key_resp_21.rt', key_resp_21.rt)
            trials_b6.addData('key_resp_21.duration', key_resp_21.duration)
        # the Routine "leftA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "leftA_on_left" ---
        # create an object to store info about Routine leftA_on_left
        leftA_on_left = data.Routine(
            name='leftA_on_left',
            components=[blacksquare_19, white_cross_19, key_resp_22, arrow_l_3, whitesquare_7, whitesquare_14],
        )
        leftA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_22
        key_resp_22.keys = []
        key_resp_22.rt = []
        _key_resp_22_allKeys = []
        # Run 'Begin Routine' code from code_9
        
        
        if currentRoutine != "leftA_on_left":
            continueRoutine = False
        
        # store start times for leftA_on_left
        leftA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        leftA_on_left.tStart = globalClock.getTime(format='float')
        leftA_on_left.status = STARTED
        thisExp.addData('leftA_on_left.started', leftA_on_left.tStart)
        leftA_on_left.maxDuration = None
        # keep track of which components have finished
        leftA_on_leftComponents = leftA_on_left.components
        for thisComponent in leftA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "leftA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        leftA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_19* updates
            
            # if blacksquare_19 is starting this frame...
            if blacksquare_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_19.frameNStart = frameN  # exact frame index
                blacksquare_19.tStart = t  # local t and not account for scr refresh
                blacksquare_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_19.started')
                # update status
                blacksquare_19.status = STARTED
                blacksquare_19.setAutoDraw(True)
            
            # if blacksquare_19 is active this frame...
            if blacksquare_19.status == STARTED:
                # update params
                pass
            
            # *white_cross_19* updates
            
            # if white_cross_19 is starting this frame...
            if white_cross_19.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_19.frameNStart = frameN  # exact frame index
                white_cross_19.tStart = t  # local t and not account for scr refresh
                white_cross_19.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_19, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_19.started')
                # update status
                white_cross_19.status = STARTED
                white_cross_19.setAutoDraw(True)
            
            # if white_cross_19 is active this frame...
            if white_cross_19.status == STARTED:
                # update params
                pass
            
            # *key_resp_22* updates
            waitOnFlip = False
            
            # if key_resp_22 is starting this frame...
            if key_resp_22.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_22.frameNStart = frameN  # exact frame index
                key_resp_22.tStart = t  # local t and not account for scr refresh
                key_resp_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_22.started')
                # update status
                key_resp_22.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_22.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_22.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_22.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_22.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_22_allKeys.extend(theseKeys)
                if len(_key_resp_22_allKeys):
                    key_resp_22.keys = _key_resp_22_allKeys[-1].name  # just the last key pressed
                    key_resp_22.rt = _key_resp_22_allKeys[-1].rt
                    key_resp_22.duration = _key_resp_22_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_22.keys == str('left')) or (key_resp_22.keys == 'left'):
                        key_resp_22.corr = 1
                    else:
                        key_resp_22.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_3* updates
            
            # if arrow_l_3 is starting this frame...
            if arrow_l_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_3.frameNStart = frameN  # exact frame index
                arrow_l_3.tStart = t  # local t and not account for scr refresh
                arrow_l_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_3.started')
                # update status
                arrow_l_3.status = STARTED
                arrow_l_3.setAutoDraw(True)
            
            # if arrow_l_3 is active this frame...
            if arrow_l_3.status == STARTED:
                # update params
                pass
            
            # *whitesquare_7* updates
            
            # if whitesquare_7 is starting this frame...
            if whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_7.frameNStart = frameN  # exact frame index
                whitesquare_7.tStart = t  # local t and not account for scr refresh
                whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_7.started')
                # update status
                whitesquare_7.status = STARTED
                whitesquare_7.setAutoDraw(True)
            
            # if whitesquare_7 is active this frame...
            if whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if whitesquare_7 is stopping this frame...
            if whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_7.tStop = t  # not accounting for scr refresh
                    whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_7.stopped')
                    # update status
                    whitesquare_7.status = FINISHED
                    whitesquare_7.setAutoDraw(False)
            
            # *whitesquare_14* updates
            
            # if whitesquare_14 is starting this frame...
            if whitesquare_14.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_14.frameNStart = frameN  # exact frame index
                whitesquare_14.tStart = t  # local t and not account for scr refresh
                whitesquare_14.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_14, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_14.started')
                # update status
                whitesquare_14.status = STARTED
                whitesquare_14.setAutoDraw(True)
            
            # if whitesquare_14 is active this frame...
            if whitesquare_14.status == STARTED:
                # update params
                pass
            
            # if whitesquare_14 is stopping this frame...
            if whitesquare_14.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_14.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_14.tStop = t  # not accounting for scr refresh
                    whitesquare_14.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_14.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_14.stopped')
                    # update status
                    whitesquare_14.status = FINISHED
                    whitesquare_14.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                leftA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in leftA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "leftA_on_left" ---
        for thisComponent in leftA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for leftA_on_left
        leftA_on_left.tStop = globalClock.getTime(format='float')
        leftA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('leftA_on_left.stopped', leftA_on_left.tStop)
        # check responses
        if key_resp_22.keys in ['', [], None]:  # No response was made
            key_resp_22.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_22.corr = 1;  # correct non-response
            else:
               key_resp_22.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_22.keys',key_resp_22.keys)
        trials_b6.addData('key_resp_22.corr', key_resp_22.corr)
        if key_resp_22.keys != None:  # we had a response
            trials_b6.addData('key_resp_22.rt', key_resp_22.rt)
            trials_b6.addData('key_resp_22.duration', key_resp_22.duration)
        # the Routine "leftA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_right" ---
        # create an object to store info about Routine rightA_on_right
        rightA_on_right = data.Routine(
            name='rightA_on_right',
            components=[blacksquare_20, white_cross_20, key_resp_23, arrow_l_4, whitesquare_11, whitesquare_18],
        )
        rightA_on_right.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_23
        key_resp_23.keys = []
        key_resp_23.rt = []
        _key_resp_23_allKeys = []
        # Run 'Begin Routine' code from code_13
        
        
        if currentRoutine != "rightA_on_right":
            continueRoutine = False
        
        # store start times for rightA_on_right
        rightA_on_right.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_right.tStart = globalClock.getTime(format='float')
        rightA_on_right.status = STARTED
        thisExp.addData('rightA_on_right.started', rightA_on_right.tStart)
        rightA_on_right.maxDuration = None
        # keep track of which components have finished
        rightA_on_rightComponents = rightA_on_right.components
        for thisComponent in rightA_on_right.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_right" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        rightA_on_right.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_20* updates
            
            # if blacksquare_20 is starting this frame...
            if blacksquare_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_20.frameNStart = frameN  # exact frame index
                blacksquare_20.tStart = t  # local t and not account for scr refresh
                blacksquare_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_20.started')
                # update status
                blacksquare_20.status = STARTED
                blacksquare_20.setAutoDraw(True)
            
            # if blacksquare_20 is active this frame...
            if blacksquare_20.status == STARTED:
                # update params
                pass
            
            # *white_cross_20* updates
            
            # if white_cross_20 is starting this frame...
            if white_cross_20.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_20.frameNStart = frameN  # exact frame index
                white_cross_20.tStart = t  # local t and not account for scr refresh
                white_cross_20.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_20, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_20.started')
                # update status
                white_cross_20.status = STARTED
                white_cross_20.setAutoDraw(True)
            
            # if white_cross_20 is active this frame...
            if white_cross_20.status == STARTED:
                # update params
                pass
            
            # *key_resp_23* updates
            waitOnFlip = False
            
            # if key_resp_23 is starting this frame...
            if key_resp_23.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_23.frameNStart = frameN  # exact frame index
                key_resp_23.tStart = t  # local t and not account for scr refresh
                key_resp_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_23.started')
                # update status
                key_resp_23.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_23.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_23.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_23.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_23.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_23_allKeys.extend(theseKeys)
                if len(_key_resp_23_allKeys):
                    key_resp_23.keys = _key_resp_23_allKeys[-1].name  # just the last key pressed
                    key_resp_23.rt = _key_resp_23_allKeys[-1].rt
                    key_resp_23.duration = _key_resp_23_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_23.keys == str('left')) or (key_resp_23.keys == 'left'):
                        key_resp_23.corr = 1
                    else:
                        key_resp_23.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_4* updates
            
            # if arrow_l_4 is starting this frame...
            if arrow_l_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_4.frameNStart = frameN  # exact frame index
                arrow_l_4.tStart = t  # local t and not account for scr refresh
                arrow_l_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_4.started')
                # update status
                arrow_l_4.status = STARTED
                arrow_l_4.setAutoDraw(True)
            
            # if arrow_l_4 is active this frame...
            if arrow_l_4.status == STARTED:
                # update params
                pass
            
            # *whitesquare_11* updates
            
            # if whitesquare_11 is starting this frame...
            if whitesquare_11.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_11.frameNStart = frameN  # exact frame index
                whitesquare_11.tStart = t  # local t and not account for scr refresh
                whitesquare_11.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_11, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_11.started')
                # update status
                whitesquare_11.status = STARTED
                whitesquare_11.setAutoDraw(True)
            
            # if whitesquare_11 is active this frame...
            if whitesquare_11.status == STARTED:
                # update params
                pass
            
            # if whitesquare_11 is stopping this frame...
            if whitesquare_11.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_11.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_11.tStop = t  # not accounting for scr refresh
                    whitesquare_11.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_11.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_11.stopped')
                    # update status
                    whitesquare_11.status = FINISHED
                    whitesquare_11.setAutoDraw(False)
            
            # *whitesquare_18* updates
            
            # if whitesquare_18 is starting this frame...
            if whitesquare_18.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_18.frameNStart = frameN  # exact frame index
                whitesquare_18.tStart = t  # local t and not account for scr refresh
                whitesquare_18.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_18, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_18.started')
                # update status
                whitesquare_18.status = STARTED
                whitesquare_18.setAutoDraw(True)
            
            # if whitesquare_18 is active this frame...
            if whitesquare_18.status == STARTED:
                # update params
                pass
            
            # if whitesquare_18 is stopping this frame...
            if whitesquare_18.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_18.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_18.tStop = t  # not accounting for scr refresh
                    whitesquare_18.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_18.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_18.stopped')
                    # update status
                    whitesquare_18.status = FINISHED
                    whitesquare_18.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_right.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_right.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_right" ---
        for thisComponent in rightA_on_right.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_right
        rightA_on_right.tStop = globalClock.getTime(format='float')
        rightA_on_right.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_right.stopped', rightA_on_right.tStop)
        # check responses
        if key_resp_23.keys in ['', [], None]:  # No response was made
            key_resp_23.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_23.corr = 1;  # correct non-response
            else:
               key_resp_23.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_23.keys',key_resp_23.keys)
        trials_b6.addData('key_resp_23.corr', key_resp_23.corr)
        if key_resp_23.keys != None:  # we had a response
            trials_b6.addData('key_resp_23.rt', key_resp_23.rt)
            trials_b6.addData('key_resp_23.duration', key_resp_23.duration)
        # the Routine "rightA_on_right" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "rightA_on_left" ---
        # create an object to store info about Routine rightA_on_left
        rightA_on_left = data.Routine(
            name='rightA_on_left',
            components=[blacksquare_21, white_cross_21, key_resp_24, arrow_l_5, whitesquare_9, whitesquare_16],
        )
        rightA_on_left.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_24
        key_resp_24.keys = []
        key_resp_24.rt = []
        _key_resp_24_allKeys = []
        # Run 'Begin Routine' code from code_11
        
        
        if currentRoutine != "rightA_on_left":
            continueRoutine = False
        
        # store start times for rightA_on_left
        rightA_on_left.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        rightA_on_left.tStart = globalClock.getTime(format='float')
        rightA_on_left.status = STARTED
        thisExp.addData('rightA_on_left.started', rightA_on_left.tStart)
        rightA_on_left.maxDuration = None
        # keep track of which components have finished
        rightA_on_leftComponents = rightA_on_left.components
        for thisComponent in rightA_on_left.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "rightA_on_left" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        rightA_on_left.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_21* updates
            
            # if blacksquare_21 is starting this frame...
            if blacksquare_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_21.frameNStart = frameN  # exact frame index
                blacksquare_21.tStart = t  # local t and not account for scr refresh
                blacksquare_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_21.started')
                # update status
                blacksquare_21.status = STARTED
                blacksquare_21.setAutoDraw(True)
            
            # if blacksquare_21 is active this frame...
            if blacksquare_21.status == STARTED:
                # update params
                pass
            
            # *white_cross_21* updates
            
            # if white_cross_21 is starting this frame...
            if white_cross_21.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_21.frameNStart = frameN  # exact frame index
                white_cross_21.tStart = t  # local t and not account for scr refresh
                white_cross_21.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_21, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_21.started')
                # update status
                white_cross_21.status = STARTED
                white_cross_21.setAutoDraw(True)
            
            # if white_cross_21 is active this frame...
            if white_cross_21.status == STARTED:
                # update params
                pass
            
            # *key_resp_24* updates
            waitOnFlip = False
            
            # if key_resp_24 is starting this frame...
            if key_resp_24.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_24.frameNStart = frameN  # exact frame index
                key_resp_24.tStart = t  # local t and not account for scr refresh
                key_resp_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_24.started')
                # update status
                key_resp_24.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_24.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_24.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_24.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_24.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_24_allKeys.extend(theseKeys)
                if len(_key_resp_24_allKeys):
                    key_resp_24.keys = _key_resp_24_allKeys[-1].name  # just the last key pressed
                    key_resp_24.rt = _key_resp_24_allKeys[-1].rt
                    key_resp_24.duration = _key_resp_24_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_24.keys == str('left')) or (key_resp_24.keys == 'left'):
                        key_resp_24.corr = 1
                    else:
                        key_resp_24.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_l_5* updates
            
            # if arrow_l_5 is starting this frame...
            if arrow_l_5.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_l_5.frameNStart = frameN  # exact frame index
                arrow_l_5.tStart = t  # local t and not account for scr refresh
                arrow_l_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_l_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_l_5.started')
                # update status
                arrow_l_5.status = STARTED
                arrow_l_5.setAutoDraw(True)
            
            # if arrow_l_5 is active this frame...
            if arrow_l_5.status == STARTED:
                # update params
                pass
            
            # *whitesquare_9* updates
            
            # if whitesquare_9 is starting this frame...
            if whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_9.frameNStart = frameN  # exact frame index
                whitesquare_9.tStart = t  # local t and not account for scr refresh
                whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_9.started')
                # update status
                whitesquare_9.status = STARTED
                whitesquare_9.setAutoDraw(True)
            
            # if whitesquare_9 is active this frame...
            if whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if whitesquare_9 is stopping this frame...
            if whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_9.tStop = t  # not accounting for scr refresh
                    whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_9.stopped')
                    # update status
                    whitesquare_9.status = FINISHED
                    whitesquare_9.setAutoDraw(False)
            
            # *whitesquare_16* updates
            
            # if whitesquare_16 is starting this frame...
            if whitesquare_16.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                whitesquare_16.frameNStart = frameN  # exact frame index
                whitesquare_16.tStart = t  # local t and not account for scr refresh
                whitesquare_16.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(whitesquare_16, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'whitesquare_16.started')
                # update status
                whitesquare_16.status = STARTED
                whitesquare_16.setAutoDraw(True)
            
            # if whitesquare_16 is active this frame...
            if whitesquare_16.status == STARTED:
                # update params
                pass
            
            # if whitesquare_16 is stopping this frame...
            if whitesquare_16.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > whitesquare_16.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    whitesquare_16.tStop = t  # not accounting for scr refresh
                    whitesquare_16.tStopRefresh = tThisFlipGlobal  # on global time
                    whitesquare_16.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'whitesquare_16.stopped')
                    # update status
                    whitesquare_16.status = FINISHED
                    whitesquare_16.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                rightA_on_left.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in rightA_on_left.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "rightA_on_left" ---
        for thisComponent in rightA_on_left.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for rightA_on_left
        rightA_on_left.tStop = globalClock.getTime(format='float')
        rightA_on_left.tStopRefresh = tThisFlipGlobal
        thisExp.addData('rightA_on_left.stopped', rightA_on_left.tStop)
        # check responses
        if key_resp_24.keys in ['', [], None]:  # No response was made
            key_resp_24.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_24.corr = 1;  # correct non-response
            else:
               key_resp_24.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_24.keys',key_resp_24.keys)
        trials_b6.addData('key_resp_24.corr', key_resp_24.corr)
        if key_resp_24.keys != None:  # we had a response
            trials_b6.addData('key_resp_24.rt', key_resp_24.rt)
            trials_b6.addData('key_resp_24.duration', key_resp_24.duration)
        # the Routine "rightA_on_left" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_up" ---
        # create an object to store info about Routine upA_on_up
        upA_on_up = data.Routine(
            name='upA_on_up',
            components=[blacksquare_22, white_cross_22, key_resp_25, arrow_u, up_whitesquare_3, down_whitesquare_3],
        )
        upA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_25
        key_resp_25.keys = []
        key_resp_25.rt = []
        _key_resp_25_allKeys = []
        # Run 'Begin Routine' code from code_15
        
        
        if currentRoutine != "upA_on_up":
            continueRoutine = False
        
        # store start times for upA_on_up
        upA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_up.tStart = globalClock.getTime(format='float')
        upA_on_up.status = STARTED
        thisExp.addData('upA_on_up.started', upA_on_up.tStart)
        upA_on_up.maxDuration = None
        # keep track of which components have finished
        upA_on_upComponents = upA_on_up.components
        for thisComponent in upA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        upA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_22* updates
            
            # if blacksquare_22 is starting this frame...
            if blacksquare_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_22.frameNStart = frameN  # exact frame index
                blacksquare_22.tStart = t  # local t and not account for scr refresh
                blacksquare_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_22.started')
                # update status
                blacksquare_22.status = STARTED
                blacksquare_22.setAutoDraw(True)
            
            # if blacksquare_22 is active this frame...
            if blacksquare_22.status == STARTED:
                # update params
                pass
            
            # *white_cross_22* updates
            
            # if white_cross_22 is starting this frame...
            if white_cross_22.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_22.frameNStart = frameN  # exact frame index
                white_cross_22.tStart = t  # local t and not account for scr refresh
                white_cross_22.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_22, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_22.started')
                # update status
                white_cross_22.status = STARTED
                white_cross_22.setAutoDraw(True)
            
            # if white_cross_22 is active this frame...
            if white_cross_22.status == STARTED:
                # update params
                pass
            
            # *key_resp_25* updates
            waitOnFlip = False
            
            # if key_resp_25 is starting this frame...
            if key_resp_25.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_25.frameNStart = frameN  # exact frame index
                key_resp_25.tStart = t  # local t and not account for scr refresh
                key_resp_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_25.started')
                # update status
                key_resp_25.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_25.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_25.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_25.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_25.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_25_allKeys.extend(theseKeys)
                if len(_key_resp_25_allKeys):
                    key_resp_25.keys = _key_resp_25_allKeys[-1].name  # just the last key pressed
                    key_resp_25.rt = _key_resp_25_allKeys[-1].rt
                    key_resp_25.duration = _key_resp_25_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_25.keys == str('left')) or (key_resp_25.keys == 'left'):
                        key_resp_25.corr = 1
                    else:
                        key_resp_25.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u* updates
            
            # if arrow_u is starting this frame...
            if arrow_u.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u.frameNStart = frameN  # exact frame index
                arrow_u.tStart = t  # local t and not account for scr refresh
                arrow_u.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u.started')
                # update status
                arrow_u.status = STARTED
                arrow_u.setAutoDraw(True)
            
            # if arrow_u is active this frame...
            if arrow_u.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_3* updates
            
            # if up_whitesquare_3 is starting this frame...
            if up_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_3.frameNStart = frameN  # exact frame index
                up_whitesquare_3.tStart = t  # local t and not account for scr refresh
                up_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_3.started')
                # update status
                up_whitesquare_3.status = STARTED
                up_whitesquare_3.setAutoDraw(True)
            
            # if up_whitesquare_3 is active this frame...
            if up_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_3 is stopping this frame...
            if up_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_3.tStop = t  # not accounting for scr refresh
                    up_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_3.stopped')
                    # update status
                    up_whitesquare_3.status = FINISHED
                    up_whitesquare_3.setAutoDraw(False)
            
            # *down_whitesquare_3* updates
            
            # if down_whitesquare_3 is starting this frame...
            if down_whitesquare_3.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_3.frameNStart = frameN  # exact frame index
                down_whitesquare_3.tStart = t  # local t and not account for scr refresh
                down_whitesquare_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_3.started')
                # update status
                down_whitesquare_3.status = STARTED
                down_whitesquare_3.setAutoDraw(True)
            
            # if down_whitesquare_3 is active this frame...
            if down_whitesquare_3.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_3 is stopping this frame...
            if down_whitesquare_3.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_3.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_3.tStop = t  # not accounting for scr refresh
                    down_whitesquare_3.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_3.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_3.stopped')
                    # update status
                    down_whitesquare_3.status = FINISHED
                    down_whitesquare_3.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_up" ---
        for thisComponent in upA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_up
        upA_on_up.tStop = globalClock.getTime(format='float')
        upA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_up.stopped', upA_on_up.tStop)
        # check responses
        if key_resp_25.keys in ['', [], None]:  # No response was made
            key_resp_25.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_25.corr = 1;  # correct non-response
            else:
               key_resp_25.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_25.keys',key_resp_25.keys)
        trials_b6.addData('key_resp_25.corr', key_resp_25.corr)
        if key_resp_25.keys != None:  # we had a response
            trials_b6.addData('key_resp_25.rt', key_resp_25.rt)
            trials_b6.addData('key_resp_25.duration', key_resp_25.duration)
        # the Routine "upA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "upA_on_down" ---
        # create an object to store info about Routine upA_on_down
        upA_on_down = data.Routine(
            name='upA_on_down',
            components=[blacksquare_23, white_cross_23, key_resp_26, arrow_u_2, up_whitesquare_7, down_whitesquare_7],
        )
        upA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_26
        key_resp_26.keys = []
        key_resp_26.rt = []
        _key_resp_26_allKeys = []
        # Run 'Begin Routine' code from code_19
        
        
        if currentRoutine != "upA_on_down":
            continueRoutine = False
        
        # store start times for upA_on_down
        upA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        upA_on_down.tStart = globalClock.getTime(format='float')
        upA_on_down.status = STARTED
        thisExp.addData('upA_on_down.started', upA_on_down.tStart)
        upA_on_down.maxDuration = None
        # keep track of which components have finished
        upA_on_downComponents = upA_on_down.components
        for thisComponent in upA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "upA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        upA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_23* updates
            
            # if blacksquare_23 is starting this frame...
            if blacksquare_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_23.frameNStart = frameN  # exact frame index
                blacksquare_23.tStart = t  # local t and not account for scr refresh
                blacksquare_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_23.started')
                # update status
                blacksquare_23.status = STARTED
                blacksquare_23.setAutoDraw(True)
            
            # if blacksquare_23 is active this frame...
            if blacksquare_23.status == STARTED:
                # update params
                pass
            
            # *white_cross_23* updates
            
            # if white_cross_23 is starting this frame...
            if white_cross_23.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_23.frameNStart = frameN  # exact frame index
                white_cross_23.tStart = t  # local t and not account for scr refresh
                white_cross_23.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_23, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_23.started')
                # update status
                white_cross_23.status = STARTED
                white_cross_23.setAutoDraw(True)
            
            # if white_cross_23 is active this frame...
            if white_cross_23.status == STARTED:
                # update params
                pass
            
            # *key_resp_26* updates
            waitOnFlip = False
            
            # if key_resp_26 is starting this frame...
            if key_resp_26.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_26.frameNStart = frameN  # exact frame index
                key_resp_26.tStart = t  # local t and not account for scr refresh
                key_resp_26.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_26, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_26.started')
                # update status
                key_resp_26.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_26.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_26.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_26.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_26.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_26_allKeys.extend(theseKeys)
                if len(_key_resp_26_allKeys):
                    key_resp_26.keys = _key_resp_26_allKeys[-1].name  # just the last key pressed
                    key_resp_26.rt = _key_resp_26_allKeys[-1].rt
                    key_resp_26.duration = _key_resp_26_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_26.keys == str('left')) or (key_resp_26.keys == 'left'):
                        key_resp_26.corr = 1
                    else:
                        key_resp_26.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_2* updates
            
            # if arrow_u_2 is starting this frame...
            if arrow_u_2.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_2.frameNStart = frameN  # exact frame index
                arrow_u_2.tStart = t  # local t and not account for scr refresh
                arrow_u_2.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_2, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_2.started')
                # update status
                arrow_u_2.status = STARTED
                arrow_u_2.setAutoDraw(True)
            
            # if arrow_u_2 is active this frame...
            if arrow_u_2.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_7* updates
            
            # if up_whitesquare_7 is starting this frame...
            if up_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_7.frameNStart = frameN  # exact frame index
                up_whitesquare_7.tStart = t  # local t and not account for scr refresh
                up_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_7.started')
                # update status
                up_whitesquare_7.status = STARTED
                up_whitesquare_7.setAutoDraw(True)
            
            # if up_whitesquare_7 is active this frame...
            if up_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_7 is stopping this frame...
            if up_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_7.tStop = t  # not accounting for scr refresh
                    up_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_7.stopped')
                    # update status
                    up_whitesquare_7.status = FINISHED
                    up_whitesquare_7.setAutoDraw(False)
            
            # *down_whitesquare_7* updates
            
            # if down_whitesquare_7 is starting this frame...
            if down_whitesquare_7.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_7.frameNStart = frameN  # exact frame index
                down_whitesquare_7.tStart = t  # local t and not account for scr refresh
                down_whitesquare_7.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_7, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_7.started')
                # update status
                down_whitesquare_7.status = STARTED
                down_whitesquare_7.setAutoDraw(True)
            
            # if down_whitesquare_7 is active this frame...
            if down_whitesquare_7.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_7 is stopping this frame...
            if down_whitesquare_7.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_7.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_7.tStop = t  # not accounting for scr refresh
                    down_whitesquare_7.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_7.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_7.stopped')
                    # update status
                    down_whitesquare_7.status = FINISHED
                    down_whitesquare_7.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                upA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in upA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "upA_on_down" ---
        for thisComponent in upA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for upA_on_down
        upA_on_down.tStop = globalClock.getTime(format='float')
        upA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('upA_on_down.stopped', upA_on_down.tStop)
        # check responses
        if key_resp_26.keys in ['', [], None]:  # No response was made
            key_resp_26.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_26.corr = 1;  # correct non-response
            else:
               key_resp_26.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_26.keys',key_resp_26.keys)
        trials_b6.addData('key_resp_26.corr', key_resp_26.corr)
        if key_resp_26.keys != None:  # we had a response
            trials_b6.addData('key_resp_26.rt', key_resp_26.rt)
            trials_b6.addData('key_resp_26.duration', key_resp_26.duration)
        # the Routine "upA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_down" ---
        # create an object to store info about Routine downA_on_down
        downA_on_down = data.Routine(
            name='downA_on_down',
            components=[blacksquare_24, white_cross_24, key_resp_27, arrow_u_3, up_whitesquare_9, down_whitesquare_9],
        )
        downA_on_down.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_27
        key_resp_27.keys = []
        key_resp_27.rt = []
        _key_resp_27_allKeys = []
        # Run 'Begin Routine' code from code_21
        
        
        if currentRoutine != "downA_on_down":
            continueRoutine = False
        
        # store start times for downA_on_down
        downA_on_down.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_down.tStart = globalClock.getTime(format='float')
        downA_on_down.status = STARTED
        thisExp.addData('downA_on_down.started', downA_on_down.tStart)
        downA_on_down.maxDuration = None
        # keep track of which components have finished
        downA_on_downComponents = downA_on_down.components
        for thisComponent in downA_on_down.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_down" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        downA_on_down.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_24* updates
            
            # if blacksquare_24 is starting this frame...
            if blacksquare_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_24.frameNStart = frameN  # exact frame index
                blacksquare_24.tStart = t  # local t and not account for scr refresh
                blacksquare_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_24.started')
                # update status
                blacksquare_24.status = STARTED
                blacksquare_24.setAutoDraw(True)
            
            # if blacksquare_24 is active this frame...
            if blacksquare_24.status == STARTED:
                # update params
                pass
            
            # *white_cross_24* updates
            
            # if white_cross_24 is starting this frame...
            if white_cross_24.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_24.frameNStart = frameN  # exact frame index
                white_cross_24.tStart = t  # local t and not account for scr refresh
                white_cross_24.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_24, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_24.started')
                # update status
                white_cross_24.status = STARTED
                white_cross_24.setAutoDraw(True)
            
            # if white_cross_24 is active this frame...
            if white_cross_24.status == STARTED:
                # update params
                pass
            
            # *key_resp_27* updates
            waitOnFlip = False
            
            # if key_resp_27 is starting this frame...
            if key_resp_27.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_27.frameNStart = frameN  # exact frame index
                key_resp_27.tStart = t  # local t and not account for scr refresh
                key_resp_27.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_27, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_27.started')
                # update status
                key_resp_27.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_27.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_27.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_27.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_27.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_27_allKeys.extend(theseKeys)
                if len(_key_resp_27_allKeys):
                    key_resp_27.keys = _key_resp_27_allKeys[-1].name  # just the last key pressed
                    key_resp_27.rt = _key_resp_27_allKeys[-1].rt
                    key_resp_27.duration = _key_resp_27_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_27.keys == str('left')) or (key_resp_27.keys == 'left'):
                        key_resp_27.corr = 1
                    else:
                        key_resp_27.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_3* updates
            
            # if arrow_u_3 is starting this frame...
            if arrow_u_3.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_3.frameNStart = frameN  # exact frame index
                arrow_u_3.tStart = t  # local t and not account for scr refresh
                arrow_u_3.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_3, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_3.started')
                # update status
                arrow_u_3.status = STARTED
                arrow_u_3.setAutoDraw(True)
            
            # if arrow_u_3 is active this frame...
            if arrow_u_3.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_9* updates
            
            # if up_whitesquare_9 is starting this frame...
            if up_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_9.frameNStart = frameN  # exact frame index
                up_whitesquare_9.tStart = t  # local t and not account for scr refresh
                up_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_9.started')
                # update status
                up_whitesquare_9.status = STARTED
                up_whitesquare_9.setAutoDraw(True)
            
            # if up_whitesquare_9 is active this frame...
            if up_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_9 is stopping this frame...
            if up_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_9.tStop = t  # not accounting for scr refresh
                    up_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_9.stopped')
                    # update status
                    up_whitesquare_9.status = FINISHED
                    up_whitesquare_9.setAutoDraw(False)
            
            # *down_whitesquare_9* updates
            
            # if down_whitesquare_9 is starting this frame...
            if down_whitesquare_9.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_9.frameNStart = frameN  # exact frame index
                down_whitesquare_9.tStart = t  # local t and not account for scr refresh
                down_whitesquare_9.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_9, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_9.started')
                # update status
                down_whitesquare_9.status = STARTED
                down_whitesquare_9.setAutoDraw(True)
            
            # if down_whitesquare_9 is active this frame...
            if down_whitesquare_9.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_9 is stopping this frame...
            if down_whitesquare_9.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_9.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_9.tStop = t  # not accounting for scr refresh
                    down_whitesquare_9.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_9.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_9.stopped')
                    # update status
                    down_whitesquare_9.status = FINISHED
                    down_whitesquare_9.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_down.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_down.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_down" ---
        for thisComponent in downA_on_down.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_down
        downA_on_down.tStop = globalClock.getTime(format='float')
        downA_on_down.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_down.stopped', downA_on_down.tStop)
        # check responses
        if key_resp_27.keys in ['', [], None]:  # No response was made
            key_resp_27.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_27.corr = 1;  # correct non-response
            else:
               key_resp_27.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_27.keys',key_resp_27.keys)
        trials_b6.addData('key_resp_27.corr', key_resp_27.corr)
        if key_resp_27.keys != None:  # we had a response
            trials_b6.addData('key_resp_27.rt', key_resp_27.rt)
            trials_b6.addData('key_resp_27.duration', key_resp_27.duration)
        # the Routine "downA_on_down" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        
        # --- Prepare to start Routine "downA_on_up" ---
        # create an object to store info about Routine downA_on_up
        downA_on_up = data.Routine(
            name='downA_on_up',
            components=[blacksquare_25, white_cross_25, key_resp_28, arrow_u_4, up_whitesquare_5, down_whitesquare_5],
        )
        downA_on_up.status = NOT_STARTED
        continueRoutine = True
        # update component parameters for each repeat
        # create starting attributes for key_resp_28
        key_resp_28.keys = []
        key_resp_28.rt = []
        _key_resp_28_allKeys = []
        # Run 'Begin Routine' code from code_17
        
        
        if currentRoutine != "downA_on_up":
            continueRoutine = False
        
        # store start times for downA_on_up
        downA_on_up.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
        downA_on_up.tStart = globalClock.getTime(format='float')
        downA_on_up.status = STARTED
        thisExp.addData('downA_on_up.started', downA_on_up.tStart)
        downA_on_up.maxDuration = None
        # keep track of which components have finished
        downA_on_upComponents = downA_on_up.components
        for thisComponent in downA_on_up.components:
            thisComponent.tStart = None
            thisComponent.tStop = None
            thisComponent.tStartRefresh = None
            thisComponent.tStopRefresh = None
            if hasattr(thisComponent, 'status'):
                thisComponent.status = NOT_STARTED
        # reset timers
        t = 0
        _timeToFirstFrame = win.getFutureFlipTime(clock="now")
        frameN = -1
        
        # --- Run Routine "downA_on_up" ---
        # if trial has changed, end Routine now
        if isinstance(trials_b6, data.TrialHandler2) and thisTrials_b6.thisN != trials_b6.thisTrial.thisN:
            continueRoutine = False
        downA_on_up.forceEnded = routineForceEnded = not continueRoutine
        while continueRoutine:
            # get current time
            t = routineTimer.getTime()
            tThisFlip = win.getFutureFlipTime(clock=routineTimer)
            tThisFlipGlobal = win.getFutureFlipTime(clock=None)
            frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
            # update/draw components on each frame
            
            # *blacksquare_25* updates
            
            # if blacksquare_25 is starting this frame...
            if blacksquare_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                blacksquare_25.frameNStart = frameN  # exact frame index
                blacksquare_25.tStart = t  # local t and not account for scr refresh
                blacksquare_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(blacksquare_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'blacksquare_25.started')
                # update status
                blacksquare_25.status = STARTED
                blacksquare_25.setAutoDraw(True)
            
            # if blacksquare_25 is active this frame...
            if blacksquare_25.status == STARTED:
                # update params
                pass
            
            # *white_cross_25* updates
            
            # if white_cross_25 is starting this frame...
            if white_cross_25.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
                # keep track of start time/frame for later
                white_cross_25.frameNStart = frameN  # exact frame index
                white_cross_25.tStart = t  # local t and not account for scr refresh
                white_cross_25.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(white_cross_25, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'white_cross_25.started')
                # update status
                white_cross_25.status = STARTED
                white_cross_25.setAutoDraw(True)
            
            # if white_cross_25 is active this frame...
            if white_cross_25.status == STARTED:
                # update params
                pass
            
            # *key_resp_28* updates
            waitOnFlip = False
            
            # if key_resp_28 is starting this frame...
            if key_resp_28.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                key_resp_28.frameNStart = frameN  # exact frame index
                key_resp_28.tStart = t  # local t and not account for scr refresh
                key_resp_28.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(key_resp_28, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'key_resp_28.started')
                # update status
                key_resp_28.status = STARTED
                # keyboard checking is just starting
                waitOnFlip = True
                win.callOnFlip(key_resp_28.clock.reset)  # t=0 on next screen flip
                win.callOnFlip(key_resp_28.clearEvents, eventType='keyboard')  # clear events on next screen flip
            if key_resp_28.status == STARTED and not waitOnFlip:
                theseKeys = key_resp_28.getKeys(keyList=['left', 'right', 'up', 'down'], ignoreKeys=["escape"], waitRelease=False)
                _key_resp_28_allKeys.extend(theseKeys)
                if len(_key_resp_28_allKeys):
                    key_resp_28.keys = _key_resp_28_allKeys[-1].name  # just the last key pressed
                    key_resp_28.rt = _key_resp_28_allKeys[-1].rt
                    key_resp_28.duration = _key_resp_28_allKeys[-1].duration
                    # was this correct?
                    if (key_resp_28.keys == str('left')) or (key_resp_28.keys == 'left'):
                        key_resp_28.corr = 1
                    else:
                        key_resp_28.corr = 0
                    # a response ends the routine
                    continueRoutine = False
            
            # *arrow_u_4* updates
            
            # if arrow_u_4 is starting this frame...
            if arrow_u_4.status == NOT_STARTED and tThisFlip >= 0.5-frameTolerance:
                # keep track of start time/frame for later
                arrow_u_4.frameNStart = frameN  # exact frame index
                arrow_u_4.tStart = t  # local t and not account for scr refresh
                arrow_u_4.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(arrow_u_4, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'arrow_u_4.started')
                # update status
                arrow_u_4.status = STARTED
                arrow_u_4.setAutoDraw(True)
            
            # if arrow_u_4 is active this frame...
            if arrow_u_4.status == STARTED:
                # update params
                pass
            
            # *up_whitesquare_5* updates
            
            # if up_whitesquare_5 is starting this frame...
            if up_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                up_whitesquare_5.frameNStart = frameN  # exact frame index
                up_whitesquare_5.tStart = t  # local t and not account for scr refresh
                up_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(up_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'up_whitesquare_5.started')
                # update status
                up_whitesquare_5.status = STARTED
                up_whitesquare_5.setAutoDraw(True)
            
            # if up_whitesquare_5 is active this frame...
            if up_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if up_whitesquare_5 is stopping this frame...
            if up_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > up_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    up_whitesquare_5.tStop = t  # not accounting for scr refresh
                    up_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    up_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'up_whitesquare_5.stopped')
                    # update status
                    up_whitesquare_5.status = FINISHED
                    up_whitesquare_5.setAutoDraw(False)
            
            # *down_whitesquare_5* updates
            
            # if down_whitesquare_5 is starting this frame...
            if down_whitesquare_5.status == NOT_STARTED and tThisFlip >= 0.4-frameTolerance:
                # keep track of start time/frame for later
                down_whitesquare_5.frameNStart = frameN  # exact frame index
                down_whitesquare_5.tStart = t  # local t and not account for scr refresh
                down_whitesquare_5.tStartRefresh = tThisFlipGlobal  # on global time
                win.timeOnFlip(down_whitesquare_5, 'tStartRefresh')  # time at next scr refresh
                # add timestamp to datafile
                thisExp.timestampOnFlip(win, 'down_whitesquare_5.started')
                # update status
                down_whitesquare_5.status = STARTED
                down_whitesquare_5.setAutoDraw(True)
            
            # if down_whitesquare_5 is active this frame...
            if down_whitesquare_5.status == STARTED:
                # update params
                pass
            
            # if down_whitesquare_5 is stopping this frame...
            if down_whitesquare_5.status == STARTED:
                # is it time to stop? (based on global clock, using actual start)
                if tThisFlipGlobal > down_whitesquare_5.tStartRefresh + 0.1-frameTolerance:
                    # keep track of stop time/frame for later
                    down_whitesquare_5.tStop = t  # not accounting for scr refresh
                    down_whitesquare_5.tStopRefresh = tThisFlipGlobal  # on global time
                    down_whitesquare_5.frameNStop = frameN  # exact frame index
                    # add timestamp to datafile
                    thisExp.timestampOnFlip(win, 'down_whitesquare_5.stopped')
                    # update status
                    down_whitesquare_5.status = FINISHED
                    down_whitesquare_5.setAutoDraw(False)
            
            # check for quit (typically the Esc key)
            if defaultKeyboard.getKeys(keyList=["escape"]):
                thisExp.status = FINISHED
            if thisExp.status == FINISHED or endExpNow:
                endExperiment(thisExp, win=win)
                return
            # pause experiment here if requested
            if thisExp.status == PAUSED:
                pauseExperiment(
                    thisExp=thisExp, 
                    win=win, 
                    timers=[routineTimer], 
                    playbackComponents=[]
                )
                # skip the frame we paused on
                continue
            
            # check if all components have finished
            if not continueRoutine:  # a component has requested a forced-end of Routine
                downA_on_up.forceEnded = routineForceEnded = True
                break
            continueRoutine = False  # will revert to True if at least one component still running
            for thisComponent in downA_on_up.components:
                if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                    continueRoutine = True
                    break  # at least one component has not yet finished
            
            # refresh the screen
            if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
                win.flip()
        
        # --- Ending Routine "downA_on_up" ---
        for thisComponent in downA_on_up.components:
            if hasattr(thisComponent, "setAutoDraw"):
                thisComponent.setAutoDraw(False)
        # store stop times for downA_on_up
        downA_on_up.tStop = globalClock.getTime(format='float')
        downA_on_up.tStopRefresh = tThisFlipGlobal
        thisExp.addData('downA_on_up.stopped', downA_on_up.tStop)
        # check responses
        if key_resp_28.keys in ['', [], None]:  # No response was made
            key_resp_28.keys = None
            # was no response the correct answer?!
            if str('left').lower() == 'none':
               key_resp_28.corr = 1;  # correct non-response
            else:
               key_resp_28.corr = 0;  # failed to respond (incorrectly)
        # store data for trials_b6 (TrialHandler)
        trials_b6.addData('key_resp_28.keys',key_resp_28.keys)
        trials_b6.addData('key_resp_28.corr', key_resp_28.corr)
        if key_resp_28.keys != None:  # we had a response
            trials_b6.addData('key_resp_28.rt', key_resp_28.rt)
            trials_b6.addData('key_resp_28.duration', key_resp_28.duration)
        # the Routine "downA_on_up" was not non-slip safe, so reset the non-slip timer
        routineTimer.reset()
        thisExp.nextEntry()
        
    # completed 32.0 repeats of 'trials_b6'
    
    if thisSession is not None:
        # if running in a Session with a Liaison client, send data up to now
        thisSession.sendExperimentData()
    
    # --- Prepare to start Routine "end" ---
    # create an object to store info about Routine end
    end = data.Routine(
        name='end',
        components=[text_37, text_38, key_resp_34],
    )
    end.status = NOT_STARTED
    continueRoutine = True
    # update component parameters for each repeat
    # create starting attributes for key_resp_34
    key_resp_34.keys = []
    key_resp_34.rt = []
    _key_resp_34_allKeys = []
    # store start times for end
    end.tStartRefresh = win.getFutureFlipTime(clock=globalClock)
    end.tStart = globalClock.getTime(format='float')
    end.status = STARTED
    thisExp.addData('end.started', end.tStart)
    end.maxDuration = None
    # keep track of which components have finished
    endComponents = end.components
    for thisComponent in end.components:
        thisComponent.tStart = None
        thisComponent.tStop = None
        thisComponent.tStartRefresh = None
        thisComponent.tStopRefresh = None
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    # reset timers
    t = 0
    _timeToFirstFrame = win.getFutureFlipTime(clock="now")
    frameN = -1
    
    # --- Run Routine "end" ---
    end.forceEnded = routineForceEnded = not continueRoutine
    while continueRoutine:
        # get current time
        t = routineTimer.getTime()
        tThisFlip = win.getFutureFlipTime(clock=routineTimer)
        tThisFlipGlobal = win.getFutureFlipTime(clock=None)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        # update/draw components on each frame
        
        # *text_37* updates
        
        # if text_37 is starting this frame...
        if text_37.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_37.frameNStart = frameN  # exact frame index
            text_37.tStart = t  # local t and not account for scr refresh
            text_37.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_37, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_37.started')
            # update status
            text_37.status = STARTED
            text_37.setAutoDraw(True)
        
        # if text_37 is active this frame...
        if text_37.status == STARTED:
            # update params
            pass
        
        # *text_38* updates
        
        # if text_38 is starting this frame...
        if text_38.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            text_38.frameNStart = frameN  # exact frame index
            text_38.tStart = t  # local t and not account for scr refresh
            text_38.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(text_38, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'text_38.started')
            # update status
            text_38.status = STARTED
            text_38.setAutoDraw(True)
        
        # if text_38 is active this frame...
        if text_38.status == STARTED:
            # update params
            pass
        
        # *key_resp_34* updates
        waitOnFlip = False
        
        # if key_resp_34 is starting this frame...
        if key_resp_34.status == NOT_STARTED and tThisFlip >= 0.0-frameTolerance:
            # keep track of start time/frame for later
            key_resp_34.frameNStart = frameN  # exact frame index
            key_resp_34.tStart = t  # local t and not account for scr refresh
            key_resp_34.tStartRefresh = tThisFlipGlobal  # on global time
            win.timeOnFlip(key_resp_34, 'tStartRefresh')  # time at next scr refresh
            # add timestamp to datafile
            thisExp.timestampOnFlip(win, 'key_resp_34.started')
            # update status
            key_resp_34.status = STARTED
            # keyboard checking is just starting
            waitOnFlip = True
            win.callOnFlip(key_resp_34.clock.reset)  # t=0 on next screen flip
            win.callOnFlip(key_resp_34.clearEvents, eventType='keyboard')  # clear events on next screen flip
        if key_resp_34.status == STARTED and not waitOnFlip:
            theseKeys = key_resp_34.getKeys(keyList=['space'], ignoreKeys=["escape"], waitRelease=False)
            _key_resp_34_allKeys.extend(theseKeys)
            if len(_key_resp_34_allKeys):
                key_resp_34.keys = _key_resp_34_allKeys[-1].name  # just the last key pressed
                key_resp_34.rt = _key_resp_34_allKeys[-1].rt
                key_resp_34.duration = _key_resp_34_allKeys[-1].duration
                # a response ends the routine
                continueRoutine = False
        
        # check for quit (typically the Esc key)
        if defaultKeyboard.getKeys(keyList=["escape"]):
            thisExp.status = FINISHED
        if thisExp.status == FINISHED or endExpNow:
            endExperiment(thisExp, win=win)
            return
        # pause experiment here if requested
        if thisExp.status == PAUSED:
            pauseExperiment(
                thisExp=thisExp, 
                win=win, 
                timers=[routineTimer], 
                playbackComponents=[]
            )
            # skip the frame we paused on
            continue
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            end.forceEnded = routineForceEnded = True
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in end.components:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
    
    # --- Ending Routine "end" ---
    for thisComponent in end.components:
        if hasattr(thisComponent, "setAutoDraw"):
            thisComponent.setAutoDraw(False)
    # store stop times for end
    end.tStop = globalClock.getTime(format='float')
    end.tStopRefresh = tThisFlipGlobal
    thisExp.addData('end.stopped', end.tStop)
    # check responses
    if key_resp_34.keys in ['', [], None]:  # No response was made
        key_resp_34.keys = None
    thisExp.addData('key_resp_34.keys',key_resp_34.keys)
    if key_resp_34.keys != None:  # we had a response
        thisExp.addData('key_resp_34.rt', key_resp_34.rt)
        thisExp.addData('key_resp_34.duration', key_resp_34.duration)
    thisExp.nextEntry()
    # the Routine "end" was not non-slip safe, so reset the non-slip timer
    routineTimer.reset()
    
    # mark experiment as finished
    endExperiment(thisExp, win=win)


def saveData(thisExp):
    """
    Save data from this experiment
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    """
    filename = thisExp.dataFileName
    # these shouldn't be strictly necessary (should auto-save)
    thisExp.saveAsWideText(filename + '.csv', delim='auto')
    thisExp.saveAsPickle(filename)


def endExperiment(thisExp, win=None):
    """
    End this experiment, performing final shut down operations.
    
    This function does NOT close the window or end the Python process - use `quit` for this.
    
    Parameters
    ==========
    thisExp : psychopy.data.ExperimentHandler
        Handler object for this experiment, contains the data to save and information about 
        where to save it to.
    win : psychopy.visual.Window
        Window for this experiment.
    """
    if win is not None:
        # remove autodraw from all current components
        win.clearAutoDraw()
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed
        win.flip()
    # return console logger level to WARNING
    logging.console.setLevel(logging.WARNING)
    # mark experiment handler as finished
    thisExp.status = FINISHED
    logging.flush()


def quit(thisExp, win=None, thisSession=None):
    """
    Fully quit, closing the window and ending the Python process.
    
    Parameters
    ==========
    win : psychopy.visual.Window
        Window to close.
    thisSession : psychopy.session.Session or None
        Handle of the Session object this experiment is being run from, if any.
    """
    thisExp.abort()  # or data files will save again on exit
    # make sure everything is closed down
    if win is not None:
        # Flip one final time so any remaining win.callOnFlip() 
        # and win.timeOnFlip() tasks get executed before quitting
        win.flip()
        win.close()
    logging.flush()
    if thisSession is not None:
        thisSession.stop()
    # terminate Python process
    core.quit()


# if running this experiment as a script...
if __name__ == '__main__':
    # call all functions in order
    expInfo = showExpInfoDlg(expInfo=expInfo)
    thisExp = setupData(expInfo=expInfo)
    logFile = setupLogging(filename=thisExp.dataFileName)
    win = setupWindow(expInfo=expInfo)
    setupDevices(expInfo=expInfo, thisExp=thisExp, win=win)
    run(
        expInfo=expInfo, 
        thisExp=thisExp, 
        win=win,
        globalClock='float'
    )
    saveData(thisExp=thisExp)
    quit(thisExp=thisExp, win=win)
